[{"id":1, "name":"-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "fullmethod":"de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n * @param engine\r\n * \t\tThe current engine.\r\n * @param board\r\n * \t\tThe current board.\r\n * @param timer\r\n * \t\tThe game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}"},
 {"id":2, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.GameController.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Process a event, that we are listening to.\r\n *\r\n * @param event\r\n * \t\tThe event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    System.out.println((\"Got event \" + (event.getActionCommand())));\r\n    // If the timer fired the event, check for timeout.\r\n    if ((event.getSource()) == (getGameTimer())) {\r\n        String command = event.getActionCommand();\r\n        if (\"timeout white\".equals(command)) {\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for you! I win!\");\r\n        }\r\n        if (\"timeout black\".equals(command)) {\r\n            System.out.println(\"Black timeout!\");\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for me! You win!\");\r\n        }\r\n    }\r\n}"},
 {"id":3, "name":"computerPly()", "fullmethod":"de.java_chess.javaChess.GameController.computerPly()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Let the computer make a move.\r\n */\r\npublic final boolean computerPly() {\r\n    Ply nextPly = getEngine().computeBestPly();\r\n    if (nextPly == null) {\r\n        System.out.println(\"No computer move returned\");\r\n        return false;\r\n    } else {\r\n        doPly(nextPly);\r\n        getEngine().startPermanentBrain();\r\n        return true;\r\n    }\r\n}"},
 {"id":4, "name":"convertUserPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}"},
 {"id":5, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.GameController.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to do.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    // If the game is over, stop here.\r\n    if ((_gameState) == (GameState.TIMEOUT)) {\r\n        return;\r\n    }\r\n    // Store the ply notation to set the check flags a bit later, since they are computed in the gameOver()\r\n    // call in the move right toggle.\r\n    PlyNotation plyNotation = new PlyNotationImpl(ply, getBoard().getPiece(ply.getSource()));\r\n    getGame().doPly(ply);\r\n    getBoard().doPly(ply);\r\n    getRenderer().doPly(ply);\r\n    // Now try to get some info on the current game state.\r\n    boolean gameOver = gameOver((!(_moveRight)));\r\n    // Set check info for this ply.\r\n    if ((_gameState) == (GameState.CHECKMATE)) {\r\n        plyNotation.setCheckMate(true);\r\n    } else {\r\n        if ((_gameState) == (GameState.CHECK)) {\r\n            plyNotation.setCheck(true);\r\n        }\r\n    }\r\n    // Add the ply to the notation.\r\n    getGameNotation().addPly(plyNotation);\r\n    if (gameOver) {\r\n        getGameTimer().stop();// The game has ended.\r\n\r\n        if ((_gameState) == (GameState.DRAW)) {\r\n            signalGameOver(\"Draw! Use File -> Reset to play again!\");\r\n        } else {\r\n            signalGameOver(((_moveRight) == (_computerIsWhite) ? \"Checkmate! I win! :-)\" : \"Checkmate! I lose... :-(\"));\r\n        }\r\n    } else {\r\n        toggleMoveRight();\r\n    }\r\n}"},
 {"id":6, "name":"gameOver(boolean)", "fullmethod":"de.java_chess.javaChess.GameController.gameOver(boolean)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Check if the game is over.\r\n *\r\n * @param white\r\n * \t\tTrue, if white is about to move.\r\n * @return true, if the game is over.\r\n */\r\nprivate final boolean gameOver(boolean white) {\r\n    _gameState = getEngine().getCurrentGameState(white);\r\n    return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW));\r\n}"},
 {"id":7, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.GameController.getBoard()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":8, "name":"getEngine()", "fullmethod":"de.java_chess.javaChess.GameController.getEngine()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nfinal ChessEngine getEngine() {\r\n    return _engine;\r\n}"},
 {"id":9, "name":"getGame()", "fullmethod":"de.java_chess.javaChess.GameController.getGame()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":10, "name":"getGameNotation()", "fullmethod":"de.java_chess.javaChess.GameController.getGameNotation()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Get the current game notation.\r\n *\r\n * @return The current game notation.\r\n */\r\npublic final GameNotation getGameNotation() {\r\n    return _gameNotation;\r\n}"},
 {"id":11, "name":"getGameTimer()", "fullmethod":"de.java_chess.javaChess.GameController.getGameTimer()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Get the current game timer.\r\n *\r\n * @return The current game timer.\r\n */\r\nfinal GameTimer getGameTimer() {\r\n    return _gameTimer;\r\n}"},
 {"id":12, "name":"getRenderer()", "fullmethod":"de.java_chess.javaChess.GameController.getRenderer()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Get the renderer.\r\n *\r\n * @return The current renderer.\r\n */\r\nfinal ChessBoardRenderer getRenderer() {\r\n    return _renderer;\r\n}"},
 {"id":13, "name":"reset()", "fullmethod":"de.java_chess.javaChess.GameController.reset()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Reset the game controller.\r\n */\r\npublic final void reset() {\r\n    _moveRight = true;\r\n    // White has the first move.\r\n    _gameState = GameState.STOPPED;// The game is stopped until white moves.\r\n\r\n}"},
 {"id":14, "name":"setBoard(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.GameController.setBoard(de.java_chess.javaChess.board.Board)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nfinal void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":15, "name":"setEngine(de.java_chess.javaChess.engine.ChessEngine)", "fullmethod":"de.java_chess.javaChess.GameController.setEngine(de.java_chess.javaChess.engine.ChessEngine)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * \t\tThe new engine.\r\n */\r\nfinal void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}"},
 {"id":16, "name":"setGame(de.java_chess.javaChess.game.Game)", "fullmethod":"de.java_chess.javaChess.GameController.setGame(de.java_chess.javaChess.game.Game)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":17, "name":"setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.GameController.setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Set the current game notation.\r\n *\r\n * @param gameNotation\r\n * \t\tThe new game notation.\r\n */\r\npublic final void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":18, "name":"setGameTimer(de.java_chess.javaChess.timer.GameTimer)", "fullmethod":"de.java_chess.javaChess.GameController.setGameTimer(de.java_chess.javaChess.timer.GameTimer)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Set a new game timer.\r\n *\r\n * @param timer\r\n * \t\tThe new game timer.\r\n */\r\nfinal void setGameTimer(GameTimer timer) {\r\n    _gameTimer = timer;\r\n    timer.addActionListener(this);\r\n}"},
 {"id":19, "name":"setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)", "fullmethod":"de.java_chess.javaChess.GameController.setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Set a new renderer.\r\n *\r\n * @param renderer\r\n * \t\tThe new renderer.\r\n */\r\nfinal void setRenderer(ChessBoardRenderer renderer) {\r\n    _renderer = renderer;\r\n}"},
 {"id":20, "name":"signalGameOver(java.lang.String)", "fullmethod":"de.java_chess.javaChess.GameController.signalGameOver(java.lang.String)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Signal the end if the game.\r\n *\r\n * @param gameOverMessage\r\n * \t\tSome info how and why the game has ended.\r\n */\r\npublic final void signalGameOver(String gameOverMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, gameOverMessage, \"Game over\", JOptionPane.INFORMATION_MESSAGE);\r\n}"},
 {"id":21, "name":"signalUserInputError(java.lang.String)", "fullmethod":"de.java_chess.javaChess.GameController.signalUserInputError(java.lang.String)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Signal a input error to the user.\r\n *\r\n * @param errorMessage\r\n * \t\tMore information on the error.\r\n */\r\npublic final void signalUserInputError(String errorMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, errorMessage, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n}"},
 {"id":22, "name":"toggleMoveRight()", "fullmethod":"de.java_chess.javaChess.GameController.toggleMoveRight()", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * Turn the right to move from one player to the other.\r\n */\r\npublic void toggleMoveRight() {\r\n    _moveRight = !(_moveRight);\r\n    if (getGameTimer().isRunning()) {\r\n        getGameTimer().toggle();\r\n    } else {\r\n        getGameTimer().start();\r\n        _gameState = GameState.ONGOING;// Change the game state to running.\r\n\r\n    }\r\n    // Check if the computer has the next move.\r\n    if ((_moveRight) == (_computerIsWhite)) {\r\n        if (!(computerPly())) {\r\n            System.out.println(\"Computer cannot move!\");\r\n        }\r\n    }\r\n}"},
 {"id":23, "name":"userPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.GameController.userPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"1", "ownerclassname":"GameController", "sourcecode":"/**\r\n * The user moved a piece.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the user.\r\n */\r\npublic final void userPly(Ply ply) {\r\n    // Before any user ply can be applied, we have to stop\r\n    // the permanent brain, so the engine is free to process\r\n    // the user ply.\r\n    getEngine().stopPermanentBrain();\r\n    // plyInterpretation\r\n    ply = convertUserPly(ply);\r\n    // Check if the user has the right to move a piece\r\n    // and made a valid move.\r\n    if ((_moveRight) != (_computerIsWhite)) {\r\n        if ((((_gameState) != (GameState.CHECKMATE)) && ((_gameState) != (GameState.DRAW))) && ((_gameState) != (GameState.TIMEOUT))) {\r\n            if (getEngine().validateUserPly(ply)) {\r\n                doPly(ply);// Ok => move the piece.\r\n\r\n            } else {\r\n                // The user had to right to move or made an invalid move.\r\n                signalUserInputError(\"invalid move\");\r\n            }\r\n        } else {\r\n            signalUserInputError(\"game is already over\");\r\n        }\r\n    } else {\r\n        signalUserInputError(\"user is not about to move\");\r\n    }\r\n}"},
 {"id":24, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.JavaChess.-init-()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"1() {\r\n}"},
 {"id":25, "name":"busy()", "fullmethod":"de.java_chess.javaChess.JavaChess.busy()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"private void busy() {\r\n    glasspane.requestFocus();\r\n    glasspane.setVisible(true);\r\n}"},
 {"id":26, "name":"engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "fullmethod":"de.java_chess.javaChess.JavaChess.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"public void engineStatusChanged(ChessEngineImpl engine) {\r\n    if ((this.jpStatus) != null) {\r\n        this.jpStatus.setActionText(engine.getStatusDisplayString());\r\n    }\r\n}"},
 {"id":27, "name":"free()", "fullmethod":"de.java_chess.javaChess.JavaChess.free()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"private void free() {\r\n    glasspane.setVisible(false);\r\n}"},
 {"id":28, "name":"getInstance()", "fullmethod":"de.java_chess.javaChess.JavaChess.getInstance()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"/**\r\n * Get the instance of this chess app.\r\n *\r\n * @return The instance of this chess app.\r\n */\r\npublic static final JavaChess getInstance() {\r\n    return JavaChess._instance;\r\n}"},
 {"id":29, "name":"getMenuItem(de.java_chess.javaChess.action.JavaChessAction)", "fullmethod":"de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * \t\tThe action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}"},
 {"id":30, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.JavaChess.jbInit()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"/**\r\n * Die GUI nach Nomenklatur des JBuilder\r\n *\r\n * @throws Exception\r\n * \t\t\r\n */\r\nprivate void jbInit() throws Exception {\r\n    // Add some location for resources to the resource loader.\r\n    ResourceLoader.getInstance().addLocation(\"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/\");\r\n    _game = new GameImpl();\r\n    _gameNotation = new GameNotationImpl();\r\n    _board = new BitBoardImpl();\r\n    _engine = new ChessEngineImpl(_game, _gameNotation, _board, false);\r\n    ((ChessEngineImpl) (_engine)).addEngineStatusListener(this);\r\n    // Create a timer with 40 min for each player.\r\n    _gameTimer = new GameTimerPanel((40 * 60));\r\n    _controller = new GameController(_game, _gameNotation, _engine, _board, _gameTimer);\r\n    _renderer = new ChessBoardRenderer2D(_controller, _board);\r\n    _controller.setRenderer(_renderer);\r\n    editMenu = new EditMenu();\r\n    this.jpNotation = new NotationPanel(_gameNotation);\r\n    ((GameNotationImpl) (_gameNotation)).setNotationPanel(jpNotation);\r\n    editMenu.setNotationPanel(jpNotation);\r\n    this.jpEngine = new EnginePanel();\r\n    ((ChessEngineImpl) (_engine)).setEnginePanel(jpEngine);\r\n    ((ChessEngineImpl) (_engine)).setStatusPanel(jpStatus);\r\n    this.jpNavigation = new NavigationPanel();\r\n    // setIconImage(Toolkit.getDefaultToolkit().createImage(VisFrame.class.getResource(\"jclogo.gif\")));\r\n    contentPane = ((JPanel) (this.getContentPane()));\r\n    contentPane.setLayout(new GridBagLayout());\r\n    this.setSize(new Dimension(800, 600));\r\n    this.addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent e) {\r\n            this_windowClosing(e);\r\n        }\r\n    });\r\n    JMenuBar menuBar = new JMenuBar();\r\n    JMenu fileMenu = new JMenu(\"File\");\r\n    fileMenu.setMnemonic(KeyEvent.VK_F);// Shortcut Alt-F\r\n\r\n    fileMenu.add(getMenuItem(new ResetGameAction()));\r\n    fileMenu.addSeparator();\r\n    fileMenu.add(getMenuItem(new LoadGameAction()));\r\n    fileMenu.addSeparator();\r\n    fileMenu.add(getMenuItem(new SaveGameAction(_gameNotation)));\r\n    fileMenu.add(getMenuItem(new SaveGameAsAction(_gameNotation)));\r\n    _exitItem = new JMenuItem(\"Exit\");\r\n    // Shortcut f\ufffdr ALT-X zum Beenden:\r\n    this._exitItem.setAccelerator(KeyStroke.getKeyStroke(88, KeyEvent.ALT_MASK, false));\r\n    _exitItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            System.exit(0);\r\n        }\r\n    });\r\n    // Create a separated exit item\r\n    fileMenu.addSeparator();\r\n    this.jpBrett.setLayout(gridBagBrett);\r\n    // this.jpBrett.setPreferredSize( new Dimension(520,520) );\r\n    // this.jpBrett.setMaximumSize( new Dimension(520,520) );\r\n    // this.jpBrett.setMinimumSize( new Dimension(520,520) );\r\n    this.jpBrett.setPreferredSize(new Dimension(430, 430));\r\n    // this.jpBrett.setMaximumSize( new Dimension(400,400) );\r\n    this.jpBrett.setMinimumSize(new Dimension(430, 430));\r\n    this.jpStatus.setPreferredSize(new Dimension(780, 20));\r\n    this.jpStatus.setMinimumSize(new Dimension(780, 20));\r\n    this.jpStatus.setMaximumSize(new Dimension(780, 20));\r\n    this.jpEngine.setPreferredSize(new Dimension(780, 150));\r\n    this.jpEngine.setMinimumSize(new Dimension(780, 150));\r\n    this.jpEngine.setMaximumSize(new Dimension(780, 150));\r\n    this.jpNavigation.setLayout(gridBagNavigation);\r\n    fileMenu.add(_exitItem);\r\n    // Add the file menu to the menu bar.\r\n    menuBar.add(fileMenu);\r\n    // Get the Edit menu from the according class and add to the menu bar.\r\n    menuBar.add(editMenu.getMenu());\r\n    // Get the menu from the chess engine and add it to the menu bar.\r\n    menuBar.add(_engine.getMenu());\r\n    this.engineStatusChanged(((ChessEngineImpl) (_engine)));\r\n    // Create and add a help menu\r\n    JMenu helpMenu = new JMenu(\"Help\");\r\n    helpMenu.add(new HelpAction());\r\n    helpMenu.addSeparator();\r\n    helpMenu.add(new AboutAction());\r\n    menuBar.add(Box.createHorizontalGlue());// Move the help menu to the right.\r\n\r\n    menuBar.add(helpMenu);\r\n    // Create and set the menu.\r\n    this.setJMenuBar(menuBar);\r\n    contentPane.setForeground(Color.black);\r\n    contentPane.add(jpBrett, new GridBagConstraints(0, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));// Brett\r\n\r\n    contentPane.add(_gameTimer, new GridBagConstraints(1, 1, 1, 1, 1.0, 0.0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));// The Clock\r\n\r\n    contentPane.add(jpEngine, new GridBagConstraints(0, 2, 2, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(2, 2, 2, 2), 0, 0));// Engineoutput\r\n\r\n    contentPane.add(jpStatus, new GridBagConstraints(0, 3, 2, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(2, 2, 2, 2), 0, 0));// Statuszeile\r\n\r\n    contentPane.add(jpNotation, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(2, 2, 2, 2), 0, 0));\r\n    contentPane.add(jpNavigation, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));// Notation etc.\r\n\r\n    jpBrett.add(((ChessBoardRenderer2D) (_renderer)), new GridBagConstraints(0, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    jpBrett.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.pack();\r\n    this.setVisible(true);\r\n}"},
 {"id":31, "name":"main(java.lang.String[])", "fullmethod":"de.java_chess.javaChess.JavaChess.main(java.lang.String[])", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"// Methods\r\n/**\r\n * The main method.\r\n *\r\n * @param args\r\n * \t\tThe commandline arguments.\r\n */\r\npublic static void main(String[] args) {\r\n    JavaChess._instance = new JavaChess();\r\n}"},
 {"id":32, "name":"packFrame()", "fullmethod":"de.java_chess.javaChess.JavaChess.packFrame()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"private Dimension packFrame() {\r\n    boolean packFrame = true;\r\n    if (packFrame) {\r\n        pack();\r\n    } else {\r\n        validate();\r\n    }\r\n    return this.getSize();\r\n}"},
 {"id":33, "name":"placeFrame(java.awt.Dimension,java.awt.Dimension)", "fullmethod":"de.java_chess.javaChess.JavaChess.placeFrame(java.awt.Dimension,java.awt.Dimension)", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"private void placeFrame(Dimension screenSize, Dimension frameSize) {\r\n    setLocation((((screenSize.width) - (frameSize.width)) / 2), (((screenSize.height) - (frameSize.height)) / 2));\r\n}"},
 {"id":34, "name":"reset()", "fullmethod":"de.java_chess.javaChess.JavaChess.reset()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"/**\r\n * Reset the game.\r\n */\r\npublic void reset() {\r\n    // Reset all the game components.\r\n    _game.reset();\r\n    _gameNotation.reset();\r\n    _board.initialPosition();\r\n    _engine.reset();\r\n    // Reset the timer to 40 min for each player.\r\n    _gameTimer.reset((40 * 60));\r\n    _controller.reset();\r\n    _renderer.reset();\r\n}"},
 {"id":35, "name":"setDefaultFrameCoordinates()", "fullmethod":"de.java_chess.javaChess.JavaChess.setDefaultFrameCoordinates()", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"private void setDefaultFrameCoordinates() {\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    Dimension frameSize = packFrame();\r\n    setFrameSize(screenSize, frameSize);\r\n    placeFrame(screenSize, frameSize);\r\n}"},
 {"id":36, "name":"setFrameSize(java.awt.Dimension,java.awt.Dimension)", "fullmethod":"de.java_chess.javaChess.JavaChess.setFrameSize(java.awt.Dimension,java.awt.Dimension)", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"private void setFrameSize(Dimension screenSize, Dimension frameSize) {\r\n    if ((frameSize.height) > (screenSize.height)) {\r\n        frameSize.height = screenSize.height;\r\n    }\r\n    if ((frameSize.width) > (screenSize.width)) {\r\n        frameSize.width = screenSize.width;\r\n    }\r\n}"},
 {"id":37, "name":"this_windowClosing(java.awt.event.WindowEvent)", "fullmethod":"de.java_chess.javaChess.JavaChess.this_windowClosing(java.awt.event.WindowEvent)", "ownerclassid":"3", "ownerclassname":"JavaChess", "sourcecode":"/**\r\n * If Java-Chess is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * \t\tThe Window event\r\n */\r\nvoid this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}"},
 {"id":38, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.AboutAction.-init-()", "ownerclassid":"4", "ownerclassname":"AboutAction", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic AboutAction() {\r\n    super(\"About\");\r\n}"},
 {"id":39, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.action.AboutAction.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"4", "ownerclassname":"AboutAction", "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    DialogAbout dialog = DialogAbout.getInstance();\r\n    if (dialog != null) {\r\n        Tools.setDialogToCenter(dialog);\r\n        dialog.show();\r\n    }\r\n}"},
 {"id":40, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.HelpAction.-init-()", "ownerclassid":"5", "ownerclassname":"HelpAction", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic HelpAction() {\r\n    super(\"Help\");\r\n}"},
 {"id":41, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.action.HelpAction.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"5", "ownerclassname":"HelpAction", "sourcecode":"// Methods\r\n/**\r\n * The action action.\r\n *\r\n * @param event\r\n * \t\tThe event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Just a dummy so far...\r\n}"},
 {"id":42, "name":"-init-(java.lang.String)", "fullmethod":"de.java_chess.javaChess.JavaChessAction.-init-(java.lang.String)", "ownerclassid":"6", "ownerclassname":"JavaChessAction", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new Java-Chess action.\r\n *\r\n * @param name\r\n * \t\tThe name of the action.\r\n */\r\npublic JavaChessAction(String name) {\r\n    super(name);\r\n    putValue(Action.SHORT_DESCRIPTION, name);\r\n}"},
 {"id":43, "name":"getName()", "fullmethod":"de.java_chess.javaChess.action.JavaChessAction.getName()", "ownerclassid":"6", "ownerclassname":"JavaChessAction", "sourcecode":"/**\r\n * Get the name of this action (which is currently the short description).\r\n *\r\n * @return The name of this action.\r\n */\r\npublic final String getName() {\r\n    return getShortDescription();\r\n}"},
 {"id":44, "name":"getShortDescription()", "fullmethod":"de.java_chess.javaChess.action.JavaChessAction.getShortDescription()", "ownerclassid":"6", "ownerclassname":"JavaChessAction", "sourcecode":"// Methods\r\n/**\r\n * Get the short description (the name) of this action.\r\n *\r\n * @return The short description of this action.\r\n */\r\npublic String getShortDescription() {\r\n    return ((String) (getValue(Action.SHORT_DESCRIPTION)));\r\n}"},
 {"id":45, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.LoadGameAction.-init-()", "ownerclassid":"7", "ownerclassname":"LoadGameAction", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic LoadGameAction() {\r\n    super(\"Load game\");\r\n}"},
 {"id":46, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.action.LoadGameAction.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"7", "ownerclassname":"LoadGameAction", "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Missing: save current project?\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        try {\r\n            PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n            GameNotation notation = pgnFile.readGame();\r\n        } catch (FileNotFoundException fe) {\r\n            JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n        } catch (RecognitionException re) {\r\n        } catch (TokenStreamException te) {\r\n        }\r\n    }\r\n}"},
 {"id":47, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.ResetGameAction.-init-()", "ownerclassid":"8", "ownerclassname":"ResetGameAction", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic ResetGameAction() {\r\n    super(\"Reset game\");\r\n}"},
 {"id":48, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.action.ResetGameAction.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"8", "ownerclassname":"ResetGameAction", "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JavaChess.getInstance().reset();\r\n}"},
 {"id":49, "name":"-init-(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.SaveGameAction.-init-(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"9", "ownerclassname":"SaveGameAction", "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * \t\tThe game notation.\r\n */\r\npublic SaveGameAction(GameNotation gameNotation) {\r\n    super(\"Save game\");\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":50, "name":"-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"9", "ownerclassname":"SaveGameAction", "sourcecode":"/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * \t\tThe name of the action.\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":51, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.action.SaveGameAction.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"9", "ownerclassname":"SaveGameAction", "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n}"},
 {"id":52, "name":"trySave(java.io.File)", "fullmethod":"de.java_chess.javaChess.action.SaveGameAction.trySave(java.io.File)", "ownerclassid":"9", "ownerclassname":"SaveGameAction", "sourcecode":"/**\r\n * Try to save the game into the given file.\r\n *\r\n * @param file\r\n * \t\tThe file to write into.\r\n */\r\npublic void trySave(File file) {\r\n    try {\r\n        PGNOutputStream PGNOutput = new PGNOutputStream(file);\r\n        // Write the notation of the game.\r\n        PGNOutput.write(_gameNotation);\r\n    } catch (IOException exception) {\r\n        JOptionPane.showMessageDialog(null, (\"Error while writing file: \" + (file.getName())), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n    }\r\n}"},
 {"id":53, "name":"-init-(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.SaveGameAsAction.-init-(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"10", "ownerclassname":"SaveGameAsAction", "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\npublic SaveGameAsAction(GameNotation gameNotation) {\r\n    super(\"Save game as...\", gameNotation);\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":54, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.action.SaveGameAsAction.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"10", "ownerclassname":"SaveGameAsAction", "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Create a new filechooser\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Saving game as pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showSaveDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        trySave(chooser.getSelectedFile());\r\n    }\r\n}"},
 {"id":55, "name":"getPGNFileFilter()", "fullmethod":"de.java_chess.javaChess.action.SaveGameAsAction.getPGNFileFilter()", "ownerclassid":"10", "ownerclassname":"SaveGameAsAction", "sourcecode":"/**\r\n * Get a PGN file filter.\r\n *\r\n * @return A PGN file filter.\r\n */\r\npublic static PGNFileFilter getPGNFileFilter() {\r\n    // To avoid the instanciation of too many object at app startup,\r\n    // less important object are created as needed.\r\n    if (null == (SaveGameAsAction._pgnFileFilter)) {\r\n        SaveGameAsAction._pgnFileFilter = new PGNFileFilter();\r\n    }\r\n    return SaveGameAsAction._pgnFileFilter;\r\n}"},
 {"id":56, "name":"getAllPiecesForColor(boolean)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoard.getAllPiecesForColor(boolean)", "ownerclassid":"11", "ownerclassname":"BitBoard", "sourcecode":"/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * \t\ttrue, if the white pieces are requested,\r\n * \t\tfalse for the black pieces.\r\n */\r\nlong getAllPiecesForColor(boolean white);"},
 {"id":57, "name":"getBytes()", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoard.getBytes()", "ownerclassid":"11", "ownerclassname":"BitBoard", "sourcecode":"/**\r\n * Get the board as a byte stream.\r\n *\r\n * @return The board as a array of bytes.\r\n */\r\nbyte[] getBytes();"},
 {"id":58, "name":"getEmptySquares()", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoard.getEmptySquares()", "ownerclassid":"11", "ownerclassname":"BitBoard", "sourcecode":"/**\r\n * Get the position of all empty squares.\r\n *\r\n * @return The position of all empty squares.\r\n */\r\nlong getEmptySquares();"},
 {"id":59, "name":"getPositionOfPieces(int)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoard.getPositionOfPieces(int)", "ownerclassid":"11", "ownerclassname":"BitBoard", "sourcecode":"// Methods\r\n/**\r\n * Get the position of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * \t\tThe color and type of the pieces.\r\n * @return A bitmask with the positions of these pieces.\r\n */\r\nlong getPositionOfPieces(int pieceTypeColor);"},
 {"id":60, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.BitBoardImpl.-init-()", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a chess board with pieces on their\r\n * initial positions.\r\n */\r\npublic BitBoardImpl() {\r\n    initialPosition();\r\n}"},
 {"id":61, "name":"clone()", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.clone()", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"// Methods\r\n/**\r\n * Create a clone of this board.\r\n *\r\n * @return A clone of this board.\r\n */\r\npublic final Object clone() {\r\n    BitBoardImpl clone = new BitBoardImpl();\r\n    for (int i = 0; i < 4; i++) {\r\n        clone._boardLayer[i] = _boardLayer[i];\r\n    }\r\n    return clone;\r\n}"},
 {"id":62, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    Piece movedPiece = getPiece(ply.getSource());\r\n    // Check, if it was a castling\r\n    if (ply instanceof CastlingPly) {\r\n        int offset = (movedPiece.isWhite()) ? 0 : 56;\r\n        if (((CastlingPly) (ply)).isLeftCastling()) {\r\n            setPiece(movedPiece, new PositionImpl((2 + offset)));\r\n            // Move the rook to the right\r\n            doPly(new PlyImpl(new PositionImpl((0 + offset)), new PositionImpl((3 + offset)), false));\r\n        } else {\r\n            setPiece(movedPiece, new PositionImpl((6 + offset)));\r\n            // Move the rook to the left\r\n            doPly(new PlyImpl(new PositionImpl((7 + offset)), new PositionImpl((5 + offset)), false));\r\n        }\r\n    } else {\r\n        // If a pawn has just reached the last row\r\n        if (ply instanceof TransformationPly) {\r\n            // Set a piece of the new type on the destination square.\r\n            setPiece(new PieceImpl(((TransformationPly) (ply)).getTypeAfterTransformation(), movedPiece.getColor()), ply.getDestination());\r\n        } else {\r\n            // Copy the piece from source square to destination square.\r\n            setPiece(movedPiece, ply.getDestination());\r\n            // If its a en passant ply, remove the attacked pawn.\r\n            if (ply instanceof EnPassantPly) {\r\n                setPiece(null, ((EnPassantPly) (ply)).getAttackedPosition());\r\n            }\r\n        }\r\n    }\r\n    // Empty the source square.\r\n    setPiece(null, ply.getSource());\r\n}"},
 {"id":63, "name":"emptyBoard()", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.emptyBoard()", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Remove all the pieces from the board.\r\n */\r\npublic final void emptyBoard() {\r\n    for (int i = 0; i < 4; i++) {\r\n        _boardLayer[i] = 0L;\r\n    }\r\n}"},
 {"id":64, "name":"getAllPiecesForColor(boolean)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.getAllPiecesForColor(boolean)", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * \t\ttrue, if the white pieces are requested,\r\n * \t\tfalse for the black pieces.\r\n */\r\npublic final long getAllPiecesForColor(boolean white) {\r\n    return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]));\r\n}"},
 {"id":65, "name":"getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}"},
 {"id":66, "name":"getBytes()", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.getBytes()", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Get the board as a byte stream.\r\n *\r\n * @return The board as a array of bytes.\r\n */\r\npublic final byte[] getBytes() {\r\n    // A buffer for the bytes.\r\n    byte[] buffer = new byte[32];\r\n    int bufferIndex = 0;\r\n    for (int layer = 0; layer < 4; layer++) {\r\n        // Get the current layer.\r\n        long currentLayer = _boardLayer[layer];\r\n        // Now shift the layer in the buffer.\r\n        for (int bytePos = 0; bytePos < 8; bytePos++) {\r\n            buffer[(bufferIndex++)] = ((byte) (((int) (currentLayer)) & 255));\r\n            currentLayer >>= 8;\r\n        }\r\n    }\r\n    return buffer;// Return the buffer with the bytes.\r\n\r\n}"},
 {"id":67, "name":"getEmptySquares()", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.getEmptySquares()", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Get a bitmask with all the free squares.\r\n *\r\n * @return A bitmask with all the empty squares marked by a 1 bit.\r\n */\r\npublic final long getEmptySquares() {\r\n    return ~(((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3]));\r\n}"},
 {"id":68, "name":"getPiece(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}"},
 {"id":69, "name":"getPositionOfPieces(int)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.getPositionOfPieces(int)", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Get the positions of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * \t\tThe color and type of the pieces.\r\n */\r\npublic final long getPositionOfPieces(int pieceTypeColor) {\r\n    return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]));\r\n}"},
 {"id":70, "name":"initialPosition()", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.initialPosition()", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Set all the pieces to their initial positions.\r\n */\r\npublic final void initialPosition() {\r\n    // Empty the board, before the pieces are added.\r\n    for (int i = 0; i < 64; i++) {\r\n        setPiece(null, new PositionImpl(i));\r\n    }\r\n    for (int i = 0; i < 8; i++) {\r\n        setPiece(new PieceImpl(Piece.PAWN, Piece.WHITE), new PositionImpl((8 + i)));\r\n        setPiece(new PieceImpl(Piece.PAWN, Piece.BLACK), new PositionImpl((48 + i)));\r\n    }\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.WHITE), new PositionImpl(0));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.WHITE), new PositionImpl(1));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.WHITE), new PositionImpl(2));\r\n    setPiece(new PieceImpl(Piece.QUEEN, Piece.WHITE), new PositionImpl(3));\r\n    setPiece(new PieceImpl(Piece.KING, Piece.WHITE), new PositionImpl(4));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.WHITE), new PositionImpl(5));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.WHITE), new PositionImpl(6));\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.WHITE), new PositionImpl(7));\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.BLACK), new PositionImpl(56));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.BLACK), new PositionImpl(57));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.BLACK), new PositionImpl(58));\r\n    setPiece(new PieceImpl(Piece.QUEEN, Piece.BLACK), new PositionImpl(59));\r\n    setPiece(new PieceImpl(Piece.KING, Piece.BLACK), new PositionImpl(60));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.BLACK), new PositionImpl(61));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.BLACK), new PositionImpl(62));\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.BLACK), new PositionImpl(63));\r\n}"},
 {"id":71, "name":"setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "ownerclassid":"12", "ownerclassname":"BitBoardImpl", "sourcecode":"/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set, or null to empty the square.\r\n * @param position\r\n * \t\tThe position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}"},
 {"id":72, "name":"clone()", "fullmethod":"de.java_chess.javaChess.board.Board.clone()", "ownerclassid":"13", "ownerclassname":"Board", "sourcecode":"/**\r\n * Return a copy of the current board.\r\n *\r\n * @return A copy of the current board.\r\n */\r\npublic Object clone();"},
 {"id":73, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.board.Board.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"13", "ownerclassname":"Board", "sourcecode":"/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * \t\tThe move to perform.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":74, "name":"emptyBoard()", "fullmethod":"de.java_chess.javaChess.board.Board.emptyBoard()", "ownerclassid":"13", "ownerclassname":"Board", "sourcecode":"/**\r\n * Remove all the pieces from the board.\r\n */\r\nvoid emptyBoard();"},
 {"id":75, "name":"getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"13", "ownerclassname":"Board", "sourcecode":"/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);"},
 {"id":76, "name":"getPiece(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)", "ownerclassid":"13", "ownerclassname":"Board", "sourcecode":"/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * \t\tThe position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);"},
 {"id":77, "name":"initialPosition()", "fullmethod":"de.java_chess.javaChess.board.Board.initialPosition()", "ownerclassid":"13", "ownerclassname":"Board", "sourcecode":"/**\r\n * Set the pieces to their initial positions.\r\n */\r\nvoid initialPosition();"},
 {"id":78, "name":"setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)", "ownerclassid":"13", "ownerclassname":"Board", "sourcecode":"/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * \t\tThe piece to set.\r\n * @param position\r\n * \t\tThe position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);"},
 {"id":79, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.DialogAbout.-init-()", "ownerclassid":"14", "ownerclassname":"DialogAbout", "sourcecode":"// ////////////////////////////////////////////////////////\r\n// //////////////////// Constructor //////////////////////\r\n// //////////////////////////////////////////////////////\r\nprivate DialogAbout() {\r\n    try {\r\n        jbInit();\r\n        this.setTitle(\"About Java-Chess\");\r\n        this.setSize(400, 380);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":80, "name":"CloseButton_keyReleased(java.awt.event.KeyEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.DialogAbout.CloseButton_keyReleased(java.awt.event.KeyEvent)", "ownerclassid":"14", "ownerclassname":"DialogAbout", "sourcecode":"void CloseButton_keyReleased(KeyEvent e) {\r\n    if ((e.getKeyCode()) == (KeyEvent.VK_ENTER))\r\n        this.hide();\r\n\r\n}"},
 {"id":81, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.DialogAbout.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"14", "ownerclassname":"DialogAbout", "sourcecode":"public void actionPerformed(ActionEvent event) {\r\n    this.setVisible(false);\r\n}"},
 {"id":82, "name":"getDialogResource(java.lang.String)", "fullmethod":"de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)", "ownerclassid":"14", "ownerclassname":"DialogAbout", "sourcecode":"/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * \t\tThe name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}"},
 {"id":83, "name":"getInstance()", "fullmethod":"de.java_chess.javaChess.dialogs.DialogAbout.getInstance()", "ownerclassid":"14", "ownerclassname":"DialogAbout", "sourcecode":"// //////////////////////////////////////////\r\n// ////////////// Methods //////////////////\r\n// /////////////////////////////////////////\r\n/**\r\n * Get the one and only instance of this class\r\n * (singleton pattern).\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static DialogAbout getInstance() {\r\n    // If theres no instance yet, create one.\r\n    if ((DialogAbout._instance) == null) {\r\n        DialogAbout._instance = new DialogAbout();\r\n    }\r\n    return DialogAbout._instance;\r\n}"},
 {"id":84, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.dialogs.DialogAbout.jbInit()", "ownerclassid":"14", "ownerclassname":"DialogAbout", "sourcecode":"private void jbInit() throws Exception {\r\n    titledBorder1 = new TitledBorder(\"\");\r\n    jLTitle.setBackground(Color.white);\r\n    jLTitle.setForeground(Color.black);\r\n    jLTitle.setText(\"Java-Chess 1.0.1 pre-alpha2\");\r\n    tAAuthors.setBackground(Color.black);\r\n    tAAuthors.setForeground(Color.white);\r\n    tAAuthors.setNextFocusableComponent(tAThanks);\r\n    tAAuthors.setEditable(false);\r\n    tAAuthors.setMargin(new Insets(20, 70, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tAAuthors, \"/home/weigo/Documents/Progs/authors\");\r\n    setRegister(tAAuthors, getDialogResource(\"authors.txt\"));\r\n    tAThanks.setBackground(Color.black);\r\n    tAThanks.setForeground(Color.white);\r\n    tAThanks.setNextFocusableComponent(tALicense);\r\n    tAThanks.setEditable(false);\r\n    tAThanks.setMargin(new Insets(20, 50, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tAThanks, \"/home/weigo/Documents/Progs/thanks\");\r\n    setRegister(tAThanks, getDialogResource(\"thanks.txt\"));\r\n    tALicense.setBackground(Color.black);\r\n    tALicense.setForeground(Color.white);\r\n    tALicense.setNextFocusableComponent(bCloseButton);\r\n    tALicense.setEditable(false);\r\n    tALicense.setMargin(new Insets(20, 50, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tALicense, \"/home/weigo/Documents/Progs/license\");\r\n    setRegister(tALicense, getDialogResource(\"license.txt\"));\r\n    tAAbout.setBackground(Color.black);\r\n    tAAbout.setForeground(Color.white);\r\n    tAAbout.setNextFocusableComponent(tAAuthors);\r\n    tAAbout.setEditable(false);\r\n    tAAbout.setMargin(new Insets(20, 70, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tAAbout, \"/home/weigo/Documents/Progs/about\");\r\n    setRegister(tAAbout, getDialogResource(\"about.txt\"));\r\n    bCloseButton.setBackground(Color.black);\r\n    bCloseButton.setForeground(Color.red);\r\n    bCloseButton.setNextFocusableComponent(tAAbout);\r\n    bCloseButton.setToolTipText(\"close the about dialog\");\r\n    bCloseButton.setMnemonic(0);\r\n    bCloseButton.setText(\"close\");\r\n    bCloseButton.addKeyListener(new DialogAbout_CloseButton_keyAdapter(this));\r\n    jPanel2.setBackground(Color.lightGray);\r\n    jPanel2.setBorder(BorderFactory.createEtchedBorder());\r\n    this.getContentPane().setBackground(Color.lightGray);\r\n    jPanel1.setBackground(Color.lightGray);\r\n    jPanel1.add(jLTitle, null);\r\n    this.getContentPane().add(jPanel2, BorderLayout.SOUTH);\r\n    jPanel2.add(bCloseButton, null);\r\n    this.getContentPane().add(tPAboutDialog, BorderLayout.CENTER);\r\n    tPAboutDialog.add(tAAbout, \"About\");\r\n    tPAboutDialog.add(tAAuthors, \"Authors\");\r\n    this.getContentPane().add(jPanel1, BorderLayout.NORTH);\r\n    tPAboutDialog.add(tAThanks, \"Thanks to\");\r\n    tPAboutDialog.add(tALicense, \"License agreements\");\r\n    bCloseButton.addActionListener(this);\r\n}"},
 {"id":85, "name":"setRegister(javax.swing.JTextArea,java.io.Reader)", "fullmethod":"de.java_chess.javaChess.dialogs.DialogAbout.setRegister(javax.swing.JTextArea,java.io.Reader)", "ownerclassid":"14", "ownerclassname":"DialogAbout", "sourcecode":"void setRegister(JTextArea textArea, Reader in) {\r\n    try {\r\n        char[] buffer = new char[4096];\r\n        int len;\r\n        textArea.setText(\"\");\r\n        while ((len = in.read(buffer)) != (-1)) {\r\n            String s = new String(buffer, 0, len);\r\n            textArea.append(s);\r\n        } \r\n        textArea.setCaretPosition(0);\r\n    } catch (IOException e) {\r\n        textArea.setText((((e.getClass().getName()) + \": \") + (e.getMessage())));\r\n    }\r\n}"},
 {"id":86, "name":"-init-(de.java_chess.javaChess.dialogs.DialogAbout)", "fullmethod":"de.java_chess.javaChess.DialogAbout_CloseButton_keyAdapter.-init-(de.java_chess.javaChess.dialogs.DialogAbout)", "ownerclassid":"15", "ownerclassname":"DialogAbout_CloseButton_keyAdapter", "sourcecode":"DialogAbout_CloseButton_keyAdapter(DialogAbout adaptee) {\r\n    this.adaptee = adaptee;\r\n}"},
 {"id":87, "name":"keyReleased(java.awt.event.KeyEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.keyReleased(java.awt.event.KeyEvent)", "ownerclassid":"15", "ownerclassname":"DialogAbout_CloseButton_keyAdapter", "sourcecode":"public void keyReleased(KeyEvent e) {\r\n    adaptee.CloseButton_keyReleased(e);\r\n}"},
 {"id":88, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PieceSelectionPanel.-init-()", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"/**\r\n * Constructor\r\n */\r\n// Constructor\r\npublic PieceSelectionPanel() {\r\n    _pieceIcon = new ImageIcon[2][7];\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            _pieceIcon[col][type] = new ImageIcon(new PieceRenderer(col, type, _set, this));\r\n        }\r\n    }\r\n    _pieceButton = new JButton[2][7];\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            _pieceButton[col][type] = new JButton(_pieceIcon[col][type]);\r\n            _pieceButton[col][type].addActionListener(this);\r\n        }\r\n    }\r\n    // this.jlSelectedPieceImage.setIcon( _pieceIcon[this.getColor()][this.getType()] );\r\n    // -----------------------------------------------------------------------\r\n    // Layout:\r\n    // -----------------------------------------------------------------------\r\n    this.setLayout(gblPieces);\r\n    this.add(_pieceButton[Piece.BLACK][Piece.PAWN], new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 20, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.PAWN], new GridBagConstraints(0, 1, 2, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 20, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.KNIGHT], new GridBagConstraints(1, 0, 2, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.BISHOP], new GridBagConstraints(3, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.ROOK], new GridBagConstraints(4, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.QUEEN], new GridBagConstraints(5, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.KING], new GridBagConstraints(6, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.KNIGHT], new GridBagConstraints(2, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.BISHOP], new GridBagConstraints(3, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.ROOK], new GridBagConstraints(4, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.QUEEN], new GridBagConstraints(5, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.KING], new GridBagConstraints(6, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jlSelectedPiece, new GridBagConstraints(7, 0, 1, 2, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));\r\n    this.add(jlSelectedPieceImage, new GridBagConstraints(8, 0, 1, 2, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));\r\n}"},
 {"id":89, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"public void actionPerformed(ActionEvent e) {\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            if ((_pieceButton[col][type]) == (e.getSource())) {\r\n                this.setType(type);\r\n                this.setColor(col);\r\n                this.jlSelectedPieceImage.setIcon(_pieceIcon[col][type]);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"},
 {"id":90, "name":"getColor()", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getColor()", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic byte getColor() {\r\n    return ((byte) ((pieceColor) & ((byte) (1))));\r\n}"},
 {"id":91, "name":"getSelectedPieceImage()", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getSelectedPieceImage()", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"public Image getSelectedPieceImage() {\r\n    byte type = this.getType();\r\n    if (type == 0) {\r\n        type = Piece.KING;\r\n    }\r\n    // To avoid the instanciation of a image each time, just reuse\r\n    // the images of the icons.\r\n    return _pieceIcon[this.getColor()][type].getImage();\r\n}"},
 {"id":92, "name":"getType()", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getType()", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"// -----------------------------------------------------------------------\r\n// Interface methods:\r\n// -----------------------------------------------------------------------\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic byte getType() {\r\n    return ((byte) ((pieceColor) >> 1));\r\n}"},
 {"id":93, "name":"getTypeAndColor()", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.getTypeAndColor()", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic byte getTypeAndColor() {\r\n    return this.pieceColor;\r\n}"},
 {"id":94, "name":"initializeSelectedIconLabel()", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.initializeSelectedIconLabel()", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"/**\r\n * Sets an icon for the SelectedIconLabel when no icon has been set before\r\n */\r\npublic void initializeSelectedIconLabel() {\r\n    if ((this.jlSelectedPieceImage.getIcon()) == null) {\r\n        byte type = this.getType();\r\n        if (type == 0)\r\n            type = Piece.KING;\r\n\r\n        this.jlSelectedPieceImage.setIcon(_pieceIcon[this.getColor()][type]);\r\n    }\r\n}"},
 {"id":95, "name":"isWhite()", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.isWhite()", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic boolean isWhite() {\r\n    return ((this.pieceColor) & 1) != 0;\r\n}"},
 {"id":96, "name":"setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"public void setCallingDialog(SetupBoardDialog dialog) {\r\n    this.setupBoardDialog = dialog;\r\n}"},
 {"id":97, "name":"setColor(byte)", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.setColor(byte)", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * \t\tnew color of this piece.\r\n */\r\npublic void setColor(byte color) {\r\n    pieceColor &= ((byte) (14));\r\n    pieceColor |= color;\r\n}"},
 {"id":98, "name":"setType(byte)", "fullmethod":"de.java_chess.javaChess.dialogs.PieceSelectionPanel.setType(byte)", "ownerclassid":"16", "ownerclassname":"PieceSelectionPanel", "sourcecode":"/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * \t\tThe type of this piece as defined as\r\n * \t\tconstants in the Piece interface.\r\n */\r\npublic void setType(byte type) {\r\n    pieceColor &= ((byte) (1));\r\n    pieceColor |= type << 1;\r\n}"},
 {"id":99, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PlayerDialog.-init-()", "ownerclassid":"17", "ownerclassname":"PlayerDialog", "sourcecode":"/**\r\n * Standardconstructor\r\n */\r\npublic PlayerDialog() {\r\n    super();\r\n}"},
 {"id":100, "name":"-init-(int,java.lang.String)", "fullmethod":"de.java_chess.javaChess.PlayerDialog.-init-(int,java.lang.String)", "ownerclassid":"17", "ownerclassname":"PlayerDialog", "sourcecode":"/**\r\n *\r\n *\r\n * @param iWhiteBlack\r\n * \t\t1 = edit white players name\r\n * @param currentString\r\n * \t\tThe string which already is displayed above the notation panel\r\n */\r\npublic PlayerDialog(int iWhiteBlack, String currentString) {\r\n    this.iWhite = iWhiteBlack;\r\n    this.sCurrentString = currentString;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":101, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.PlayerDialog.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"17", "ownerclassname":"PlayerDialog", "sourcecode":"/**\r\n * Interface method; handles the mouse click on the OK-button\r\n *\r\n * @param e\r\n * \t\tThe action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jbOK)) {\r\n        this.hide();\r\n    }\r\n}"},
 {"id":102, "name":"getNewName()", "fullmethod":"de.java_chess.javaChess.dialogs.PlayerDialog.getNewName()", "ownerclassid":"17", "ownerclassname":"PlayerDialog", "sourcecode":"/**\r\n * Returns the name from within the JTextField\r\n *\r\n * @return The new name\r\n */\r\npublic String getNewName() {\r\n    return this.jtNewName.getText();\r\n}"},
 {"id":103, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.dialogs.PlayerDialog.jbInit()", "ownerclassid":"17", "ownerclassname":"PlayerDialog", "sourcecode":"/**\r\n * Die GUI nach Nomenklatur des JBuilder\r\n *\r\n * @throws Exception\r\n * \t\t\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setModal(true);\r\n    this.getContentPane().setLayout(new GridBagLayout());\r\n    jtNewName = new JTextField(this.sCurrentString);\r\n    jtNewName.setSelectionStart(0);\r\n    jtNewName.setSelectionEnd(jtNewName.getText().length());\r\n    if ((this.iWhite) == 1) {\r\n        this.setTitle(\"Edit white players name\");\r\n        jLabel.setText(\"New white player name: \");\r\n        this.getContentPane().add(jLabel, new GridBagConstraints(0, 0, 1, 1, 0.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));\r\n        bWhiteOrBlack = true;\r\n    } else\r\n        if ((this.iWhite) == 2) {\r\n            jLabel.setText(\"New black player name: \");\r\n            this.setTitle(\"Edit black players name\");\r\n            this.getContentPane().add(jLabel, new GridBagConstraints(0, 0, 1, 1, 0.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));\r\n            bWhiteOrBlack = false;\r\n        }\r\n\r\n    this.getContentPane().add(jtNewName, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(2, 2, 2, 2), 0, 0));\r\n    jbOK.addActionListener(this);\r\n    this.getContentPane().add(jbOK, new GridBagConstraints(0, 1, 2, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));\r\n    this.setSize(300, 75);\r\n}"},
 {"id":104, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.SetupBoardDialog.-init-()", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Constructor\r\n */\r\npublic SetupBoardDialog() {\r\n    super();\r\n    String sMessage = \"This dialog is under construction.\n\n\";\r\n    sMessage += \"You can try some buttons and play around a bit,\n\";\r\n    sMessage += \"but it is not yet possible to place\n\";\r\n    sMessage += \"one or more pieces on the board.\n\";\r\n    sMessage += \"This point has very high priority\n\";\r\n    sMessage += \"on our ToDo-list for the next release.\";\r\n    String sTitle = \"Important note!\";\r\n    JOptionPane.showMessageDialog(null, sMessage, sTitle, JOptionPane.INFORMATION_MESSAGE);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":105, "name":"jbCancel_actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbCancel_actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Button Cancel pressed\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nprivate void jbCancel_actionPerformed(ActionEvent e) {\r\n    this.dispose();\r\n}"},
 {"id":106, "name":"jbClearBoard_actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbClearBoard_actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Button Clear board pressed; self-explaining\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jbClearBoard_actionPerformed(ActionEvent e) {\r\n    this.boardRenderer.clearBoard();\r\n}"},
 {"id":107, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbInit()", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Method for constructing the GUI\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setTitle(\"JavaChess - Setup position\");\r\n    this.getContentPane().setLayout(gblContentPane);\r\n    this.setSize(new Dimension(700, 650));\r\n    this.addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent e) {\r\n            this_windowClosing(e);\r\n        }\r\n    });\r\n    bitBoard = new BitBoardImpl();\r\n    // Hm:\r\n    // gameController = new GameController( _game, _gameNotation, _engine, _board, _gameTimer);\r\n    // boardRenderer = new ChessBoardRenderer2D( gameController, bitBoard );\r\n    boardRenderer = new ChessBoardRenderer2D(null, bitBoard);\r\n    // gameController.setRenderer( boardRenderer );\r\n    this.jpBoard.setLayout(gblBoard);\r\n    this.jpBoard.setPreferredSize(new Dimension(430, 430));\r\n    jpBoard.addMouseListener(new MouseAdapter() {\r\n        public void mouseEntered(MouseEvent e) {\r\n            jpBoard_mouseEntered(e);\r\n        }\r\n\r\n        public void mouseExited(MouseEvent e) {\r\n            jpBoard_mouseExited(e);\r\n        }\r\n    });\r\n    this.jpBoard.setMinimumSize(new Dimension(430, 430));\r\n    jpCastling.setLayout(gblCastling);\r\n    jpCastling.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jlCastling.setText(\"Castling rights:\");\r\n    checkBoxWhiteShort.setText(\"White short (O-O)\");\r\n    checkBoxWhiteLong.setText(\"White long (O-O-O)\");\r\n    checkBoxBlackShort.setText(\"Black short (O-O)\");\r\n    checkBoxBlackLong.setText(\"Black long (O-O-O)\");\r\n    jpMoveRight.setLayout(gblMoveRight);\r\n    jpMoveRight.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jpMoveRight.setMinimumSize(new Dimension(135, 73));\r\n    jpMoveRight.setPreferredSize(new Dimension(135, 73));\r\n    jlMoveRight.setText(\"Move right:\");\r\n    jrbWhiteToMove.setText(\"White to move\");\r\n    jrbWhiteToMove.setSelected(true);\r\n    jrbBlackToMove.setText(\"Black to move\");\r\n    jbClearBoard.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbClearBoard_actionPerformed(e);\r\n        }\r\n    });\r\n    jbStartPosition.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbStartPosition_actionPerformed(e);\r\n        }\r\n    });\r\n    bgMoveRight.add(jrbWhiteToMove);\r\n    bgMoveRight.add(jrbBlackToMove);\r\n    jpEnPassant.setLayout(gridBagLayout1);\r\n    jlEnPassant.setText(\"EnPassant-Square:\");\r\n    jtEnPassant.setMinimumSize(new Dimension(108, 21));\r\n    // Restrict the user input to 2 valid characters:\r\n    jtEnPassant.setDocument(new StringTextDocument(1, 2));\r\n    jtEnPassant.setPreferredSize(new Dimension(108, 21));\r\n    jpEnPassant.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jpEnPassant.setMinimumSize(new Dimension(135, 48));\r\n    jpEnPassant.setPreferredSize(new Dimension(135, 48));\r\n    jpMoveNumber.setLayout(gblMoveNumber);\r\n    jlMoveNumber.setText(\"Move number:\");\r\n    jpMoveNumber.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jpMoveNumber.setMinimumSize(new Dimension(135, 56));\r\n    jpMoveNumber.setPreferredSize(new Dimension(135, 56));\r\n    jtMoveNumber.setMinimumSize(new Dimension(108, 21));\r\n    jtMoveNumber.setPreferredSize(new Dimension(108, 21));\r\n    // Restrict the user input to 3 numbers:\r\n    jtMoveNumber.setDocument(new StringTextDocument(2, 3));\r\n    jpButtons.setLayout(gblButtons);\r\n    jbOk.setToolTipText(\"Close dialog with current position\");\r\n    jbOk.setMnemonic(KeyEvent.VK_O);\r\n    jbOk.setText(\"OK\");\r\n    jbOk.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbOk_actionPerformed(e);\r\n        }\r\n    });\r\n    jbCancel.setToolTipText(\"Abort and back to former position/game\");\r\n    jbCancel.setText(\"Cancel\");\r\n    jbCancel.setMnemonic(KeyEvent.VK_C);\r\n    jbCancel.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbCancel_actionPerformed(e);\r\n        }\r\n    });\r\n    jbClearBoard.setToolTipText(\"Clears the complete board\");\r\n    jbClearBoard.setText(\"Clear board\");\r\n    jbClearBoard.setMnemonic(KeyEvent.VK_L);\r\n    jbStartPosition.setToolTipText(\"Startup/Initial position\");\r\n    jbStartPosition.setText(\"Start position\");\r\n    jbStartPosition.setMnemonic(KeyEvent.VK_S);\r\n    jpBoard.add(boardRenderer, new GridBagConstraints(0, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.getContentPane().add(jpPieces, new GridBagConstraints(0, 5, 2, 1, 1.0, 1.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    jpBoard.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.getContentPane().add(jpBoard, new GridBagConstraints(0, 0, 1, 4, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 2, 2), 0, 0));\r\n    this.getContentPane().add(jpButtons, new GridBagConstraints(0, 6, 2, 1, 1.0, 1.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.getContentPane().add(jpMoveRight, new GridBagConstraints(1, 0, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 20), 0, 0));\r\n    jpMoveRight.add(jrbWhiteToMove, new GridBagConstraints(0, 2, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpMoveRight.add(jrbBlackToMove, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpMoveRight.add(jlMoveRight, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 0, 0), 0, 0));\r\n    jpButtons.add(jbOk, new GridBagConstraints(3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 20), 0, 0));\r\n    jpButtons.add(jbCancel, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 20), 0, 0));\r\n    jpButtons.add(jbStartPosition, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 20, 0, 20), 0, 0));\r\n    jpButtons.add(jbClearBoard, new GridBagConstraints(0, 0, 1, 1, 0.0, 1.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 20, 0, 20), 0, 0));\r\n    this.getContentPane().add(jpCastling, new GridBagConstraints(1, 1, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 20), 0, 0));\r\n    jpCastling.add(checkBoxBlackLong, new GridBagConstraints(0, 4, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(checkBoxWhiteShort, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(checkBoxWhiteLong, new GridBagConstraints(0, 2, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(checkBoxBlackShort, new GridBagConstraints(0, 3, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(jlCastling, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 10, 0), 0, 0));\r\n    this.getContentPane().add(jpEnPassant, new GridBagConstraints(1, 2, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 0), 0, 0));\r\n    jpEnPassant.add(jtEnPassant, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 4, 4), 0, 0));\r\n    jpEnPassant.add(jlEnPassant, new GridBagConstraints(0, 0, 2, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 0, 0), 0, 0));\r\n    this.getContentPane().add(jpMoveNumber, new GridBagConstraints(1, 3, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 0), 0, 0));\r\n    jpMoveNumber.add(jtMoveNumber, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));\r\n    jpMoveNumber.add(jlMoveNumber, new GridBagConstraints(0, 0, 2, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));// Brett\r\n\r\n}"},
 {"id":108, "name":"jbOk_actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbOk_actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Button Ok pressed\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nprivate void jbOk_actionPerformed(ActionEvent e) {\r\n    this.hide();\r\n}"},
 {"id":109, "name":"jbStartPosition_actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jbStartPosition_actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Button Start position pressed; self-explaining\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jbStartPosition_actionPerformed(ActionEvent e) {\r\n    bitBoard.initialPosition();\r\n    this.boardRenderer.reset();\r\n    this.validate();\r\n}"},
 {"id":110, "name":"jpBoard_mouseEntered(java.awt.event.MouseEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseEntered(java.awt.event.MouseEvent)", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Mouse cursor entered the board: Use piece as mouse pointer over the board\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jpBoard_mouseEntered(MouseEvent e) {\r\n    Image imageCursor;\r\n    oldCursor = this.getCursor();\r\n    // byte typeAndColor = ((Piece)jpPieces).getTypeAndColor();\r\n    // URL url = getClass().getResource(\"BP.gif\");\r\n    // Image image = Toolkit.getDefaultToolkit().getImage( url );\r\n    // Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(((Piece)jpPieces).getSelectedPieceImage(), new Point(20, 20), \"Piece\");\r\n    imageCursor = ((PieceSelectionPanel) (jpPieces)).getSelectedPieceImage();\r\n    ((PieceSelectionPanel) (jpPieces)).initializeSelectedIconLabel();\r\n    if (imageCursor != null) {\r\n        Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(imageCursor, new Point(20, 20), \"Piece\");\r\n        jpBoard.setCursor(myCursor);\r\n    }\r\n}"},
 {"id":111, "name":"jpBoard_mouseExited(java.awt.event.MouseEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseExited(java.awt.event.MouseEvent)", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * Mouse cursor left the board: Use normal mouse pointer again\r\n *\r\n * @param e\r\n * \t\tThe event\r\n */\r\nvoid jpBoard_mouseExited(MouseEvent e) {\r\n    jpBoard.setCursor(oldCursor);\r\n}"},
 {"id":112, "name":"this_windowClosing(java.awt.event.WindowEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.SetupBoardDialog.this_windowClosing(java.awt.event.WindowEvent)", "ownerclassid":"18", "ownerclassname":"SetupBoardDialog", "sourcecode":"/**\r\n * If this dialog is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * \t\tThe Window event\r\n */\r\nprivate void this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}"},
 {"id":113, "name":"-init-(javax.swing.JFrame,boolean)", "fullmethod":"de.java_chess.javaChess.TransformationDialog.-init-(javax.swing.JFrame,boolean)", "ownerclassid":"19", "ownerclassname":"TransformationDialog", "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation dialog.\r\n *\r\n * @param parent\r\n * \t\tThe parent frame.\r\n * @param modal\r\n * \t\tFlag, if the dialog is modal.\r\n */\r\nprivate TransformationDialog(JFrame parent, boolean modal) {\r\n    super(parent, modal);\r\n    _pieceType = Piece.QUEEN;// Set the piece type to the default value.\r\n\r\n    setTitle(\"Chose a piece type\");// Set the title of the dialog.\r\n\r\n    // Set a new layout with bigger gaps.\r\n    getContentPane().setLayout(new BorderLayout(16, 16));\r\n    // Add a panel with the options.\r\n    JPanel choserPanel = new JPanel();\r\n    choserPanel.setLayout(new GridLayout(4, 1));\r\n    // Create a group for the piece types to handle the selection\r\n    // of the radio buttons.\r\n    ButtonGroup buttonGroup = new ButtonGroup();\r\n    // Add the buttons for piece types\r\n    _queenButton = new JRadioButton(\"Queen\");\r\n    _queenButton.setSelected(true);\r\n    // Queen is the default choice.\r\n    buttonGroup.add(_queenButton);\r\n    _queenButton.addActionListener(this);\r\n    choserPanel.add(_queenButton);\r\n    _rookButton = new JRadioButton(\"Rook\");\r\n    buttonGroup.add(_rookButton);\r\n    _rookButton.addActionListener(this);\r\n    choserPanel.add(_rookButton);\r\n    _knightButton = new JRadioButton(\"Knight\");\r\n    buttonGroup.add(_knightButton);\r\n    _knightButton.addActionListener(this);\r\n    choserPanel.add(_knightButton);\r\n    _bishopButton = new JRadioButton(\"Bishop\");\r\n    buttonGroup.add(_bishopButton);\r\n    _bishopButton.addActionListener(this);\r\n    choserPanel.add(_bishopButton);\r\n    getContentPane().add(choserPanel, BorderLayout.CENTER);\r\n    // Add a button to hide the dialog.\r\n    _okButton = new JButton(\"Ok\");\r\n    _okButton.addActionListener(this);\r\n    getContentPane().add(_okButton, BorderLayout.SOUTH);\r\n    pack();\r\n    // Get the screen size and place the dialog in the middle of the screen.\r\n    Dimension size = getSize();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    setLocation((((screenSize.width) / 2) - ((size.width) / 2)), (((screenSize.height) / 2) - ((size.height) / 2)));\r\n}"},
 {"id":114, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.dialogs.TransformationDialog.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"19", "ownerclassname":"TransformationDialog", "sourcecode":"/**\r\n * A method to handle action events coming from the dialog.\r\n *\r\n * @param event\r\n * \t\tThe event that triggered this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Get the source of the event.\r\n    Object eventSource = event.getSource();\r\n    // If the user closed the dialog.\r\n    if (eventSource == (_okButton)) {\r\n        setVisible(false);\r\n        return;\r\n    }\r\n    // Check for the radio buttons.\r\n    if (eventSource == (_queenButton)) {\r\n        _pieceType = Piece.QUEEN;\r\n    } else\r\n        if (eventSource == (_rookButton)) {\r\n            _pieceType = Piece.ROOK;\r\n        } else\r\n            if (eventSource == (_knightButton)) {\r\n                _pieceType = Piece.KNIGHT;\r\n            } else\r\n                if (eventSource == (_bishopButton)) {\r\n                    _pieceType = Piece.BISHOP;\r\n                }\r\n\r\n\r\n\r\n}"},
 {"id":115, "name":"getInstance()", "fullmethod":"de.java_chess.javaChess.dialogs.TransformationDialog.getInstance()", "ownerclassid":"19", "ownerclassname":"TransformationDialog", "sourcecode":"// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final TransformationDialog getInstance() {\r\n    if ((TransformationDialog._instance) == null) {\r\n        TransformationDialog._instance = new TransformationDialog(null, true);\r\n    }\r\n    return TransformationDialog._instance;\r\n}"},
 {"id":116, "name":"getPieceType()", "fullmethod":"de.java_chess.javaChess.dialogs.TransformationDialog.getPieceType()", "ownerclassid":"19", "ownerclassname":"TransformationDialog", "sourcecode":"/**\r\n * Get the currently selected piece type.\r\n *\r\n * @return The currently selected piece type.\r\n */\r\npublic byte getPieceType() {\r\n    return _pieceType;\r\n}"},
 {"id":117, "name":"analyze()", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze()", "ownerclassid":"20", "ownerclassname":"BitBoardAnalyzer", "sourcecode":"/**\r\n * Analyze the current board.\r\n */\r\nshort analyze();"},
 {"id":118, "name":"analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "ownerclassid":"20", "ownerclassname":"BitBoardAnalyzer", "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);"},
 {"id":119, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzer.getBoard()", "ownerclassid":"20", "ownerclassname":"BitBoardAnalyzer", "sourcecode":"// Methods\r\n/**\r\n * Get the currently analyzed board.\r\n *\r\n * @return The currently analyzed board.\r\n */\r\nBitBoard getBoard();"},
 {"id":120, "name":"isInCheck(boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(boolean)", "ownerclassid":"20", "ownerclassname":"BitBoardAnalyzer", "sourcecode":"/**\r\n * Test if a king is in check.\r\n *\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(boolean white);"},
 {"id":121, "name":"isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "ownerclassid":"20", "ownerclassname":"BitBoardAnalyzer", "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);"},
 {"id":122, "name":"setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzer.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "ownerclassid":"20", "ownerclassname":"BitBoardAnalyzer", "sourcecode":"/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(BitBoard board);"},
 {"id":123, "name":"setMoveRight(boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzer.setMoveRight(boolean)", "ownerclassid":"20", "ownerclassname":"BitBoardAnalyzer", "sourcecode":"/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white has the\r\n * \t\tnext move.\r\n */\r\nvoid setMoveRight(boolean white);"},
 {"id":124, "name":"-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)", "fullmethod":"de.java_chess.javaChess.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * \t\tA PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}"},
 {"id":125, "name":"analyze()", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze()", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Analyze the current board.\r\n */\r\npublic final short analyze() {\r\n    // A check thread has a value, too.\r\n    short checkValue = 0;\r\n    // Start with the tests, if one of the players is in check.\r\n    // Its important to start the test with the color that moves next!\r\n    if (whiteHasMoveRight()) {\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n    } else {\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n    }\r\n    // Early checks hinder the position building are punished therefore.\r\n    if ((getGame().getNumberOfPlies()) < 12) {\r\n        checkValue = ((short) (checkValue / 4));\r\n    }\r\n    // Now compute the position and material value of all pieces.\r\n    short materialValue = 0;\r\n    // Count the figures and their material value.\r\n    short positionalValue = 0;// Score the position value.\r\n\r\n    // Check the entire board.\r\n    // Use a bitmask to speedup the test for a piece on the square\r\n    long emptySquareMask = getBoard().getEmptySquares();\r\n    // Get the positions of the white and black pawns.\r\n    long[] pawnPos = new long[2];\r\n    pawnPos[0] = getBoard().getPositionOfPieces(((Piece.PAWN) << 1));\r\n    pawnPos[1] = getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1));\r\n    // I reuse the same PositionImpl object to avoid the overhead of\r\n    // object instancing for each square.\r\n    Position pos = new PositionImpl(0);\r\n    for (int i = 0; i < 64; i++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            pos.setSquareIndex(i);\r\n            Piece p = getBoard().getPiece(pos);\r\n            if (p != null) {\r\n                short mValue = 0;\r\n                short pValue = 0;\r\n                // Add the value of the piece\r\n                switch (p.getType()) {\r\n                    case Piece.PAWN :\r\n                        mValue = 10;\r\n                        pValue = BitBoardAnalyzerImpl._pawnPositionalValue[((getGame().getNumberOfPlies()) <= 12 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        // Check, if this pawn could be promoted\r\n                        if (p.isWhite()) {\r\n                            int j = i + 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j < 64) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        } else {\r\n                            int j = i - 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j >= 0) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        }\r\n                        break;\r\n                    case Piece.KNIGHT :\r\n                        pValue = BitBoardAnalyzerImpl._knightPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) < 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.BISHOP :\r\n                        pValue = BitBoardAnalyzerImpl._bishopPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) <= 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.ROOK :\r\n                        mValue = 45;\r\n                        pValue = BitBoardAnalyzerImpl._rookPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.QUEEN :\r\n                        mValue = 80;\r\n                        pValue = BitBoardAnalyzerImpl._queenPositionalValue[((getGame().getNumberOfPlies()) <= 14 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.KING :\r\n                        pValue = BitBoardAnalyzerImpl._kingPositionalValue[(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                }\r\n                if (p.isWhite()) {\r\n                    materialValue += mValue;\r\n                    positionalValue += pValue;\r\n                } else {\r\n                    materialValue -= mValue;\r\n                    positionalValue -= pValue;\r\n                }\r\n            }\r\n        }\r\n        // Shift the mask to test the next square\r\n        emptySquareMask >>>= 1;\r\n    }\r\n    // Return a weighted score\r\n    return ((short) (((((short) (2)) * positionalValue) + (((short) (7)) * materialValue)) + checkValue));\r\n}"},
 {"id":126, "name":"analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board to analyze.\r\n * @param white\r\n * \t\tFlag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}"},
 {"id":127, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getBoard()", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the currently analyzed board.\r\n *\r\n * @return The currently analyzed board.\r\n */\r\npublic final BitBoard getBoard() {\r\n    return _board;\r\n}"},
 {"id":128, "name":"getGame()", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getGame()", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":129, "name":"getPlyGenerator()", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getPlyGenerator()", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Get the ply generator.\r\n *\r\n * @return The PlyGenerator.\r\n */\r\nprivate final PlyGenerator getPlyGenerator() {\r\n    return _plyGenerator;\r\n}"},
 {"id":130, "name":"isInCheck(boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * \t\tFlag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}"},
 {"id":131, "name":"isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * \t\tThe board to test.\r\n * @param white\r\n * \t\ttrue, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}"},
 {"id":132, "name":"setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(BitBoard board) {\r\n    _board = board;\r\n}"},
 {"id":133, "name":"setGame(de.java_chess.javaChess.game.Game)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setGame(de.java_chess.javaChess.game.Game)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":134, "name":"setMoveRight(boolean)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setMoveRight(boolean)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white has the\r\n * \t\tnext move.\r\n */\r\npublic final void setMoveRight(boolean white) {\r\n    _whiteMoves = white;\r\n}"},
 {"id":135, "name":"setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Set a new PlyGenerator instance.\r\n *\r\n * @param plyGenerator\r\n * \t\tThe new PlyGenerator instance.\r\n */\r\nprivate final void setPlyGenerator(PlyGenerator plyGenerator) {\r\n    _plyGenerator = plyGenerator;\r\n}"},
 {"id":136, "name":"whiteHasMoveRight()", "fullmethod":"de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.whiteHasMoveRight()", "ownerclassid":"21", "ownerclassname":"BitBoardAnalyzerImpl", "sourcecode":"/**\r\n * Check, if white moves next.\r\n *\r\n * @return true, if white moves next, false otherwise.\r\n */\r\nprivate final boolean whiteHasMoveRight() {\r\n    return _whiteMoves;\r\n}"},
 {"id":137, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.BitUtils.-init-()", "ownerclassid":"22", "ownerclassname":"BitUtils", "sourcecode":"BitUtils() {\r\n}"},
 {"id":138, "name":"getHighestBit(long)", "fullmethod":"de.java_chess.javaChess.engine.BitUtils.getHighestBit(long)", "ownerclassid":"22", "ownerclassname":"BitUtils", "sourcecode":"/**\r\n * Find the index of highest set bit in a long bitmask.\r\n *\r\n * @param bitmask\r\n * \t\tThe bitmask to operate on.\r\n * @return The index of the highest set bit or 0, if no bits are set.\r\n */\r\npublic static final int getHighestBit(long bitmask) {\r\n    int highestBit = 0;\r\n    // The following 3 statements split the 64 bit word down to\r\n    // a byte.\r\n    int dwordPart = ((int) (bitmask >>> 32));\r\n    if (dwordPart != 0) {\r\n        highestBit += 32;\r\n    } else {\r\n        dwordPart = ((int) (bitmask));\r\n    }\r\n    int wordPart = (dwordPart >>> 16) & 65535;\r\n    if (wordPart != 0) {\r\n        highestBit += 16;\r\n    } else {\r\n        wordPart = dwordPart & 65535;\r\n    }\r\n    int bytePart = (wordPart >>> 8) & 255;\r\n    if (bytePart != 0) {\r\n        highestBit += 8;\r\n    } else {\r\n        bytePart = wordPart & 255;\r\n    }\r\n    // Use the byte as a index for a precomputed array\r\n    // of bit indexes.\r\n    return highestBit + (BitUtils._highestBit[bytePart]);\r\n}"},
 {"id":139, "name":"computeBestPly()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.computeBestPly()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\nPly computeBestPly();"},
 {"id":140, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.getBoard()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nBoard getBoard();"},
 {"id":141, "name":"getCurrentGameState(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.getCurrentGameState(boolean)", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Get the current game state for a given color.\r\n *\r\n * @param white\r\n * \t\tTrue, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\nbyte getCurrentGameState(boolean white);"},
 {"id":142, "name":"getGame()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.getGame()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\nGame getGame();"},
 {"id":143, "name":"getMenu()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.getMenu()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Request a menu from the chess engine, where the user\r\n * can change its settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\nJMenu getMenu();"},
 {"id":144, "name":"getUserPlies()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.getUserPlies()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Get all the potential plies for the human player.\r\n *\r\n * @return All the potential plies for the human player.\r\n */\r\nPly[] getUserPlies();"},
 {"id":145, "name":"isWhite()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.isWhite()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Get the color of this engine.\r\n *\r\n * @param white\r\n * \t\ttrue, if the engine operates with the white pieces.\r\n */\r\nboolean isWhite();"},
 {"id":146, "name":"reset()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.reset()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Reset the engine for a new game.\r\n */\r\nvoid reset();"},
 {"id":147, "name":"setBoard(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.setBoard(de.java_chess.javaChess.board.Board)", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(Board board);"},
 {"id":148, "name":"setGame(de.java_chess.javaChess.game.Game)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.setGame(de.java_chess.javaChess.game.Game)", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\nvoid setGame(Game game);"},
 {"id":149, "name":"setWhite(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.setWhite(boolean)", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * \t\tflag to indicate if the engine operates on the white pieces.\r\n */\r\nvoid setWhite(boolean white);"},
 {"id":150, "name":"startPermanentBrain()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.startPermanentBrain()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Start the computations of the permanent brain.\r\n */\r\nvoid startPermanentBrain();"},
 {"id":151, "name":"stopPermanentBrain()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.stopPermanentBrain()", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Stop the computations of the permanent brain.\r\n */\r\nvoid stopPermanentBrain();"},
 {"id":152, "name":"validateUserPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngine.validateUserPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"23", "ownerclassname":"ChessEngine", "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\nboolean validateUserPly(Ply ply);"},
 {"id":153, "name":"-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "fullmethod":"de.java_chess.javaChess.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param notation\r\n * \t\tThe current notation.\r\n * @param board\r\n * \t\tThe new board.\r\n * @param white\r\n * \t\tFlag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}"},
 {"id":154, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Perform a action (could be a menu related action).\r\n *\r\n * @param actionEvent\r\n * \t\tThe event.\r\n */\r\npublic final void actionPerformed(ActionEvent actionEvent) {\r\n    // Check, if the user (de-)activated the permanent brain.\r\n    if (actionEvent.getSource().equals(_permanentBrainMenuItem)) {\r\n        activatePermanentBrain(_permanentBrainMenuItem.isSelected());\r\n        this.notifyListeners();\r\n        return;\r\n    }\r\n    // Check if the user has requested a new search time\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        if (actionEvent.getSource().equals(_avSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = false;\r\n        }\r\n        if (actionEvent.getSource().equals(_fixSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = true;\r\n        }\r\n    }\r\n    // Check, if the user has requested a different hashtable size.\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        if (actionEvent.getSource().equals(_hashtableSizeMenuItem[hts])) {\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n    }\r\n    this.notifyListeners();\r\n}"},
 {"id":155, "name":"activatePermanentBrain(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.activatePermanentBrain(boolean)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * (De-)activate the permanent brain function.\r\n *\r\n * @param active\r\n * \t\tFlag to indicate, if the permanent brain function should be used.\r\n */\r\nprivate final void activatePermanentBrain(boolean active) {\r\n    _usePermanentBrain = active;\r\n    // Since the permanent brain is eventually active already, stop it now.\r\n    if (!(usePermanentBrain())) {\r\n        stopPermanentBrain();\r\n    }\r\n    // If the permanent brain is activated, it will be use for the next(!) move.\r\n}"},
 {"id":156, "name":"addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Registers an object for notification.\r\n *\r\n * @param listener\r\n * \t\tThe object to be registered.\r\n */\r\npublic void addEngineStatusListener(EngineStatusListener listener) {\r\n    listeners.add(listener);\r\n}"},
 {"id":157, "name":"addLogEntry(java.lang.String)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.addLogEntry(java.lang.String)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Ads a log entry into the JavaChess logfile\r\n *\r\n * @param text\r\n * \t\tThe text to append\r\n */\r\nprivate void addLogEntry(String text) {\r\n    if ((f) != null) {\r\n        try {\r\n            // First read the existing lines into vBuffer\r\n            BufferedReader bfrIniFile = new BufferedReader(new FileReader(f));\r\n            String strOrgLine = bfrIniFile.readLine();\r\n            vBuffer = new Vector();\r\n            String strLine;\r\n            while (strOrgLine != null) {\r\n                strLine = strOrgLine.trim();\r\n                this.vBuffer.addElement(strLine);\r\n                strOrgLine = bfrIniFile.readLine();\r\n            } \r\n            // now create file new but with same filename\r\n            FileWriter fileWriter = new FileWriter(f);\r\n            PrintWriter printWriter = new PrintWriter(fileWriter);\r\n            // insert former existing text:\r\n            String[] strWrite = new String[vBuffer.size()];\r\n            vBuffer.copyInto(strWrite);\r\n            for (int i = 0; i < (vBuffer.size()); i++) {\r\n                printWriter.println(strWrite[i]);\r\n            }\r\n            // add the new text now:\r\n            printWriter.println(text);\r\n            printWriter.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"},
 {"id":158, "name":"analyzeBoard(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}"},
 {"id":159, "name":"computeBestPly()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.computeBestPly()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\npublic Ply computeBestPly() {\r\n    _bestPly = null;// Remove ply from last computation.\r\n\r\n    long startTime = System.currentTimeMillis();\r\n    if (inOpeningBook()) {\r\n        _bestPly = getOpeningBook().getOpeningBookPly();\r\n        if ((_bestPly) == null) {\r\n            // If theres no ply in the opening book.\r\n            setInOpeningBook(false);\r\n        }\r\n    }\r\n    if ((_bestPly) == null) {\r\n        // If we dont have a ply yet\r\n        start();\r\n        try {\r\n            Thread.sleep(getMaximumSearchTime());\r\n            setSearchStop(true);\r\n            // if( this.bFixedTime == false) {\r\n            _searchThread.join();// Wait for the search thread to end the search at this search depth.\r\n\r\n            // }\r\n            _searchThread = null;// Remove the thread, so it can be recreated for the next move.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n    long usedTime = (System.currentTimeMillis()) - startTime;\r\n    if ((_bestPly) != null) {\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOut = new StringBuffer();\r\n            sOut.append(\"Best ply: \");\r\n            sOut.append(_bestPly.getPly().toString());\r\n            sOut.append(\" with score \");\r\n            sOut.append(_bestPly.getScore());\r\n            sOut.append(\" and search depth \");\r\n            sOut.append(getSearchDepth());\r\n            this._enginePanel.modifyText(sOut.toString());\r\n            sOut = new StringBuffer();\r\n            sOut.append(\"Analyzed boards: \");\r\n            sOut.append(getAnalyzedBoards());\r\n            sOut.append(\" in \");\r\n            sOut.append(usedTime);\r\n            sOut.append(\" ms\");\r\n            this._enginePanel.modifyText(sOut.toString());\r\n        }\r\n        if ((this._statusPanel) != null)\r\n            this._statusPanel.setStatusText(\"Your turn...\");\r\n\r\n        return _bestPly.getPly();\r\n    }\r\n    return null;\r\n}"},
 {"id":160, "name":"createLogFile()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.createLogFile()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Initially create a logfile\r\n */\r\nprivate void createLogFile() {\r\n    File homedir = new File(System.getProperty(\"user.home\"));\r\n    f = new File(homedir, ChessEngineImpl.LOG_FILENAME);\r\n    try {\r\n        FileWriter fileWriter = new FileWriter(f);\r\n        PrintWriter printWriter = new PrintWriter(fileWriter);\r\n        printWriter.println(\"## Java-Chess Engine Logfile, do not edit! ##\");\r\n        printWriter.println(\"## For internal use only! ##\");\r\n        printWriter.close();\r\n    } catch (IOException e) {\r\n    }\r\n}"},
 {"id":161, "name":"decreaseSearchDepth()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.decreaseSearchDepth()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Decrease the search depth by 1.\r\n */\r\npublic final void decreaseSearchDepth() {\r\n    (_searchDepth)--;\r\n}"},
 {"id":162, "name":"getAnalyzedBoards()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getAnalyzedBoards()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the number of analyzed boards.\r\n *\r\n * @return The number of analyzed boards.\r\n */\r\npublic final long getAnalyzedBoards() {\r\n    return _analyzedBoards;\r\n}"},
 {"id":163, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getBoard()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":164, "name":"getCurrentGameState(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * \t\tTrue, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}"},
 {"id":165, "name":"getGame()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getGame()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":166, "name":"getHashSize()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getHashSize()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Returns the hash size\r\n *\r\n * @return The hashsize\r\n */\r\npublic int getHashSize() {\r\n    return this.getHashtable().getMaximumSize();\r\n}"},
 {"id":167, "name":"getHashtable()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getHashtable()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}"},
 {"id":168, "name":"getMaximumSearchTime()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getMaximumSearchTime()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the maximum search time.\r\n *\r\n * @return The maximum search time.\r\n */\r\npublic final int getMaximumSearchTime() {\r\n    return _maxSearchTime;\r\n}"},
 {"id":169, "name":"getMenu()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getMenu()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu engineMenu = new JMenu(\"Engine\");\r\n    // Add a toggle item for to the permanent brain.\r\n    engineMenu.add((_permanentBrainMenuItem = new JCheckBoxMenuItem(\"Use permanent brain\", usePermanentBrain())));\r\n    _permanentBrainMenuItem.addActionListener(this);\r\n    // Add a menu for the maximum search time\r\n    JMenu searchTimeMenu = new JMenu(\"Search time\");\r\n    // Add a sub-menu for fixed time.\r\n    JMenu searchTimeSubMenuFix = new JMenu(\"Fixed time\");\r\n    // Add a sub-menu for average time.\r\n    JMenu searchTimeSubMenuAv = new JMenu(\"Average time\");\r\n    // Add various options for the fixed search time\r\n    // (maybe a user defined search time should be added, too).\r\n    buttonGroupSearchTime = new ButtonGroup();\r\n    _fixSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _fixSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _fixSearchTimeMenuItem[st].addActionListener(this);\r\n        if ((_searchTime[st]) == 5) {\r\n            // set initially 5 sec max search time:\r\n            _fixSearchTimeMenuItem[st].setSelected(true);\r\n            this.setMaximumSearchTime(5000);\r\n        }\r\n        buttonGroupSearchTime.add(_fixSearchTimeMenuItem[st]);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuFix.add(_fixSearchTimeMenuItem[st]);\r\n    }\r\n    // Add various options for the average search time\r\n    _avSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _avSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _avSearchTimeMenuItem[st].addActionListener(this);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuAv.add(_avSearchTimeMenuItem[st]);\r\n        buttonGroupSearchTime.add(_avSearchTimeMenuItem[st]);\r\n    }\r\n    searchTimeMenu.add(searchTimeSubMenuFix);\r\n    searchTimeMenu.add(searchTimeSubMenuAv);\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(searchTimeMenu);\r\n    // Add a menu for the hashtable size.\r\n    JMenu hashtableSizeMenu = new JMenu(\"Hashtable size\");\r\n    // Add various options for the hashtable size.\r\n    this.buttonGroupHashSize = new ButtonGroup();\r\n    _hashtableSizeMenuItem = new JRadioButtonMenuItem[_hashtableSizes.length];\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        _hashtableSizeMenuItem[hts] = new JRadioButtonMenuItem(((\"\" + (_hashtableSizes[hts])) + \" entries\"));\r\n        _hashtableSizeMenuItem[hts].addActionListener(this);\r\n        if ((_hashtableSizes[hts]) == 10000) {\r\n            _hashtableSizeMenuItem[hts].setSelected(true);\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n        // Add the current search time menu item to its menu.\r\n        hashtableSizeMenu.add(_hashtableSizeMenuItem[hts]);\r\n        this.buttonGroupHashSize.add(_hashtableSizeMenuItem[hts]);\r\n    }\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(hashtableSizeMenu);\r\n    // Add a menu item to read openings from PGN files.\r\n    engineMenu.addSeparator();\r\n    engineMenu.add(new LoadOpeningsAction(getOpeningBook()));\r\n    // Return the engine menu.\r\n    return engineMenu;\r\n}"},
 {"id":170, "name":"getOpeningBook()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getOpeningBook()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}"},
 {"id":171, "name":"getPermanentBrain()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getPermanentBrain()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the permanent brain.\r\n *\r\n * @return The permanent brain.\r\n */\r\npublic final PermanentBrain getPermanentBrain() {\r\n    return _permanentBrain;\r\n}"},
 {"id":172, "name":"getSearchDepth()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getSearchDepth()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the current search depth.\r\n *\r\n * @return The current search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}"},
 {"id":173, "name":"getStatusDisplayString()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getStatusDisplayString()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Returns the status string to display in status bar\r\n */\r\npublic String getStatusDisplayString() {\r\n    String retString = ((((\"HashSize: \" + (this.getHashSize())) + \" entries; \") + \"Search time: \") + ((this.getMaximumSearchTime()) / 1000)) + \"sec\";\r\n    if (this.isFixedTime()) {\r\n        retString += \" fix\";\r\n    } else {\r\n        retString += \" average\";\r\n    }\r\n    return retString;\r\n}"},
 {"id":174, "name":"getUserPlies()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.getUserPlies()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get all the potential plies for the human player.\r\n *\r\n * @return All the potential plies for the human player.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    return _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), (!(isWhite())));\r\n}"},
 {"id":175, "name":"inOpeningBook()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.inOpeningBook()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the flag to indicate, if we are still in the opening book.\r\n *\r\n * @return true, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final boolean inOpeningBook() {\r\n    return _inOpeningBook;\r\n}"},
 {"id":176, "name":"increaseAnalyzedBoards()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.increaseAnalyzedBoards()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Increase the number of analyzed boards by 1.\r\n */\r\npublic final void increaseAnalyzedBoards() {\r\n    (_analyzedBoards)++;\r\n}"},
 {"id":177, "name":"increaseSearchDepth()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.increaseSearchDepth()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Increase the search depth by 1.\r\n */\r\npublic final void increaseSearchDepth() {\r\n    (_searchDepth)++;\r\n}"},
 {"id":178, "name":"isFixedTime()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.isFixedTime()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Returns whether the search time is fixed or not.\r\n *\r\n * @return Is the search time fixed?\r\n */\r\npublic boolean isFixedTime() {\r\n    return this.bFixedTime;\r\n}"},
 {"id":179, "name":"isSearchStop()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.isSearchStop()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Check, if a search should be stopped.\r\n *\r\n * @return true, if the search should be stopped.\r\n */\r\npublic final boolean isSearchStop() {\r\n    return _stopSearch;\r\n}"},
 {"id":180, "name":"isWhite()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.isWhite()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Get the color of this engine.\r\n *\r\n * @param white\r\n * \t\ttrue, if the engine operates with the white pieces.\r\n */\r\npublic boolean isWhite() {\r\n    return _white;\r\n}"},
 {"id":181, "name":"minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that created this board.\r\n * @param board\r\n * \t\tThe board to analyze.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n * @param byte\r\n * \t\tsearchLevel The level to search for.\r\n * @param alpha\r\n * \t\tThe current maximum.\r\n * @param beta\r\n * \t\tThe current minimum.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}"},
 {"id":182, "name":"notifyListeners()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.notifyListeners()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Notifies all registered listeners that the engine has taken a change.\r\n */\r\npublic void notifyListeners() {\r\n    Iterator iterator = listeners.iterator();\r\n    while (iterator.hasNext()) {\r\n        EngineStatusListener listener = ((EngineStatusListener) (iterator.next()));\r\n        listener.engineStatusChanged(this);\r\n    } \r\n}"},
 {"id":183, "name":"reset()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.reset()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"// Methods\r\n/**\r\n * Reset the engine for a new game.\r\n */\r\npublic void reset() {\r\n    setInOpeningBook(true);// Default is, that we are in the opening book.\r\n\r\n    getHashtable().reset();// Reset the hash tables.\r\n\r\n    // Remove the engine status messages.\r\n    if ((_enginePanel) != null) {\r\n        _enginePanel.setText(\"\");\r\n    }\r\n    // After a reset, the user is about to move.\r\n    if ((this._statusPanel) != null) {\r\n        this._statusPanel.setStatusText(\"Your turn...\");\r\n    }\r\n    // Start the permanent brain, if the user wants it to be used.\r\n    startPermanentBrain();\r\n    // Reset the last user ply.\r\n    _lastUserPly = null;\r\n}"},
 {"id":184, "name":"run()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.run()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * The main method of the search thread.\r\n */\r\npublic void run() {\r\n    // setAnalyzedBoards( 0L);  // Is done in the permanent brain now.\r\n    setSearchDepth(0);\r\n    // Try to get a move from the permanent brain.\r\n    PreComputedPly permanentBrainPly = (usePermanentBrain()) ? getPermanentBrain().getPlyForUserPly(_lastUserPly) : null;\r\n    // If we actually have a precomputed ply, adjust the search parameters.\r\n    if (permanentBrainPly != null) {\r\n        _bestPly = permanentBrainPly.getPly();\r\n        setSearchDepth(permanentBrainPly.getSearchDepth());// depth is increased before next search!\r\n\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOutput = new StringBuffer();\r\n            sOutput.append(\"Best ply for search depth \");\r\n            sOutput.append(getSearchDepth());\r\n            sOutput.append(\" is \");\r\n            sOutput.append(_bestPly.getPly().toString());\r\n            sOutput.append(\" with score \");\r\n            sOutput.append(_bestPly.getScore());\r\n            this._enginePanel.modifyText(sOutput.toString());\r\n        }\r\n    }\r\n    // The following search is rather inefficent at the moment, since we should try to get a principal variant\r\n    // from a search, so we can presort the plies for the next search.\r\n    do {\r\n        increaseSearchDepth();\r\n        AnalyzedPly searchDepthResult = null;\r\n        try {\r\n            searchDepthResult = startMinimaxAlphaBeta(isWhite());\r\n        } catch (InterruptedException ignored) {\r\n            // The search was just interrupted here, so we dont have to throw this exception...\r\n            decreaseSearchDepth();// But the search depth is 1 too high.\r\n\r\n        }\r\n        if (searchDepthResult != null) {\r\n            // The exception might not be the only case, where a null is returned, so keep\r\n            // this additional test.\r\n            if ((this._statusPanel) != null)\r\n                this._statusPanel.setStatusText(\"Thinking...\");\r\n\r\n            _bestPly = searchDepthResult;\r\n            if ((this._enginePanel) != null) {\r\n                StringBuffer sOutput = new StringBuffer();\r\n                sOutput.append(\"Best ply for search depth \");\r\n                sOutput.append(getSearchDepth());\r\n                sOutput.append(\" is \");\r\n                sOutput.append(_bestPly.getPly().toString());\r\n                sOutput.append(\" with score \");\r\n                sOutput.append(_bestPly.getScore());\r\n                this._enginePanel.modifyText(sOutput.toString());\r\n            }\r\n        }\r\n        // If search depth 1 was completed and no valid ply was found,\r\n        // it seems that the computer is checkmate and the search can be aborted.\r\n    } while ((!(isSearchStop())) && ((_bestPly) != null) );\r\n}"},
 {"id":185, "name":"setAnalyzedBoards(long)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setAnalyzedBoards(long)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set the number of analyzed boards.\r\n *\r\n * @param analyzedBoards\r\n * \t\tThe new number of analyzed boards.\r\n */\r\npublic final void setAnalyzedBoards(long analyzedBoards) {\r\n    _analyzedBoards = analyzedBoards;\r\n}"},
 {"id":186, "name":"setBoard(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setBoard(de.java_chess.javaChess.board.Board)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":187, "name":"setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Sets the EnginePanel to be able to output in the panel and not only with\r\n * System.out.println(...)\r\n *\r\n * @param panel\r\n * \t\tThe EnginePanel to set\r\n */\r\npublic void setEnginePanel(EnginePanel panel) {\r\n    this._enginePanel = panel;\r\n}"},
 {"id":188, "name":"setGame(de.java_chess.javaChess.game.Game)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setGame(de.java_chess.javaChess.game.Game)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":189, "name":"setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * \t\tThe new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}"},
 {"id":190, "name":"setInOpeningBook(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setInOpeningBook(boolean)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set the flag to indicate, if we are still in the opening book.\r\n *\r\n * @param inBook\r\n * \t\ttrue, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final void setInOpeningBook(boolean inBook) {\r\n    _inOpeningBook = inBook;\r\n}"},
 {"id":191, "name":"setMaximumSearchTime(int)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setMaximumSearchTime(int)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set the maximum search time.\r\n *\r\n * @param depth\r\n * \t\tThe new search time.\r\n */\r\npublic final void setMaximumSearchTime(int time) {\r\n    _maxSearchTime = time;\r\n}"},
 {"id":192, "name":"setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set a new opening book.\r\n *\r\n * @param book\r\n * \t\tThe new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}"},
 {"id":193, "name":"setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set a new permanent brain.\r\n *\r\n * @param permanentBrain\r\n * \t\tThe new permanent brain.\r\n */\r\nprivate final void setPermanentBrain(PermanentBrain permanentBrain) {\r\n    _permanentBrain = permanentBrain;\r\n}"},
 {"id":194, "name":"setSearchDepth(int)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setSearchDepth(int)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set a new search depth.\r\n *\r\n * @param searchDepth\r\n * \t\tThe new search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}"},
 {"id":195, "name":"setSearchStop(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setSearchStop(boolean)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set the the stop flag for the search.\r\n *\r\n * @param stopFlag\r\n * \t\tThe flag to stop the search engine.\r\n */\r\npublic final void setSearchStop(boolean stopFlag) {\r\n    _stopSearch = stopFlag;\r\n}"},
 {"id":196, "name":"setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"public void setStatusPanel(StatusPanel myPanel) {\r\n    if ((this._statusPanel) != myPanel)\r\n        this._statusPanel = myPanel;\r\n\r\n}"},
 {"id":197, "name":"setWhite(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.setWhite(boolean)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * \t\tflag to indicate if the engine operates on the white pieces.\r\n */\r\npublic void setWhite(boolean white) {\r\n    _white = white;\r\n}"},
 {"id":198, "name":"start()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.start()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Start a new thread to search for a ply.\r\n */\r\npublic void start() {\r\n    if ((_searchThread) == null) {\r\n        setSearchStop(false);\r\n        _searchThread = new Thread(this);\r\n        _searchThread.start();\r\n    }\r\n}"},
 {"id":199, "name":"startMinimaxAlphaBeta(boolean)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * \t\tFlag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * \t\tif the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"},
 {"id":200, "name":"startPermanentBrain()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.startPermanentBrain()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Start the computations of the permanent brain.\r\n */\r\npublic final void startPermanentBrain() {\r\n    // If the permanent brain is active.\r\n    if (usePermanentBrain()) {\r\n        getPermanentBrain().startComputation();\r\n    } else {\r\n        // Since the permanent brain cannot reset the counter,\r\n        // I do it here.\r\n        setAnalyzedBoards(0L);\r\n    }\r\n}"},
 {"id":201, "name":"stopPermanentBrain()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.stopPermanentBrain()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Stop the computations of the permanent brain.\r\n */\r\npublic final void stopPermanentBrain() {\r\n    getPermanentBrain().stopComputation();\r\n}"},
 {"id":202, "name":"usePermanentBrain()", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.usePermanentBrain()", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Check, if the permanent brain should be used.\r\n *\r\n * @return A flag, that indicates, if the permanent brain should be used.\r\n */\r\nprivate final boolean usePermanentBrain() {\r\n    return _usePermanentBrain;\r\n}"},
 {"id":203, "name":"validateUserPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"24", "ownerclassname":"ChessEngineImpl", "sourcecode":"/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}"},
 {"id":204, "name":"-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "fullmethod":"de.java_chess.javaChess.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}"},
 {"id":205, "name":"-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "fullmethod":"de.java_chess.javaChess.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * \t\tThe current game.\r\n * @param board\r\n * \t\tThe board to operate on.\r\n * @param hashtable\r\n * \t\tA hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}"},
 {"id":206, "name":"addAbsolutePlies(long,int,int,int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":207, "name":"addCastlingPly(int,boolean)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addCastlingPly(int,boolean)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add a castling ply.\r\n *\r\n * @param source\r\n * \t\tThe position square of the king.\r\n * @param goesLeft\r\n * \t\tThe flag that indicates if the castling goes to the left.\r\n */\r\nprivate final void addCastlingPly(int source, boolean goesLeft) {\r\n    addPly(new CastlingPlyImpl(new PositionImpl(source), goesLeft), REGULAR_PLY);\r\n}"},
 {"id":208, "name":"addPliesForBishopPos(int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForBishopPos(int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add the plies for a bishop position.\r\n *\r\n * @param square\r\n * \t\tThe square index of the bishop pos.\r\n */\r\nprivate final void addPliesForBishopPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    int squareRow = square >> 3;\r\n    int squareLine = square & 7;\r\n    long bitmask;\r\n    if (squareRow > 0) {\r\n        // If we are not on row 1\r\n        if (squareLine < 7) {\r\n            // Compute plies to the lower right.\r\n            square -= 7;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 7;\r\n                bitmask >>>= 7;\r\n            } \r\n        }\r\n        if (squareLine > 0) {\r\n            // Compute plies to the lower left.\r\n            square = orgPos - 9;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 9;\r\n                bitmask >>>= 9;\r\n            } \r\n        }\r\n    }\r\n    if (squareRow < 7) {\r\n        if (squareLine > 0) {\r\n            // Compute plies to the upper left.\r\n            square = orgPos + 7;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 7;\r\n                bitmask <<= 7;\r\n            } \r\n        }\r\n        if (squareLine < 7) {\r\n            // Compute plies to the upper right.\r\n            square = orgPos + 9;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 9;\r\n                bitmask <<= 9;\r\n            } \r\n        }\r\n    }\r\n}"},
 {"id":209, "name":"addPliesForBishops()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForBishops()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add the plies for bishops.\r\n */\r\npublic final void addPliesForBishops() {\r\n    long bishopPositions = getBoard().getPositionOfPieces((_white ? ((Piece.BISHOP) << 1) | 1 : (Piece.BISHOP) << 1));\r\n    while (bishopPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(bishopPositions);\r\n        addPliesForBishopPos(highestBit);\r\n        bishopPositions &= ~(1L << highestBit);\r\n    } \r\n}"},
 {"id":210, "name":"addPliesForKing()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForKing()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add all the plies for the king of the current color.\r\n */\r\nprivate final void addPliesForKing() {\r\n    long opponentKingPosition = getBoard().getPositionOfPieces((_white ? (Piece.KING) << 1 : ((Piece.KING) << 1) | 1));\r\n    int highestBit = BitUtils.getHighestBit(getBoard().getPositionOfPieces((_white ? ((Piece.KING) << 1) + 1 : (Piece.KING) << 1)));\r\n    long restrictedSquares = _kingMask[BitUtils.getHighestBit(opponentKingPosition)];\r\n    long curMoves = ((_kingMask[highestBit]) & ((_emptySquares) | (_attackablePieces))) & (~restrictedSquares);\r\n    int startBitRange = highestBit - 9;\r\n    if (startBitRange < 0) {\r\n        startBitRange = 0;\r\n    }\r\n    int endBitRange = highestBit + 9;\r\n    if (endBitRange > 63) {\r\n        endBitRange = 63;\r\n    }\r\n    addAbsolutePlies(curMoves, startBitRange, endBitRange, highestBit);\r\n    // Check for castling\r\n    if (_white) {\r\n        // If the king has not been moved and is not in check\r\n        if ((!(getGame().hasBeenMoved(new PositionImpl(4)))) && (!(getAnalyzer().isInCheck(getBoard(), true)))) {\r\n            long rookPositions = getBoard().getPositionOfPieces((((Piece.ROOK) << 1) + 1));\r\n            if (((!(getGame().hasBeenMoved(new PositionImpl(0)))) && (((_emptySquares) & 14L) == 14L)) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(4), new PositionImpl(2)))), true) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(4), new PositionImpl(3), false)))), true)))) {\r\n                // The addPly method checks for this check anyway, so it can be outcommented here...\r\n                addCastlingPly(4, true);\r\n            }\r\n            if (((!(getGame().hasBeenMoved(new PositionImpl(7)))) && (((_emptySquares) & 96L) == 96L)) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(4), new PositionImpl(6)))), true) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(4), new PositionImpl(5), false)))), true)))) {\r\n                addCastlingPly(4, false);\r\n            }\r\n        }\r\n    } else {\r\n        if ((!(getGame().hasBeenMoved(new PositionImpl(60)))) && (!(getAnalyzer().isInCheck(getBoard(), false)))) {\r\n            long rookPositions = getBoard().getPositionOfPieces(((Piece.ROOK) << 1));\r\n            if (((!(getGame().hasBeenMoved(new PositionImpl(56)))) && (((_emptySquares) & (14L << 56)) == (14L << 56))) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(60), new PositionImpl(58)))), false) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(60), new PositionImpl(59), false)))), false)))) {\r\n                addCastlingPly((4 + 56), true);\r\n            }\r\n            if (((getGame().hasBeenMoved(new PositionImpl(63))) && (((_emptySquares) & 96L) == 96L)) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(60), new PositionImpl(62)))), false) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(60), new PositionImpl(61), false)))), false)))) {\r\n                addCastlingPly((4 + 56), false);\r\n            }\r\n        }\r\n    }\r\n}"},
 {"id":211, "name":"addPliesForKnights()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForKnights()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add all the plies for knights of the current color.\r\n */\r\nprivate final void addPliesForKnights() {\r\n    long knightPositions = getBoard().getPositionOfPieces((_white ? ((Piece.KNIGHT) << 1) | 1 : (Piece.KNIGHT) << 1));\r\n    while (knightPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(knightPositions);\r\n        long curMoves = (_knightMask[highestBit]) & ((_emptySquares) | (_attackablePieces));\r\n        int startBitRange = highestBit - 17;\r\n        if (startBitRange < 0) {\r\n            startBitRange = 0;\r\n        }\r\n        int endBitRange = highestBit + 17;\r\n        if (endBitRange > 63) {\r\n            endBitRange = 63;\r\n        }\r\n        addAbsolutePlies(curMoves, startBitRange, endBitRange, highestBit);\r\n        knightPositions &= ~(1L << highestBit);\r\n    } \r\n}"},
 {"id":212, "name":"addPliesForPawns()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForPawns()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add all the plies for pawns of the current color.\r\n */\r\nprivate final void addPliesForPawns() {\r\n    if (_white) {\r\n        // Get the positions of all pawns\r\n        long pawnPos = getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1));\r\n        // Add all the diagonal attacks\r\n        addRelativePliesUpward((((pawnPos & (BitBoard._NOT_LINE_H)) << 9) & (_attackablePieces)), 17, 63, (-9));\r\n        addRelativePliesUpward((((pawnPos & (BitBoard._NOT_LINE_A)) << 7) & (_attackablePieces)), 16, 62, (-7));\r\n        // Check for a en-passent attack\r\n        if ((getLastPly()) != null) {\r\n            Position destination = getLastPly().getDestination();\r\n            Piece piece = getBoard().getPiece(destination);\r\n            // The check for the color is sorta redundant, but during analysis the\r\n            // order of moves might be incorrect.\r\n            if (((piece != null) && ((piece.getType()) == (Piece.PAWN))) && ((piece.getColor()) == (Piece.BLACK))) {\r\n                int sourceIndex = getLastPly().getSource().getSquareIndex();\r\n                int destinationIndex = getLastPly().getDestination().getSquareIndex();\r\n                // If the pawn moved 2 squares\r\n                if ((sourceIndex - destinationIndex) == 16) {\r\n                    int attackableIndex = sourceIndex - 8;\r\n                    // Compute the bitmask for the pawn.\r\n                    long attackablePawnBitmask = 1L << attackableIndex;\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) << 9) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex - 9)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) << 7) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex - 7)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Add all the 2 square plies. Since the square in front of the pawn has to be free, I have to\r\n        // add the bit and with the shifted empty squares.\r\n        addRelativePliesUpward(((((pawnPos & (BitBoard._ROW_2)) & ((_emptySquares) >>> 8)) << 16) & (_emptySquares)), 24, 31, (-16));\r\n        // Add all the 1 square plies.\r\n        long movedPawns = (pawnPos << 8) & (_emptySquares);\r\n        addRelativePliesUpward((movedPawns & (BitBoard._NOT_ROW_8)), 16, 55, (-8));\r\n        // Now take care of the last row.\r\n        movedPawns &= BitBoard._ROW_8;\r\n        while (movedPawns != 0L) {\r\n            int destinationSquare = BitUtils.getHighestBit(movedPawns);\r\n            int sourceSquare = destinationSquare - 8;\r\n            // Add all transformation types as plies.\r\n            boolean capture = ((1L << destinationSquare) & (_attackablePieces)) != 0L;\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.QUEEN, capture, QUEEN_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.KNIGHT, capture, KNIGHT_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.ROOK, capture, ROOK_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.BISHOP, capture, BISHOP_TRANSFORMATION);\r\n            movedPawns &= ~(1L << destinationSquare);\r\n        } \r\n    } else {\r\n        // Get the positions of all pawns\r\n        long pawnPos = getBoard().getPositionOfPieces(((Piece.PAWN) << 1));\r\n        // Add all the diagonal attacks\r\n        addRelativePliesDownward((((pawnPos & (BitBoard._NOT_LINE_A)) >>> 9) & (_attackablePieces)), 46, 0, 9);\r\n        addRelativePliesDownward((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 7) & (_attackablePieces)), 47, 0, 7);\r\n        // Check for a en-passent attack\r\n        if ((getLastPly()) != null) {\r\n            Position destination = getLastPly().getDestination();\r\n            Piece piece = getBoard().getPiece(destination);\r\n            // The check for the color is sorta redundant, but during analysis the\r\n            // order of moves might be incorrect.\r\n            if (((piece != null) && ((piece.getType()) == (Piece.PAWN))) && ((piece.getColor()) == (Piece.BLACK))) {\r\n                int sourceIndex = getLastPly().getSource().getSquareIndex();\r\n                int destinationIndex = getLastPly().getDestination().getSquareIndex();\r\n                // If the pawn moved 2 squares\r\n                if ((destinationIndex - sourceIndex) == 16) {\r\n                    int attackableIndex = sourceIndex + 8;\r\n                    // Compute the bitmask for the pawn.\r\n                    long attackablePawnBitmask = 1L << attackableIndex;\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 9) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex + 9)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 7) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex + 7)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Add all the 2 square plies. Since the square in front of the pawn has to be free, I have to\r\n        // add the bit and with the shifted empty squares.\r\n        addRelativePliesDownward(((((pawnPos & (BitBoard._ROW_7)) & ((_emptySquares) << 8)) >>> 16) & (_emptySquares)), 39, 32, 16);\r\n        // Add all the 1 square plies.\r\n        long movedPawns = (pawnPos >>> 8) & (_emptySquares);\r\n        addRelativePliesDownward((movedPawns & (BitBoard._NOT_ROW_1)), 56, 8, 8);\r\n        // Now take care of the last row.\r\n        movedPawns &= BitBoard._ROW_1;\r\n        while (movedPawns != 0L) {\r\n            int destinationSquare = BitUtils.getHighestBit(movedPawns);\r\n            int sourceSquare = destinationSquare + 8;\r\n            // Add all transformation types as plies.\r\n            boolean capture = ((1L << destinationSquare) & (_attackablePieces)) != 0L;\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.QUEEN, capture, QUEEN_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.KNIGHT, capture, KNIGHT_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.ROOK, capture, ROOK_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.BISHOP, capture, BISHOP_TRANSFORMATION);\r\n            movedPawns &= ~(1L << destinationSquare);\r\n        } \r\n    }\r\n}"},
 {"id":213, "name":"addPliesForQueenPos(int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForQueenPos(int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add the plies for one queen position.\r\n *\r\n * @param square\r\n * \t\tThe square index of the queen position.\r\n */\r\nprivate final void addPliesForQueenPos(int square) {\r\n    // Since a queen can move like a bishop or rook,\r\n    // I simply add the plies of both for this position.\r\n    addPliesForBishopPos(square);\r\n    addPliesForRookPos(square);\r\n}"},
 {"id":214, "name":"addPliesForQueens()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForQueens()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add the plies for queens.\r\n */\r\npublic final void addPliesForQueens() {\r\n    long queenPositions = getBoard().getPositionOfPieces((_white ? ((Piece.QUEEN) << 1) | 1 : (Piece.QUEEN) << 1));\r\n    while (queenPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(queenPositions);\r\n        addPliesForQueenPos(highestBit);\r\n        queenPositions &= ~(1L << highestBit);\r\n    } \r\n}"},
 {"id":215, "name":"addPliesForRookPos(int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForRookPos(int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add the plies for one rook position.\r\n *\r\n * @param square\r\n * \t\tThe square index of the rook pos.\r\n */\r\nprivate final void addPliesForRookPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    long bitmask;\r\n    // Compute plies to the left.\r\n    bitmask = 1L << square;\r\n    while ((square & 7) > 0) {\r\n        square -= 1;\r\n        bitmask >>>= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies downwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square > 8) {\r\n        square -= 8;\r\n        bitmask >>>= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies to the right.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while ((square & 7) < 7) {\r\n        square += 1;\r\n        bitmask <<= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies upwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square < 56) {\r\n        square += 8;\r\n        bitmask <<= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n}"},
 {"id":216, "name":"addPliesForRooks()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPliesForRooks()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add the plies for rooks.\r\n */\r\npublic final void addPliesForRooks() {\r\n    long rookPositions = getBoard().getPositionOfPieces((_white ? ((Piece.ROOK) << 1) | 1 : (Piece.ROOK) << 1));\r\n    while (rookPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(rookPositions);\r\n        addPliesForRookPos(highestBit);\r\n        rookPositions &= ~(1L << highestBit);\r\n    } \r\n}"},
 {"id":217, "name":"addPly(de.java_chess.javaChess.ply.Ply,short)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to add.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}"},
 {"id":218, "name":"addRegularPly(int,int,boolean,short)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}"},
 {"id":219, "name":"addRelativePliesDownward(long,int,int,int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}"},
 {"id":220, "name":"addRelativePliesUpward(long,int,int,int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * \t\tThe destination positions for all the plies.\r\n * @param int\r\n * \t\tstartBit The bit to start scanning from.\r\n * @param int\r\n * \t\tendBit The bit to end the scanning at.\r\n * \t\tint offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}"},
 {"id":221, "name":"addTransformationPly(int,int,byte,boolean,short)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * \t\tThe source square of the old piece.\r\n * @param destination\r\n * \t\tThe destination square of the piece.\r\n * @param pieceType\r\n * \t\tThe new piece type after the ply.\r\n * @param capture\r\n * \t\tFlag to indicate if another piece is captured.\r\n * @param score\r\n * \t\tThe presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}"},
 {"id":222, "name":"getAnalyzer()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getAnalyzer()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Get a analyzer for check test.\r\n *\r\n * @return A analyzer for chess boards.\r\n */\r\nfinal BitBoardAnalyzer getAnalyzer() {\r\n    return _analyzer;\r\n}"},
 {"id":223, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getBoard()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal BitBoard getBoard() {\r\n    return _board;\r\n}"},
 {"id":224, "name":"getGame()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getGame()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}"},
 {"id":225, "name":"getHashtable()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getHashtable()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}"},
 {"id":226, "name":"getKnightPlies(int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getKnightPlies(int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Get the knight plies for a given knight square.\r\n *\r\n * @param square\r\n * \t\tThe square, where the knight is located.\r\n * @return All the knight plies as a 64 bit bitmask.\r\n */\r\npublic final long getKnightPlies(int square) {\r\n    return _knightMask[square];\r\n}"},
 {"id":227, "name":"getLastPly()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getLastPly()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\nfinal Ply getLastPly() {\r\n    return getGame().getLastPly();\r\n    // return _lastPly;\r\n}"},
 {"id":228, "name":"getPliesForColor(boolean)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(boolean)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Get the plies for a given game position and color.\r\n *\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(boolean white) {\r\n    resetPlies();\r\n    _white = white;// Store the color of the current player.\r\n\r\n    // Compute some bitmasks, so we dont have to compute them again for each piece type.\r\n    _emptySquares = getBoard().getEmptySquares();// Get the positions of the empty squares.\r\n\r\n    _attackablePieces = (getBoard().getAllPiecesForColor((!(_white)))) & (~(getBoard().getPositionOfPieces((((Piece.KING) << 1) | (_white ? 0 : 1)))));\r\n    // Add the possible plies for all piece types.\r\n    // I tried to sort this list according to the probality for a check, so\r\n    // the analyzer has a better chance to find it early.\r\n    addPliesForKnights();\r\n    addPliesForBishops();\r\n    addPliesForRooks();\r\n    addPliesForQueens();\r\n    addPliesForPawns();\r\n    addPliesForKing();\r\n    // Check, if theres a good ply for this board in the hash table.\r\n    Ply hashtablePly = getHashtable().getPly(getBoard(), _white);\r\n    if (hashtablePly != null) {\r\n        // If so, increase the score of this ply.\r\n        for (int index = 0; index < (_plyCounter); index++) {\r\n            if (_currentPlies[index].getPly().equals(hashtablePly)) {\r\n                _currentPlies[index].setScore(HASHTABLE_PLY);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // Presort the plies\r\n    presortPlies();\r\n    // Convert the plies to a array of the correct size\r\n    Ply[] plies = new Ply[_plyCounter];\r\n    int destIndex = 0;\r\n    for (int sourceIndex = (_plyCounter) - 1; sourceIndex >= 0;) {\r\n        plies[(destIndex++)] = _currentPlies[(sourceIndex--)].getPly();\r\n    }\r\n    return plies;\r\n}"},
 {"id":229, "name":"getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * \t\tThe ply, that lead to the given board.\r\n * @param board\r\n * \t\tThe board with the game position.\r\n * @param white\r\n * \t\ttrue, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}"},
 {"id":230, "name":"precomputeKingPlies()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.precomputeKingPlies()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Compute the king moves for each square in advance.\r\n */\r\nprivate final void precomputeKingPlies() {\r\n    for (int i = 0; i < 64; i++) {\r\n        long currentMask = 0L;\r\n        int line = i & 7;\r\n        int row = i >> 3;\r\n        for (int currentPlyIndex = 0; currentPlyIndex < (PlyGenerator._kingPlyOffset.length); currentPlyIndex++) {\r\n            int[] curOffsets = PlyGenerator._kingPlyOffset[currentPlyIndex];\r\n            int targetRow = row + (curOffsets[1]);\r\n            int targetLine = line + (curOffsets[0]);\r\n            if ((((targetRow >= 0) && (targetRow < 8)) && (targetLine >= 0)) && (targetLine < 8)) {\r\n                currentMask |= 1L << ((targetRow << 3) + targetLine);\r\n            }\r\n        }\r\n        _kingMask[i] = currentMask;\r\n    }\r\n}"},
 {"id":231, "name":"precomputeKnightPlies()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.precomputeKnightPlies()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Compute the knight plies for each square. This is done at startup,\r\n * so we can get the plies by a simple array access.\r\n */\r\nprivate final void precomputeKnightPlies() {\r\n    for (int i = 0; i < 64; i++) {\r\n        long currentMask = 0L;\r\n        int line = i & 7;\r\n        int row = i >> 3;\r\n        for (int currentPlyIndex = 0; currentPlyIndex < (PlyGenerator._knightPlyOffset.length); currentPlyIndex++) {\r\n            int[] curOffsets = PlyGenerator._knightPlyOffset[currentPlyIndex];\r\n            int targetRow = row + (curOffsets[1]);\r\n            int targetLine = line + (curOffsets[0]);\r\n            if ((((targetRow >= 0) && (targetRow < 8)) && (targetLine >= 0)) && (targetLine < 8)) {\r\n                currentMask |= 1L << ((targetRow << 3) + targetLine);\r\n            }\r\n        }\r\n        _knightMask[i] = currentMask;\r\n    }\r\n}"},
 {"id":232, "name":"presortPlies()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.presortPlies()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Presort the scored plies.\r\n */\r\nprivate final void presortPlies() {\r\n    if ((_plyCounter) > 1) {\r\n        // Check the array size, so the sort methods dont have to do it.\r\n        quickersort(0, ((_plyCounter) - 1));\r\n    }\r\n}"},
 {"id":233, "name":"quickersort(int,int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.quickersort(int,int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Perform a combined quick-/shakersort on a ply partition.\r\n *\r\n * @param l\r\n * \t\tThe left bound of the array partition.\r\n * @param r\r\n * \t\tThe right bound of the array partition.\r\n */\r\nprivate final void quickersort(int l, int r) {\r\n    int i = l;\r\n    int j = r;\r\n    AnalyzedPly x = _currentPlies[((l + r) / 2)];\r\n    do {\r\n        while ((_currentPlies[i].getScore()) > (x.getScore())) {\r\n            i++;\r\n        } \r\n        while ((x.getScore()) > (_currentPlies[j].getScore())) {\r\n            j--;\r\n        } \r\n        if (i <= j) {\r\n            AnalyzedPly w = _currentPlies[i];\r\n            _currentPlies[(i++)] = _currentPlies[j];\r\n            _currentPlies[(j--)] = w;\r\n        }\r\n    } while (i <= j );\r\n    if (l < j) {\r\n        if ((l - j) > 7) {\r\n            quickersort(l, j);\r\n        } else {\r\n            shakersort(l, j);\r\n        }\r\n    }\r\n    if (i < r) {\r\n        if ((r - i) > 7) {\r\n            quickersort(i, r);\r\n        } else {\r\n            shakersort(i, r);\r\n        }\r\n    }\r\n}"},
 {"id":234, "name":"resetPlies()", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.resetPlies()", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Reset the ply buffer.\r\n */\r\nprivate final void resetPlies() {\r\n    _plyCounter = 0;\r\n}"},
 {"id":235, "name":"setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Set the last ply.\r\n *\r\n * @param lastPly\r\n * \t\tThe last ply.\r\n */\r\n/* final void setLastPly( Ply lastPly) {\n// _lastPly = lastPly;\n}\n */\r\n/**\r\n * Set a analyzer for check tests.\r\n *\r\n * @param analyzer\r\n * \t\tThe new analyzer to set.\r\n */\r\npublic final void setAnalyzer(BitBoardAnalyzer analyzer) {\r\n    _analyzer = analyzer;\r\n}"},
 {"id":236, "name":"setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.setBoard(de.java_chess.javaChess.bitboard.BitBoard)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nfinal void setBoard(BitBoard board) {\r\n    _board = board;\r\n}"},
 {"id":237, "name":"setGame(de.java_chess.javaChess.game.Game)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.setGame(de.java_chess.javaChess.game.Game)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * \t\tcurrent game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}"},
 {"id":238, "name":"setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * \t\tThe new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}"},
 {"id":239, "name":"shakersort(int,int)", "fullmethod":"de.java_chess.javaChess.engine.PlyGenerator.shakersort(int,int)", "ownerclassid":"25", "ownerclassname":"PlyGenerator", "sourcecode":"/**\r\n * Perform a shakersort on a ply partition.\r\n *\r\n * @param l\r\n * \t\tThe left bound of the ply partition.\r\n * @param r\r\n * \t\tThe right bound of the ply partition.\r\n */\r\nprivate final void shakersort(int l, int r) {\r\n    int i = l + 1;\r\n    int j = r;\r\n    int k = r;\r\n    do {\r\n        for (int h = j; h >= i; h--) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        i = k + 1;\r\n        for (int h = i; h <= j; h++) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        j = k - 1;\r\n    } while (i <= j );\r\n}"},
 {"id":240, "name":"getMaximumSize()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getMaximumSize()", "ownerclassid":"26", "ownerclassname":"PlyHashtable", "sourcecode":"/**\r\n * Get the maximum number of entries in the hashtable.\r\n *\r\n * @return The maximum number of entries in the hashtable.\r\n */\r\nint getMaximumSize();"},
 {"id":241, "name":"getPly(de.java_chess.javaChess.board.Board,boolean)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)", "ownerclassid":"26", "ownerclassname":"PlyHashtable", "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe board before the move.\r\n * @param white\r\n * \t\tFlag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);"},
 {"id":242, "name":"getSize()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.getSize()", "ownerclassid":"26", "ownerclassname":"PlyHashtable", "sourcecode":"/**\r\n * Get the current number of entries.\r\n *\r\n * @return The current number of entries.\r\n */\r\nint getSize();"},
 {"id":243, "name":"pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "ownerclassid":"26", "ownerclassname":"PlyHashtable", "sourcecode":"/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * \t\tThe new entry, that the hashtable might store.\r\n */\r\nvoid pushEntry(PlyHashtableEntry ply);"},
 {"id":244, "name":"removeOldestEntry()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.removeOldestEntry()", "ownerclassid":"26", "ownerclassname":"PlyHashtable", "sourcecode":"/**\r\n * Try to remove the oldest entry.\r\n */\r\nvoid removeOldestEntry();"},
 {"id":245, "name":"reset()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.reset()", "ownerclassid":"26", "ownerclassname":"PlyHashtable", "sourcecode":"// Methods\r\n/**\r\n * Reset the hashtables for a new game.\r\n */\r\nvoid reset();"},
 {"id":246, "name":"setMaximumSize(int)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtable.setMaximumSize(int)", "ownerclassid":"26", "ownerclassname":"PlyHashtable", "sourcecode":"/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * \t\tThe new maximum number of entries.\r\n */\r\nvoid setMaximumSize(int maximumEntries);"},
 {"id":247, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.getBoard()", "ownerclassid":"27", "ownerclassname":"PlyHashtableEntry", "sourcecode":"/**\r\n * Get the game position before the ply is applied.\r\n *\r\n * @return The board before the ply is applied.\r\n */\r\nBoard getBoard();"},
 {"id":248, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.getPly()", "ownerclassid":"27", "ownerclassname":"PlyHashtableEntry", "sourcecode":"/**\r\n * Get the ply.\r\n *\r\n * @return The ply.\r\n */\r\nPly getPly();"},
 {"id":249, "name":"getSearchDepth()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.getSearchDepth()", "ownerclassid":"27", "ownerclassname":"PlyHashtableEntry", "sourcecode":"/**\r\n * Get the search depth for the computed ply.\r\n *\r\n * @return The search depth for the computed ply.\r\n */\r\nint getSearchDepth();"},
 {"id":250, "name":"hashKey()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.hashKey()", "ownerclassid":"27", "ownerclassname":"PlyHashtableEntry", "sourcecode":"/**\r\n * Request a key for this entry.\r\n *\r\n * @return The key for this entry.\r\n */\r\nlong hashKey();"},
 {"id":251, "name":"isWhiteMove()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.isWhiteMove()", "ownerclassid":"27", "ownerclassname":"PlyHashtableEntry", "sourcecode":"// Methods\r\n/**\r\n * Get the color, that is supposed to apply this ply.\r\n *\r\n * @return true, if white applies this ply.\r\n */\r\nboolean isWhiteMove();"},
 {"id":252, "name":"-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)", "fullmethod":"de.java_chess.javaChess.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * \t\tThe board before the ply.\r\n * @param ply\r\n * \t\tThe ply to store.\r\n * @param searchDepth\r\n * \t\tThe search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":253, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getBoard()", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the board of this entry.\r\n *\r\n * @return The board of this entry.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":254, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getPly()", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Get the ply.\r\n *\r\n * @return The ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":255, "name":"getSearchDepth()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getSearchDepth()", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Get the search depth for the computed ply.\r\n *\r\n * @return The search depth for the computed ply.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}"},
 {"id":256, "name":"hashKey()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey()", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Get the hashcode for this ply.\r\n *\r\n * @return A hashcode for this ply.\r\n */\r\npublic final long hashKey() {\r\n    return PlyHashtableEntryImpl.hashKey(getBoard(), isWhiteMove());\r\n}"},
 {"id":257, "name":"hashKey(de.java_chess.javaChess.board.Board,boolean)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}"},
 {"id":258, "name":"isWhiteMove()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.isWhiteMove()", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Check, if its a move with white pieces.\r\n *\r\n * @return true, if its a move with white pieces.\r\n */\r\npublic final boolean isWhiteMove() {\r\n    return (getBoard().getPiece(getPly().getSource()).getColor()) == (Piece.WHITE);\r\n}"},
 {"id":259, "name":"setBoard(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setBoard(de.java_chess.javaChess.board.Board)", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Set a new board for this entry.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":260, "name":"setPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Set the ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to set.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":261, "name":"setSearchDepth(int)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setSearchDepth(int)", "ownerclassid":"28", "ownerclassname":"PlyHashtableEntryImpl", "sourcecode":"/**\r\n * Set the search depth for the computed ply.\r\n *\r\n * @param searchDepth\r\n * \t\tThe search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}"},
 {"id":262, "name":"-init-(int)", "fullmethod":"de.java_chess.javaChess.PlyHashtableImpl.-init-(int)", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new hashtable instance with a given maximum size.\r\n *\r\n * @param maxSize\r\n * \t\tThe maximum number of entries.\r\n */\r\npublic PlyHashtableImpl(int maxSize) {\r\n    _hashtable = new Hashtable();\r\n    _orderedList = new LinkedList();\r\n    setMaximumSize(maxSize);\r\n}"},
 {"id":263, "name":"getMaximumSize()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getMaximumSize()", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"/**\r\n * Get the maximum number of entries in the hashtable.\r\n *\r\n * @return The maximum number of entries in the hashtable.\r\n */\r\npublic final int getMaximumSize() {\r\n    return _maxSize;\r\n}"},
 {"id":264, "name":"getPly(de.java_chess.javaChess.board.Board,boolean)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\ttrue, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}"},
 {"id":265, "name":"getSize()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getSize()", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"/**\r\n * Get the current number of entries.\r\n *\r\n * @return The current number of entries.\r\n */\r\npublic final int getSize() {\r\n    return _hashtable.size();\r\n}"},
 {"id":266, "name":"pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * \t\tThe new entry, that the hashtable might store.\r\n */\r\npublic final void pushEntry(PlyHashtableEntry ply) {\r\n    // Compute and store the key for this ply.\r\n    Long hashKey = new Long(ply.hashKey());\r\n    // Check if this ply is not already in the hashtable\r\n    PlyHashtableEntry oldEntry = ((PlyHashtableEntry) (_hashtable.get(hashKey)));\r\n    if (oldEntry != null) {\r\n        // There is a entry with the same key\r\n        if ((oldEntry.getSearchDepth()) >= (ply.getSearchDepth())) {\r\n            return;// This entry shouldnt be replaced.\r\n\r\n        }\r\n    } else {\r\n        // Now we actually add a new entry to the table.\r\n        // Check, if the hashtable has not exceeded its maximum capacity\r\n        // and remove older entries, if necessary.\r\n        while ((getSize()) >= (getMaximumSize())) {\r\n            removeOldestEntry();\r\n        } \r\n    }\r\n    // Put the new ply into the hashtable\r\n    _hashtable.put(hashKey, ply);\r\n    // Append the new ply at the end of the list of plies.\r\n    // ATTENTION: this will only work, if theres only _one_\r\n    // ply for each key!\r\n    _orderedList.add(hashKey);\r\n}"},
 {"id":267, "name":"removeOldestEntry()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.removeOldestEntry()", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"/**\r\n * Try to remove the oldest entry.\r\n * ATTENTION: this version will only work, if theres only _one_ entry for each hashkey!\r\n */\r\npublic final void removeOldestEntry() {\r\n    // Get and remove the oldest ply from the ordered list.\r\n    _hashtable.remove(_orderedList.removeFirst());\r\n}"},
 {"id":268, "name":"reset()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.reset()", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"// Methods\r\n/**\r\n * Reset the hashtables for a new game.\r\n */\r\npublic void reset() {\r\n    _hashtable.clear();\r\n    // Remove all the entries from the hashtable.\r\n    _orderedList.clear();// And the ordered list.\r\n\r\n}"},
 {"id":269, "name":"setMaximumSize(int)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.setMaximumSize(int)", "ownerclassid":"29", "ownerclassname":"PlyHashtableImpl", "sourcecode":"/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * \t\tThe new maximum number of entries.\r\n */\r\npublic final void setMaximumSize(int maximumEntries) {\r\n    _maxSize = maximumEntries;\r\n    // Remove the oldest entries, if the current size\r\n    // is bigger than the new maximum size.\r\n    while ((getSize()) > (getMaximumSize())) {\r\n        removeOldestEntry();\r\n    } \r\n}"},
 {"id":270, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.ZobristKeyImpl.-init-()", "ownerclassid":"30", "ownerclassname":"ZobristKeyImpl", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new key instance.\r\n */\r\nprivate ZobristKeyImpl() {\r\n    // Create a new multidimensional array.\r\n    _factors = new long[2][6][64];\r\n    Random rand = new Random();\r\n    for (int i = 0; i < 64; i++) {\r\n        for (int j = 0; j < 6; j++) {\r\n            _factors[0][j][i] = rand.nextLong();\r\n            _factors[1][j][i] = rand.nextLong();\r\n        }\r\n    }\r\n    _blackMoves = rand.nextLong();\r\n}"},
 {"id":271, "name":"computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "fullmethod":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)", "ownerclassid":"30", "ownerclassname":"ZobristKeyImpl", "sourcecode":"/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * \t\tThe current board.\r\n * @param white\r\n * \t\tFlag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}"},
 {"id":272, "name":"getInstance()", "fullmethod":"de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.getInstance()", "ownerclassid":"30", "ownerclassname":"ZobristKeyImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the only instance of this class.\r\n */\r\npublic static final ZobristKeyImpl getInstance() {\r\n    if ((ZobristKeyImpl._instance) == null) {\r\n        ZobristKeyImpl._instance = new ZobristKeyImpl();\r\n    }\r\n    return ZobristKeyImpl._instance;\r\n}"},
 {"id":273, "name":"addPGNopening(java.io.File)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBook.addPGNopening(java.io.File)", "ownerclassid":"31", "ownerclassname":"OpeningBook", "sourcecode":"/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * \t\tThe File to add to the opening book.\r\n */\r\nvoid addPGNopening(File file);"},
 {"id":274, "name":"doUserPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBook.doUserPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"31", "ownerclassname":"OpeningBook", "sourcecode":"// Methods\r\n/**\r\n * Advance the game by one user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply from the user.\r\n */\r\nvoid doUserPly(Ply ply);"},
 {"id":275, "name":"getOpeningBookPly()", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBook.getOpeningBookPly()", "ownerclassid":"31", "ownerclassname":"OpeningBook", "sourcecode":"/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\nAnalyzedPly getOpeningBookPly();"},
 {"id":276, "name":"reset()", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBook.reset()", "ownerclassid":"31", "ownerclassname":"OpeningBook", "sourcecode":"/**\r\n * Reset the opening book to the initial piece position.\r\n */\r\nvoid reset();"},
 {"id":277, "name":"-init-(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.OpeningBookImpl.-init-(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this class.\r\n *\r\n * @param notation\r\n * \t\tThe notation of the current game.\r\n */\r\npublic OpeningBookImpl(GameNotation notation) {\r\n    setNotation(notation);\r\n    // Create a new dynamic array for the openings.\r\n    _openings = new ArrayList();\r\n    // Reset the opening book.\r\n    reset();\r\n}"},
 {"id":278, "name":"addPGNopening(java.io.File)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.addPGNopening(java.io.File)", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * \t\tThe File to add to the opening book.\r\n */\r\npublic final void addPGNopening(File file) {\r\n    try {\r\n        PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n        GameNotation notation = pgnFile.readGame();\r\n        _openings.add(notation);\r\n        // System.out.println( \"DEBUG: added opening \n\" + notation.toString());\r\n    } catch (FileNotFoundException fe) {\r\n        JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (IOException ioe) {\r\n        JOptionPane.showMessageDialog(null, ((\"IO error while parsing file \" + (file.getName())) + \"!\"), \"IO error\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (RecognitionException re) {\r\n        JOptionPane.showMessageDialog(null, ((\"Error while parsing file \" + (file.getName())) + \"!\"), \"Error in PGN file\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (TokenStreamException te) {\r\n        System.err.print(\"Tokenstream exception\");\r\n    }\r\n}"},
 {"id":279, "name":"doUserPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.doUserPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"// Methods\r\n/**\r\n * The user just did a ply.\r\n *\r\n * @param ply\r\n * \t\tThe user ply.\r\n */\r\npublic final void doUserPly(Ply ply) {\r\n    // If we are already in a opening, check if the current user\r\n    // move doesnt lead us out of the opening line.\r\n    if ((_currentOpening) != (-1)) {\r\n        if (!(isInOpening(_currentOpening))) {\r\n            _currentOpening = -1;\r\n        }\r\n    }\r\n}"},
 {"id":280, "name":"findOpening()", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.findOpening()", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"/**\r\n * Try to find a opening for the current game notation.\r\n *\r\n * @return The index of the found opening.\r\n */\r\nprivate final int findOpening() {\r\n    for (int i = 0; i < (_openings.size()); i++) {\r\n        if (isInOpening(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;// No opening found.\r\n\r\n}"},
 {"id":281, "name":"getNotation()", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getNotation()", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"/**\r\n * Get the notation of the current game.\r\n *\r\n * @return The notation of the current game.\r\n */\r\nprivate final GameNotation getNotation() {\r\n    return _notation;\r\n}"},
 {"id":282, "name":"getOpeningBookPly()", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getOpeningBookPly()", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\npublic final AnalyzedPly getOpeningBookPly() {\r\n    // If we have no opening yet, try to find one.\r\n    if ((_currentOpening) == (-1)) {\r\n        _currentOpening = findOpening();\r\n    }\r\n    // Check, if we have found a opening.\r\n    if ((_currentOpening) != (-1)) {\r\n        // Check, if we have another ply in the opening.\r\n        int pliesMade = _notation.size();\r\n        GameNotation currentOpening = ((GameNotation) (_openings.get(_currentOpening)));\r\n        if ((currentOpening.size()) > pliesMade) {\r\n            return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)));\r\n        }\r\n    }\r\n    return null;// No ply found in the available opening books.\r\n\r\n}"},
 {"id":283, "name":"isInOpening(int)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * \t\tThe index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}"},
 {"id":284, "name":"reset()", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.reset()", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"/**\r\n * Reset the opening book to the initial piece position.\r\n */\r\npublic final void reset() {\r\n    _currentOpening = -1;\r\n}"},
 {"id":285, "name":"setNotation(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.setNotation(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"32", "ownerclassname":"OpeningBookImpl", "sourcecode":"/**\r\n * Set the notation of the current game.\r\n *\r\n * @param notation\r\n * \t\tThe notation of the current game.\r\n */\r\nprivate final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}"},
 {"id":286, "name":"-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "fullmethod":"de.java_chess.javaChess.LoadOpeningsAction.-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "ownerclassid":"33", "ownerclassname":"LoadOpeningsAction", "sourcecode":"// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param book\r\n * \t\tThe opening book, we are operating on.\r\n */\r\npublic LoadOpeningsAction(OpeningBook book) {\r\n    super(\"Load openings from PGN...\");\r\n    setOpeningBook(book);\r\n}"},
 {"id":287, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"33", "ownerclassname":"LoadOpeningsAction", "sourcecode":"// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * \t\tThe event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load opening from pgn files\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    // Allow the user to select directories.\r\n    chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        processFileOrDirectory(file);\r\n    }\r\n}"},
 {"id":288, "name":"getOpeningBook()", "fullmethod":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.getOpeningBook()", "ownerclassid":"33", "ownerclassname":"LoadOpeningsAction", "sourcecode":"/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}"},
 {"id":289, "name":"processFileOrDirectory(java.io.File)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processFileOrDirectory(java.io.File)", "ownerclassid":"33", "ownerclassname":"LoadOpeningsAction", "sourcecode":"/**\r\n * Process a file or directory.\r\n *\r\n * @param file\r\n * \t\tThe file to process.\r\n */\r\nprivate final void processFileOrDirectory(File file) {\r\n    // If this file is a directory, read all the files in it.\r\n    if (file.isDirectory()) {\r\n        String[] files = file.list();// Get the content of the directory\r\n\r\n        // Now create an absolute file from each name and process it.\r\n        for (int i = 0; i < (files.length); i++) {\r\n            processFileOrDirectory(new File(file, files[i]));\r\n        }\r\n    } else {\r\n        // This is a single file, so\r\n        // check, if it might be a PGN file.\r\n        if (SaveGameAsAction.getPGNFileFilter().accept(file)) {\r\n            processPGNfile(file);\r\n        }\r\n    }\r\n}"},
 {"id":290, "name":"processPGNfile(java.io.File)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processPGNfile(java.io.File)", "ownerclassid":"33", "ownerclassname":"LoadOpeningsAction", "sourcecode":"/**\r\n * Process a single PGN file.\r\n *\r\n * @param file\r\n * \t\tThe PGN file to process.\r\n */\r\nprivate final void processPGNfile(File file) {\r\n    getOpeningBook().addPGNopening(file);\r\n}"},
 {"id":291, "name":"setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "fullmethod":"de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)", "ownerclassid":"33", "ownerclassname":"LoadOpeningsAction", "sourcecode":"/**\r\n * Set the opening book, we are operating on.\r\n *\r\n * @param book\r\n * \t\tThe new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}"},
 {"id":292, "name":"-init-(de.java_chess.javaChess.engine.ChessEngine)", "fullmethod":"de.java_chess.javaChess.PermanentBrain.-init-(de.java_chess.javaChess.engine.ChessEngine)", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"// Constructors\r\n/**\r\n * Create a new PermanentBrain instance.\r\n *\r\n * @param engine\r\n * \t\tThe used chess engine.\r\n */\r\npublic PermanentBrain(ChessEngine engine) {\r\n    setEngine(engine);\r\n}"},
 {"id":293, "name":"getEngine()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getEngine()", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"// Methods\r\n/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nprivate final ChessEngine getEngine() {\r\n    return _engine;\r\n}"},
 {"id":294, "name":"getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"},
 {"id":295, "name":"getUserPlies()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getUserPlies()", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"/**\r\n * Get the potential plies for a user.\r\n * (Required to validate a user ply.)\r\n *\r\n * @return The potential plies for a user.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    // Lazy computation for better performance.\r\n    if ((_userPlies) == null) {\r\n        _userPlies = getEngine().getUserPlies();\r\n    }\r\n    return _userPlies;// Return the user plies.\r\n\r\n}"},
 {"id":296, "name":"resetUserPlies()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.resetUserPlies()", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"/**\r\n * Reset (remove) the user plies.\r\n */\r\npublic final void resetUserPlies() {\r\n    _userPlies = null;\r\n}"},
 {"id":297, "name":"run()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.run()", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"/**\r\n * The actual search method.\r\n */\r\npublic void run() {\r\n    // Start with search depth 1\r\n    ((ChessEngineImpl) (getEngine())).setSearchDepth(1);\r\n    // Save the current board of the actual game.\r\n    Board currentBoard = getEngine().getBoard();// No clone() required at the moment.\r\n\r\n    // Get the user plies as a local variable.\r\n    Ply[] userPlies = getUserPlies();\r\n    // Let the minimax search run through.\r\n    ((ChessEngineImpl) (getEngine())).setSearchStop(false);\r\n    // Reset the number of analyzed boards.\r\n    ((ChessEngineImpl) (getEngine())).setAnalyzedBoards(0L);\r\n    while ((_searchThread) == (Thread.currentThread())) {\r\n        // Go through all the user plies and compute a response.\r\n        for (int i = 0; (i < (userPlies.length)) && ((_searchThread) == (Thread.currentThread())); i++) {\r\n            getEngine().setBoard(currentBoard.getBoardAfterPly(userPlies[i]));\r\n            try {\r\n                _computedPlies[i] = new PreComputedPlyImpl(((ChessEngineImpl) (getEngine())).startMinimaxAlphaBeta(getEngine().isWhite()), ((ChessEngineImpl) (getEngine())).getSearchDepth());\r\n            } catch (InterruptedException ignored) {\r\n                _computedPlies[i] = null;\r\n            }\r\n        }\r\n        // Increase the search depth and continue with another run.\r\n        ((ChessEngineImpl) (getEngine())).increaseSearchDepth();\r\n    } \r\n    // Restore the current board.\r\n    getEngine().setBoard(currentBoard);\r\n}"},
 {"id":298, "name":"setEngine(de.java_chess.javaChess.engine.ChessEngine)", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.setEngine(de.java_chess.javaChess.engine.ChessEngine)", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * \t\tThe new chess engine.\r\n */\r\nprivate final void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}"},
 {"id":299, "name":"startComputation()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.startComputation()", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"/**\r\n * Start the computation of a response to the next user ply.\r\n */\r\npublic final void startComputation() {\r\n    // Stop the computation, if it was a reset.\r\n    stopComputation();\r\n    // Reset the permanent brain for the next user move.\r\n    resetUserPlies();\r\n    _computedPlies = new PreComputedPly[getUserPlies().length];\r\n    if ((_searchThread) == null) {\r\n        // Should always be null\r\n        _searchThread = new Thread(this);\r\n        _searchThread.start();\r\n    }\r\n}"},
 {"id":300, "name":"stopComputation()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.stopComputation()", "ownerclassid":"34", "ownerclassname":"PermanentBrain", "sourcecode":"/**\r\n * Stop the computation of a response to the next user ply.\r\n */\r\npublic final void stopComputation() {\r\n    if ((_searchThread) != null) {\r\n        Thread savedThread = _searchThread;// Save the thread.\r\n\r\n        ((ChessEngineImpl) (getEngine())).setSearchStop(true);\r\n        _searchThread = null;\r\n        // Signal to finish.\r\n        try {\r\n            savedThread.join();// Use the copy to wait\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }// for the thread to finish.\r\n\r\n    }\r\n}"},
 {"id":301, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPly.getPly()", "ownerclassid":"35", "ownerclassname":"PreComputedPly", "sourcecode":"// Methods\r\n/**\r\n * Get the computed ply.\r\n *\r\n * @return The computed ply.\r\n */\r\nAnalyzedPly getPly();"},
 {"id":302, "name":"getSearchDepth()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPly.getSearchDepth()", "ownerclassid":"35", "ownerclassname":"PreComputedPly", "sourcecode":"/**\r\n * Get the search depth, that was used to compute this ply.\r\n *\r\n * @return The search depth for this ply.\r\n */\r\nint getSearchDepth();"},
 {"id":303, "name":"-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)", "fullmethod":"de.java_chess.javaChess.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)", "ownerclassid":"36", "ownerclassname":"PreComputedPlyImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * \t\tThe computed ply.\r\n * @param searchDepth\r\n * \t\tThe used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}"},
 {"id":304, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getPly()", "ownerclassid":"36", "ownerclassname":"PreComputedPlyImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the computed ply.\r\n *\r\n * @return The computed ply.\r\n */\r\npublic final AnalyzedPly getPly() {\r\n    return _ply;\r\n}"},
 {"id":305, "name":"getSearchDepth()", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getSearchDepth()", "ownerclassid":"36", "ownerclassname":"PreComputedPlyImpl", "sourcecode":"/**\r\n * Get the used search depth.\r\n *\r\n * @return The used search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}"},
 {"id":306, "name":"setPly(de.java_chess.javaChess.ply.AnalyzedPly)", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setPly(de.java_chess.javaChess.ply.AnalyzedPly)", "ownerclassid":"36", "ownerclassname":"PreComputedPlyImpl", "sourcecode":"/**\r\n * Set the computed ply.\r\n *\r\n * @param ply\r\n * \t\tThe computed ply.\r\n */\r\nprivate final void setPly(AnalyzedPly ply) {\r\n    _ply = ply;\r\n}"},
 {"id":307, "name":"setSearchDepth(int)", "fullmethod":"de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setSearchDepth(int)", "ownerclassid":"36", "ownerclassname":"PreComputedPlyImpl", "sourcecode":"/**\r\n * Set the used search depth.\r\n *\r\n * @param searchDepth\r\n * \t\tThe used search depth.\r\n */\r\nprivate final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}"},
 {"id":308, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.AnalyzerTest1.-init-()", "ownerclassid":"37", "ownerclassname":"AnalyzerTest1", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic AnalyzerTest1() {\r\n    super(\"A simple analyzer test with a attack on the black queen\");\r\n}"},
 {"id":309, "name":"analyzerTest1()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest1.analyzerTest1()", "ownerclassid":"37", "ownerclassname":"AnalyzerTest1", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void analyzerTest1() {\r\n    // Do the 1st analysis\r\n    short score1 = _analyzer.analyze(((BitBoard) (_board)), true);\r\n    // Move the pawn and attack a black pawn\r\n    _board.doPly(new PlyImpl(new PositionImpl(43), new PositionImpl(52), true));\r\n    // Analyze the board after the ply\r\n    short score2 = _analyzer.analyze(((BitBoard) (_board)), false);\r\n    // Check if the 2nd board is better for white.\r\n    TestCase.assertTrue(\"Analyzer did not recognize attack on black piece\", (score2 > score1));\r\n    // Now attack the black queen.\r\n    _board.doPly(new PlyImpl(new PositionImpl(52), new PositionImpl(59), true));\r\n    // Analyze the board again\r\n    short score3 = _analyzer.analyze(((BitBoard) (_board)), false);\r\n    TestCase.assertTrue(\"Analyzer does not recognize attack on black queen\", (score3 > score2));\r\n}"},
 {"id":310, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest1.runTest()", "ownerclassid":"37", "ownerclassname":"AnalyzerTest1", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    analyzerTest1();\r\n}"},
 {"id":311, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest1.setUp()", "ownerclassid":"37", "ownerclassname":"AnalyzerTest1", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, new PlyHashtableImpl(1000));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the black knight to f6\r\n    _board.doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move a white pawn to the 6th row\r\n    _board.doPly(new PlyImpl(new PositionImpl(11), new PositionImpl((11 + 32)), false));\r\n}"},
 {"id":312, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.AnalyzerTest2.-init-()", "ownerclassid":"38", "ownerclassname":"AnalyzerTest2", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic AnalyzerTest2() {\r\n    super(\"A simple analyzer test for a opening strategy\");\r\n}"},
 {"id":313, "name":"analyzerTest2()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest2.analyzerTest2()", "ownerclassid":"38", "ownerclassname":"AnalyzerTest2", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void analyzerTest2() {\r\n    prepareTest();\r\n    // Move the black pawn to e5 and analyze the board\r\n    doPly(new PlyImpl(new PositionImpl(\"e7\"), new PositionImpl(\"e5\"), false));\r\n    // Do the 1st analysis\r\n    short score1 = _analyzer.analyze(((BitBoard) (_board)), true);\r\n    prepareTest();\r\n    doPly(new PlyImpl(new PositionImpl(\"g8\"), new PositionImpl(\"h6\"), false));\r\n    // Analyze the board after the ply\r\n    short score2 = _analyzer.analyze(((BitBoard) (_board)), false);\r\n    // Check if the 2nd board is better for white.\r\n    TestCase.assertTrue(\"Analyzer prefers pawn move\", (score2 > score1));\r\n}"},
 {"id":314, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest2.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"38", "ownerclassname":"AnalyzerTest2", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":315, "name":"prepareTest()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest2.prepareTest()", "ownerclassid":"38", "ownerclassname":"AnalyzerTest2", "sourcecode":"/**\r\n * Prepare the opening test.\r\n */\r\nprivate final void prepareTest() {\r\n    reset();\r\n    // Move a white pawn to the 4th row\r\n    doPly(new PlyImpl(new PositionImpl(\"e2\"), new PositionImpl(\"e4\"), false));\r\n}"},
 {"id":316, "name":"reset()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest2.reset()", "ownerclassid":"38", "ownerclassname":"AnalyzerTest2", "sourcecode":"/**\r\n * Reset the game for a new score.\r\n */\r\nprivate final void reset() {\r\n    _game.reset();\r\n    _board.initialPosition();\r\n}"},
 {"id":317, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest2.runTest()", "ownerclassid":"38", "ownerclassname":"AnalyzerTest2", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    analyzerTest2();\r\n}"},
 {"id":318, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.AnalyzerTest2.setUp()", "ownerclassid":"38", "ownerclassname":"AnalyzerTest2", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, new PlyHashtableImpl(1000));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n}"},
 {"id":319, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.BoardConsistencyTest1.-init-()", "ownerclassid":"39", "ownerclassname":"BoardConsistencyTest1", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic BoardConsistencyTest1() {\r\n    super(\"A test if the engine does not alter the board unintentionally during the search for the best ply\");\r\n}"},
 {"id":320, "name":"boardConsistencyTest1()", "fullmethod":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1.boardConsistencyTest1()", "ownerclassid":"39", "ownerclassname":"BoardConsistencyTest1", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void boardConsistencyTest1() {\r\n    TestCase.assertTrue(\"Row1 complete after initial position\", (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    TestCase.assertTrue(\"Row1 complete after e2 - e4\", (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Compute the best ply for this game position.\r\n    Ply bestPly = _engine.computeBestPly();\r\n    doPly(bestPly);\r\n    TestCase.assertTrue((\"Row1 complete after \" + (bestPly.toString())), (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Move the white pawn from d2 - d4\r\n    doPly(new PlyImpl(new PositionImpl(11), new PositionImpl((11 + 16)), false));\r\n    TestCase.assertTrue(\"Row1 complete after d2 - d4\", (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Compute the best ply for this game position.\r\n    bestPly = _engine.computeBestPly();\r\n    doPly(bestPly);\r\n    TestCase.assertTrue((\"Row1 complete after \" + (bestPly.toString())), (((_board.getEmptySquares()) & 255L) == 0L));\r\n}"},
 {"id":321, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"39", "ownerclassname":"BoardConsistencyTest1", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":322, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1.runTest()", "ownerclassid":"39", "ownerclassname":"BoardConsistencyTest1", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    boardConsistencyTest1();\r\n}"},
 {"id":323, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.BoardConsistencyTest1.setUp()", "ownerclassid":"39", "ownerclassname":"BoardConsistencyTest1", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create a engine instance.\r\n    _engine = new ChessEngineImpl(_game, null, _board, false);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n}"},
 {"id":324, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.ChessEngineTest.-init-()", "ownerclassid":"40", "ownerclassname":"ChessEngineTest", "sourcecode":"ChessEngineTest() {\r\n}"},
 {"id":325, "name":"suite()", "fullmethod":"de.java_chess.javaChess.engine.test.ChessEngineTest.suite()", "ownerclassid":"40", "ownerclassname":"ChessEngineTest", "sourcecode":"/**\r\n * Create the engine test suite.\r\n *\r\n * @return The engine test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite\r\n    TestSuite suite = new TestSuite();\r\n    // Test the ply generator\r\n    suite.addTest(new PlyGeneratorTest1());\r\n    suite.addTest(new PlyGeneratorTest2());\r\n    suite.addTest(new PlyGeneratorTest3());\r\n    suite.addTest(new PlyGeneratorTest4());\r\n    suite.addTest(new PlyGeneratorTest5());\r\n    suite.addTest(new PlyGeneratorTest6());\r\n    // Add the actual engine tests.\r\n    suite.addTest(new KingInKnightCheckTest());\r\n    // Test the analyzer\r\n    suite.addTest(new AnalyzerTest1());\r\n    suite.addTest(new AnalyzerTest2());\r\n    // Test the complete engine\r\n    suite.addTest(new MinimaxTest1());\r\n    suite.addTest(new MinimaxTest2());\r\n    suite.addTest(new BoardConsistencyTest1());\r\n    return suite;\r\n}"},
 {"id":326, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.KingInKnightCheckTest.-init-()", "ownerclassid":"41", "ownerclassname":"KingInKnightCheckTest", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic KingInKnightCheckTest() {\r\n    super(\"King is in knight check test\");\r\n}"},
 {"id":327, "name":"knightTests()", "fullmethod":"de.java_chess.javaChess.engine.test.KingInKnightCheckTest.knightTests()", "ownerclassid":"41", "ownerclassname":"KingInKnightCheckTest", "sourcecode":"/**\r\n * Run the actual knight tests.\r\n */\r\npublic void knightTests() {\r\n    // Now set the black knight on every other square to see if the analyzer\r\n    // reports a check.\r\n    for (int i = 63; i >= 0; i--) {\r\n        Position currentPosition = new PositionImpl(i);\r\n        if (null == (_board.getPiece(currentPosition))) {\r\n            // If this square is empty\r\n            _board.setPiece(new PieceImpl(Piece.KNIGHT, Piece.BLACK), currentPosition);// Set a black knight there.\r\n\r\n            int squareIndexDifference = Math.abs((i - (_whiteKingPos)));\r\n            // The white king is in check, if the square difference is\r\n            // 6, 10, 15 or 17 (count the squares on a board to verify this).\r\n            boolean whiteKingIsInCheck = (((squareIndexDifference == 6) || (squareIndexDifference == 10)) || (squareIndexDifference == 15)) || (squareIndexDifference == 17);\r\n            // Only if the white king is in check, the analyzer should return BLACK_WIN.\r\n            TestCase.assertTrue((\"Wrong check status with knight on square \" + i), (whiteKingIsInCheck == (_analyzer.isInCheck(((BitBoard) (_board)), true))));\r\n            _board.setPiece(null, currentPosition);// Remove the black knight from the current square.\r\n\r\n        }\r\n    }\r\n}"},
 {"id":328, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.KingInKnightCheckTest.runTest()", "ownerclassid":"41", "ownerclassname":"KingInKnightCheckTest", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    knightTests();\r\n}"},
 {"id":329, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.KingInKnightCheckTest.setUp()", "ownerclassid":"41", "ownerclassname":"KingInKnightCheckTest", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Set the positions of the 2 kings.\r\n    _whiteKingPos = 4;\r\n    _blackKingPos = 60;\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator (the hashtable is not used here).\r\n    _plyGenerator = new PlyGenerator(_game, new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    // Set the 2 kings on the board\r\n    _board.setPiece(new PieceImpl(Piece.KING, Piece.BLACK), new PositionImpl(_blackKingPos));\r\n    _board.setPiece(new PieceImpl(Piece.KING, Piece.WHITE), new PositionImpl(_whiteKingPos));\r\n}"},
 {"id":330, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.MinimaxTest1.-init-()", "ownerclassid":"42", "ownerclassname":"MinimaxTest1", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic MinimaxTest1() {\r\n    super(\"A test of the minimax implementation, if boards are passed correctly over search depths\");\r\n}"},
 {"id":331, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest1.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"42", "ownerclassname":"MinimaxTest1", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":332, "name":"minimaxTest1()", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest1.minimaxTest1()", "ownerclassid":"42", "ownerclassname":"MinimaxTest1", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void minimaxTest1() {\r\n    // Compute the best ply for this game position.\r\n    Ply bestPly = _engine.computeBestPly();\r\n    // Check if e7 - e5 was delivered as the best ply.\r\n    TestCase.assertTrue(\"Engine computed invalid ply e7-e5\", (((bestPly.getSource().getSquareIndex()) != 52) || ((bestPly.getDestination().getSquareIndex()) != (52 - 15))));\r\n}"},
 {"id":333, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest1.runTest()", "ownerclassid":"42", "ownerclassname":"MinimaxTest1", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    minimaxTest1();\r\n}"},
 {"id":334, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest1.setUp()", "ownerclassid":"42", "ownerclassname":"MinimaxTest1", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create a engine instance.\r\n    _engine = new ChessEngineImpl(_game, null, _board, false);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black knight to f6\r\n    doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move the white pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl(((12 + 16) + 8)), false));\r\n}"},
 {"id":335, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.MinimaxTest2.-init-()", "ownerclassid":"43", "ownerclassname":"MinimaxTest2", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic MinimaxTest2() {\r\n    super(\"A test of the minimax implementation, if piece captures are not recognized\");\r\n}"},
 {"id":336, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest2.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"43", "ownerclassname":"MinimaxTest2", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":337, "name":"minimaxTest1()", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest2.minimaxTest1()", "ownerclassid":"43", "ownerclassname":"MinimaxTest2", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void minimaxTest1() {\r\n    // Compute the best ply for this game position.\r\n    Ply bestPly = _engine.computeBestPly();\r\n    // Check if Qxg2 was delivered as the best ply.\r\n    TestCase.assertTrue(\"Engine computed ply Qxg2\", (((bestPly.getSource().getSquareIndex()) != 38) || ((bestPly.getDestination().getSquareIndex()) != 14)));\r\n}"},
 {"id":338, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest2.runTest()", "ownerclassid":"43", "ownerclassname":"MinimaxTest2", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    minimaxTest1();\r\n}"},
 {"id":339, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.MinimaxTest2.setUp()", "ownerclassid":"43", "ownerclassname":"MinimaxTest2", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create a engine instance.\r\n    _engine = new ChessEngineImpl(_game, null, _board, false);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl(52), new PositionImpl((52 - 16)), false));\r\n    // Move the white pawn to f3\r\n    doPly(new PlyImpl(new PositionImpl(13), new PositionImpl((13 + 8)), false));\r\n    // Move the black queen to g5\r\n    doPly(new PlyImpl(new PositionImpl(59), new PositionImpl(38), false));\r\n    // Move the white pawn to d3\r\n    doPly(new PlyImpl(new PositionImpl(11), new PositionImpl(19), false));\r\n    // Black is about to move\r\n    _engine.setWhite(false);\r\n}"},
 {"id":340, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PlyGeneratorTest1.-init-()", "ownerclassid":"44", "ownerclassname":"PlyGeneratorTest1", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest1() {\r\n    super(\"A simple ply generator test with a attack on the pawn e5\");\r\n}"},
 {"id":341, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"44", "ownerclassname":"PlyGeneratorTest1", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":342, "name":"plygeneratorTest1()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1.plygeneratorTest1()", "ownerclassid":"44", "ownerclassname":"PlyGeneratorTest1", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void plygeneratorTest1() {\r\n    // Get the plies for black\r\n    Ply[] plies = _plyGenerator.getPliesForColor(false);\r\n    // Check if e7 - e5 was delivered as a potential ply.\r\n    boolean containsInvalidMoves = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 52) && ((plies[i].getDestination().getSquareIndex()) == (52 - 16))) {\r\n            containsInvalidMoves = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes invalid move e7 - e5\", (!containsInvalidMoves));\r\n}"},
 {"id":343, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1.runTest()", "ownerclassid":"44", "ownerclassname":"PlyGeneratorTest1", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    plygeneratorTest1();\r\n}"},
 {"id":344, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest1.setUp()", "ownerclassid":"44", "ownerclassname":"PlyGeneratorTest1", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black knight to f6\r\n    doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move the white pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl(((12 + 16) + 8)), false));\r\n}"},
 {"id":345, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PlyGeneratorTest2.-init-()", "ownerclassid":"45", "ownerclassname":"PlyGeneratorTest2", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest2() {\r\n    super(\"A simple ply generator test with a attack on the knight g3\");\r\n}"},
 {"id":346, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"45", "ownerclassname":"PlyGeneratorTest2", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":347, "name":"generatorTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2.generatorTest()", "ownerclassid":"45", "ownerclassname":"PlyGeneratorTest2", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for black\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if h2 - g3 was delivered as a potential ply.\r\n    boolean containsCaptureMove = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 15) && ((plies[i].getDestination().getSquareIndex()) == 22)) {\r\n            containsCaptureMove = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes capture move h2 - g3\", containsCaptureMove);\r\n}"},
 {"id":348, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2.runTest()", "ownerclassid":"45", "ownerclassname":"PlyGeneratorTest2", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}"},
 {"id":349, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest2.setUp()", "ownerclassid":"45", "ownerclassname":"PlyGeneratorTest2", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black knight to f6\r\n    doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move the white pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl(((12 + 16) + 8)), false));\r\n    // Move the black knight to e4\r\n    doPly(new PlyImpl(new PositionImpl((62 - 17)), new PositionImpl((12 + 16)), false));\r\n    // Move f2 - f3\r\n    doPly(new PlyImpl(new PositionImpl(13), new PositionImpl((13 + 8)), false));\r\n    // Move the black knight to g3 (??)\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl((14 + 8)), false));\r\n}"},
 {"id":350, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PlyGeneratorTest3.-init-()", "ownerclassid":"46", "ownerclassname":"PlyGeneratorTest3", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest3() {\r\n    super(\"A simple ply generator test for a illegal queen move h4-a5\");\r\n}"},
 {"id":351, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"46", "ownerclassname":"PlyGeneratorTest3", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":352, "name":"generatorTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3.generatorTest()", "ownerclassid":"46", "ownerclassname":"PlyGeneratorTest3", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for black\r\n    Ply[] plies = _plyGenerator.getPliesForColor(false);\r\n    // Check if h4-a5 was delivered as a potential ply.\r\n    boolean containsIllegalMove = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 31) && ((plies[i].getDestination().getSquareIndex()) == 32)) {\r\n            containsIllegalMove = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator does not computes move h4-a5\", (!containsIllegalMove));\r\n}"},
 {"id":353, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3.runTest()", "ownerclassid":"46", "ownerclassname":"PlyGeneratorTest3", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}"},
 {"id":354, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest3.setUp()", "ownerclassid":"46", "ownerclassname":"PlyGeneratorTest3", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black pawn from e7 - e5\r\n    doPly(new PlyImpl(new PositionImpl(52), new PositionImpl(36), false));\r\n    // Move f2 - f3\r\n    doPly(new PlyImpl(new PositionImpl(13), new PositionImpl((13 + 8)), false));\r\n    // Move the black queen to h4\r\n    doPly(new PlyImpl(new PositionImpl(59), new PositionImpl(31), false));\r\n    // Move g2-g3\r\n    doPly(new PlyImpl(new PositionImpl(14), new PositionImpl((14 + 8)), false));\r\n}"},
 {"id":355, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PlyGeneratorTest4.-init-()", "ownerclassid":"47", "ownerclassname":"PlyGeneratorTest4", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest4() {\r\n    super(\"A simple ply generator test for a rook capture on h8 by a bishop\");\r\n}"},
 {"id":356, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"47", "ownerclassname":"PlyGeneratorTest4", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":357, "name":"generatorTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4.generatorTest()", "ownerclassid":"47", "ownerclassname":"PlyGeneratorTest4", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for white\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if b2 x h8 was delivered as a potential ply.\r\n    boolean containsCapture = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 9) && ((plies[i].getDestination().getSquareIndex()) == 63)) {\r\n            containsCapture = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes capture b2 x h8\", containsCapture);\r\n}"},
 {"id":358, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4.runTest()", "ownerclassid":"47", "ownerclassname":"PlyGeneratorTest4", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}"},
 {"id":359, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest4.setUp()", "ownerclassid":"47", "ownerclassname":"PlyGeneratorTest4", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from b2 - b3\r\n    doPly(new PlyImpl(new PositionImpl(9), new PositionImpl(17), false));\r\n    // Move the black pawn from g7 - g6\r\n    doPly(new PlyImpl(new PositionImpl(54), new PositionImpl(46), false));\r\n    // Move the bishop from c1 - b2\r\n    doPly(new PlyImpl(new PositionImpl(2), new PositionImpl(9), false));\r\n    // Move the black pawn from g6 - g5 (doesnt matter anyway. Just keep\r\n    // the attack on h8 open.\r\n    doPly(new PlyImpl(new PositionImpl(66), new PositionImpl((66 - 8)), false));\r\n}"},
 {"id":360, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PlyGeneratorTest5.-init-()", "ownerclassid":"48", "ownerclassname":"PlyGeneratorTest5", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest5() {\r\n    super(\"A simple ply generator test for a queen capture on h7 by a bishop\");\r\n}"},
 {"id":361, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"48", "ownerclassname":"PlyGeneratorTest5", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":362, "name":"generatorTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5.generatorTest()", "ownerclassid":"48", "ownerclassname":"PlyGeneratorTest5", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for white\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if d3 x h7 was delivered as a potential ply.\r\n    boolean containsCapture = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if ((19 == (plies[i].getSource().getSquareIndex())) && (55 == (plies[i].getDestination().getSquareIndex()))) {\r\n            containsCapture = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes capture d3 x h7\", containsCapture);\r\n}"},
 {"id":363, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5.runTest()", "ownerclassid":"48", "ownerclassname":"PlyGeneratorTest5", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}"},
 {"id":364, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest5.setUp()", "ownerclassid":"48", "ownerclassname":"PlyGeneratorTest5", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Perform the moves to get to the tested board position.\r\n    for (int i = 0; i < (_prevMoves.length); i++) {\r\n        doPly(new PlyImpl(new PositionImpl(_prevMoves[i][0]), new PositionImpl(_prevMoves[i][1]), false));\r\n    }\r\n}"},
 {"id":365, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PlyGeneratorTest6.-init-()", "ownerclassid":"49", "ownerclassname":"PlyGeneratorTest6", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest6() {\r\n    super(\"A simple ply generator test for a bishop move f1-c4\");\r\n}"},
 {"id":366, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"49", "ownerclassname":"PlyGeneratorTest6", "sourcecode":"/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}"},
 {"id":367, "name":"generatorTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6.generatorTest()", "ownerclassid":"49", "ownerclassname":"PlyGeneratorTest6", "sourcecode":"/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for white\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if d3 x h7 was delivered as a potential ply.\r\n    boolean containsMove = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if ((5 == (plies[i].getSource().getSquareIndex())) && (26 == (plies[i].getDestination().getSquareIndex()))) {\r\n            containsMove = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes bishop move f1 - c4\", containsMove);\r\n}"},
 {"id":368, "name":"runTest()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6.runTest()", "ownerclassid":"49", "ownerclassname":"PlyGeneratorTest6", "sourcecode":"// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}"},
 {"id":369, "name":"setUp()", "fullmethod":"de.java_chess.javaChess.engine.test.PlyGeneratorTest6.setUp()", "ownerclassid":"49", "ownerclassname":"PlyGeneratorTest6", "sourcecode":"/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Perform the moves to get to the tested board position.\r\n    for (int i = 0; i < (_prevMoves.length); i++) {\r\n        doPly(new PlyImpl(new PositionImpl(_prevMoves[i][0]), new PositionImpl(_prevMoves[i][1]), false));\r\n    }\r\n}"},
 {"id":370, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.game.Game.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"50", "ownerclassname":"Game", "sourcecode":"/**\r\n * Add a new ply to the game.\r\n *\r\n * @unknown The new ply.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":371, "name":"getLastPly()", "fullmethod":"de.java_chess.javaChess.game.Game.getLastPly()", "ownerclassid":"50", "ownerclassname":"Game", "sourcecode":"/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\nPly getLastPly();"},
 {"id":372, "name":"getNumberOfPlies()", "fullmethod":"de.java_chess.javaChess.game.Game.getNumberOfPlies()", "ownerclassid":"50", "ownerclassname":"Game", "sourcecode":"/**\r\n * Get the number of plies in this game.\r\n *\r\n * @return The number of plies in this game.\r\n */\r\nint getNumberOfPlies();"},
 {"id":373, "name":"hasBeenMoved(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.game.Game.hasBeenMoved(de.java_chess.javaChess.position.Position)", "ownerclassid":"50", "ownerclassname":"Game", "sourcecode":"/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * \t\tThe position to check.\r\n */\r\nboolean hasBeenMoved(Position position);"},
 {"id":374, "name":"reset()", "fullmethod":"de.java_chess.javaChess.game.Game.reset()", "ownerclassid":"50", "ownerclassname":"Game", "sourcecode":"// Methods\r\n/**\r\n * Reset the game.\r\n */\r\nvoid reset();"},
 {"id":375, "name":"undoLastPly()", "fullmethod":"de.java_chess.javaChess.game.Game.undoLastPly()", "ownerclassid":"50", "ownerclassname":"Game", "sourcecode":"/**\r\n * Take the last ply back.\r\n */\r\nvoid undoLastPly();"},
 {"id":376, "name":"-init-(de.java_chess.javaChess.ply.Ply,long)", "fullmethod":"de.java_chess.javaChess.GameImpl.-init-(de.java_chess.javaChess.ply.Ply,long)", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this game status.\r\n * @param bitmask\r\n * \t\tThe moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}"},
 {"id":377, "name":"-init-(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.GameImpl.-init-(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * \t\tThe first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}"},
 {"id":378, "name":"-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "fullmethod":"de.java_chess.javaChess.GameImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * \t\tThe previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}"},
 {"id":379, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.GameImpl.-init-()", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new game instance.\r\n */\r\npublic GameImpl() {\r\n    _gameStatus = new UnsynchronizedArrayStack();\r\n}"},
 {"id":380, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.game.GameImpl.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Do a new ply in this game.\r\n *\r\n * @param ply\r\n * \t\tThe next ply.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    // Add a new game status, that derives from the previous status.\r\n    _gameStatus.push(((getLastGameStatus()) == null ? new GameImpl.GameStatus(ply) : new GameImpl.GameStatus(ply, getLastGameStatus())));\r\n}"},
 {"id":381, "name":"getLastGameStatus()", "fullmethod":"de.java_chess.javaChess.game.GameImpl.getLastGameStatus()", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the last game status.\r\n *\r\n * @return The last game status.\r\n */\r\nprivate final GameImpl.GameStatus getLastGameStatus() {\r\n    return _gameStatus.empty() ? null : ((GameImpl.GameStatus) (_gameStatus.peek()));\r\n}"},
 {"id":382, "name":"getLastPly()", "fullmethod":"de.java_chess.javaChess.game.GameImpl.getLastPly()", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\npublic final Ply getLastPly() {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? null : lastStatus.getPly();\r\n}"},
 {"id":383, "name":"getNumberOfPlies()", "fullmethod":"de.java_chess.javaChess.game.GameImpl.getNumberOfPlies()", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Get the total number of plies.\r\n *\r\n * @return The total number of plies.\r\n */\r\npublic final int getNumberOfPlies() {\r\n    return _gameStatus.size();\r\n}"},
 {"id":384, "name":"hasBeenMoved(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * \t\tThe position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}"},
 {"id":385, "name":"reset()", "fullmethod":"de.java_chess.javaChess.game.GameImpl.reset()", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Reset the game.\r\n */\r\npublic final void reset() {\r\n    // Simply remove all the status instances from the game.\r\n    _gameStatus.clear();\r\n}"},
 {"id":386, "name":"toString()", "fullmethod":"de.java_chess.javaChess.game.GameImpl.toString()", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Convert the game to a string.\r\n *\r\n * @return A string representation of the game.\r\n */\r\npublic final String toString() {\r\n    // A buffer for the string representation\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Iterate over the stack content\r\n    for (Iterator iter = _gameStatus.iterator(); iter.hasNext();) {\r\n        resultBuffer.append(((GameImpl.GameStatus) (iter.next())).getPly().toString());\r\n        resultBuffer.append(\"\n\");\r\n    }\r\n    return resultBuffer.toString();\r\n}"},
 {"id":387, "name":"undoLastPly()", "fullmethod":"de.java_chess.javaChess.game.GameImpl.undoLastPly()", "ownerclassid":"52", "ownerclassname":"GameImpl", "sourcecode":"/**\r\n * Undo the last ply.\r\n */\r\npublic final void undoLastPly() {\r\n    // Remove the last ply\r\n    _gameStatus.pop();\r\n}"},
 {"id":388, "name":"-init-(de.java_chess.javaChess.ply.Ply,long)", "fullmethod":"de.java_chess.javaChess.null.-init-(de.java_chess.javaChess.ply.Ply,long)", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this game status.\r\n * @param bitmask\r\n * \t\tThe moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}"},
 {"id":389, "name":"-init-(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.null.-init-(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * \t\tThe first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}"},
 {"id":390, "name":"-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "fullmethod":"de.java_chess.javaChess.null.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * \t\tThe previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}"},
 {"id":391, "name":"getMovedPieces()", "fullmethod":"de.java_chess.javaChess.game.GameImpl$GameStatus.getMovedPieces()", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"/**\r\n * Get the bitmask for the moved pieces.\r\n *\r\n * @return The bitmask for the moved pieces.\r\n */\r\nprivate final long getMovedPieces() {\r\n    return _movedPieces;\r\n}"},
 {"id":392, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.game.GameImpl$GameStatus.getPly()", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"// Methods\r\n/**\r\n * Get the ply, that lead to this game status.\r\n *\r\n * @return The ply, that lead to this game status.\r\n */\r\nfinal Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":393, "name":"hasBeenMoved(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}"},
 {"id":394, "name":"setMoved(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.game.GameImpl$GameStatus.setMoved(de.java_chess.javaChess.position.Position)", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"/**\r\n * Mark a piece moved from its initial position.\r\n *\r\n * @param position\r\n * \t\tThe position of the moved piece.\r\n */\r\nprivate final void setMoved(Position position) {\r\n    _movedPieces |= 1L << (position.getSquareIndex());\r\n}"},
 {"id":395, "name":"setMovedPieces(long)", "fullmethod":"de.java_chess.javaChess.game.GameImpl$GameStatus.setMovedPieces(long)", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"/**\r\n * Set the bitmask for the moved pieces.\r\n *\r\n * @param bitmask\r\n * \t\tThe new bitmask for the moved pieces.\r\n */\r\nprivate final void setMovedPieces(long bitmask) {\r\n    _movedPieces = bitmask;\r\n}"},
 {"id":396, "name":"setPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.game.GameImpl$GameStatus.setPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"null", "ownerclassname":"null", "sourcecode":"/**\r\n * Set the ply, that lead to this game status.\r\n *\r\n * @param ply\r\n * \t\tThe ply, that lead to this game status.\r\n */\r\nfinal void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":397, "name":"engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "fullmethod":"de.java_chess.javaChess.listener.EngineStatusListener.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)", "ownerclassid":"53", "ownerclassname":"EngineStatusListener", "sourcecode":"public void engineStatusChanged(ChessEngineImpl engine);"},
 {"id":398, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.EditMenu.-init-()", "ownerclassid":"54", "ownerclassname":"EditMenu", "sourcecode":"/**\r\n * Standardconstructor\r\n */\r\npublic EditMenu() {\r\n    this.notationPanel = null;\r\n}"},
 {"id":399, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.menu.EditMenu.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"54", "ownerclassname":"EditMenu", "sourcecode":"/**\r\n * Interface method. Currently displays input dialogs to edit white and black player\r\n * names\r\n *\r\n * @param e\r\n * \t\tThe action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jmiEditPosition)) {\r\n        SetupBoardDialog setupBoardDialog = new SetupBoardDialog();\r\n        Tools.setDialogToCenter(setupBoardDialog);\r\n        setupBoardDialog.setModal(true);\r\n        setupBoardDialog.show();\r\n    } else {\r\n        if ((notationPanel) != null) {\r\n            PlayerDialog playerDialog = null;\r\n            boolean bWhiteOrBlack = true;\r\n            if (e.getSource().equals(jmiWhitePlayerName)) {\r\n                playerDialog = new PlayerDialog(1, notationPanel.getWhitePlayerName());\r\n                bWhiteOrBlack = true;\r\n            } else\r\n                if (e.getSource().equals(jmiBlackPlayerName)) {\r\n                    playerDialog = new PlayerDialog(2, notationPanel.getBlackPlayerName());\r\n                    bWhiteOrBlack = false;\r\n                }\r\n\r\n            if (playerDialog != null) {\r\n                Tools.setDialogToCenter(playerDialog);\r\n                playerDialog.show();\r\n                String sNewName = playerDialog.getNewName();\r\n                if (bWhiteOrBlack == true) {\r\n                    notationPanel.setWhitePlayerName(sNewName);\r\n                } else {\r\n                    notationPanel.setBlackPlayerName(sNewName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"},
 {"id":400, "name":"getMenu()", "fullmethod":"de.java_chess.javaChess.menu.EditMenu.getMenu()", "ownerclassid":"54", "ownerclassname":"EditMenu", "sourcecode":"/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu jmEditMenu = new JMenu(\"Edit\");\r\n    // Add menu items\r\n    jmiBlackPlayerName.setText(\"Black player name\");\r\n    jmiWhitePlayerName.setText(\"White player name\");\r\n    jmiEditPosition.setText(\"Edit/Setup position\");\r\n    jmiEditPosition.setMnemonic(S);\r\n    jmiBlackPlayerName.addActionListener(this);\r\n    jmiWhitePlayerName.addActionListener(this);\r\n    jmiEditPosition.addActionListener(this);\r\n    jmEditMenu.add(jmiWhitePlayerName);\r\n    jmEditMenu.add(jmiBlackPlayerName);\r\n    jmEditMenu.addSeparator();\r\n    jmEditMenu.add(jmiEditPosition);\r\n    jmEditMenu.setMnemonic(KeyEvent.VK_E);\r\n    return jmEditMenu;\r\n}"},
 {"id":401, "name":"setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "fullmethod":"de.java_chess.javaChess.menu.EditMenu.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "ownerclassid":"54", "ownerclassname":"EditMenu", "sourcecode":"/**\r\n * Sets the NotationPanel to be able to perform some actions there\r\n *\r\n * @param panel\r\n * \t\tThe NotationPanel object\r\n */\r\npublic final void setNotationPanel(NotationPanel panel) {\r\n    this.notationPanel = panel;\r\n}"},
 {"id":402, "name":"addPly(de.java_chess.javaChess.notation.PlyNotation)", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.addPly(de.java_chess.javaChess.notation.PlyNotation)", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * \t\tThe notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation);"},
 {"id":403, "name":"getMove(int,boolean)", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.getMove(int,boolean)", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * \t\tThe index of the move.\r\n * @param boolean\r\n * \t\twhite Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\nString getMove(int moveIndex, boolean white);"},
 {"id":404, "name":"getOpeningInfo()", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.getOpeningInfo()", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Get the info on the used opening.\r\n *\r\n * @return The name of the used opening.\r\n */\r\nString getOpeningInfo();"},
 {"id":405, "name":"getPGNheader()", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.getPGNheader()", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Get some extended PGN compatible info on the game.\r\n *\r\n * @return Extended PGN compatible info on the game.\r\n */\r\nString getPGNheader();"},
 {"id":406, "name":"getPlayerInfo(boolean)", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.getPlayerInfo(boolean)", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\nString getPlayerInfo(boolean white);"},
 {"id":407, "name":"getPlyNotation(int)", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.getPlyNotation(int)", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * \t\tThe index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index);"},
 {"id":408, "name":"reset()", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.reset()", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"// Methods\r\n/**\r\n * Reset the game notation for a new game.\r\n */\r\npublic void reset();"},
 {"id":409, "name":"setOpeningInfo(java.lang.String)", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.setOpeningInfo(java.lang.String)", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * \t\tThe name of the opening.\r\n */\r\nvoid setOpeningInfo(String name);"},
 {"id":410, "name":"setPlayerInfo(java.lang.String,boolean)", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.setPlayerInfo(java.lang.String,boolean)", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * \t\tThe player info.\r\n * @param white\r\n * \t\tFlag to indicate, if its the player\r\n * \t\twith the white pieces.\r\n */\r\nvoid setPlayerInfo(String playerInfo, boolean white);"},
 {"id":411, "name":"size()", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.size()", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Get the number of plies in this notation.\r\n *\r\n * @return The number of plies.\r\n */\r\npublic int size();"},
 {"id":412, "name":"toString()", "fullmethod":"de.java_chess.javaChess.notation.GameNotation.toString()", "ownerclassid":"55", "ownerclassname":"GameNotation", "sourcecode":"/**\r\n * Get the entire game as a string.\r\n *\r\n * @return The entire game as a string.\r\n */\r\nString toString();"},
 {"id":413, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.GameNotationImpl.-init-()", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new game notation instance.\r\n */\r\npublic GameNotationImpl() {\r\n    _plies = new ArrayList();\r\n    _notation = new StringBuffer();\r\n}"},
 {"id":414, "name":"addPly(de.java_chess.javaChess.notation.PlyNotation)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.addPly(de.java_chess.javaChess.notation.PlyNotation)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * \t\tThe notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation) {\r\n    _plies.add(plyNotation);\r\n    int nPlies = _plies.size();// Get the number of plies.\r\n\r\n    if ((nPlies & 1) != 0) {\r\n        if (nPlies > 1) {\r\n            // Start a new line\r\n            _notation.append(\"\n\");\r\n        }\r\n        _notation.append(((\"\" + ((nPlies >> 1) + 1)) + \". \"));\r\n    } else {\r\n        _notation.append(\" \");\r\n    }\r\n    _notation.append(plyNotation.toString());\r\n    // If theres a panel, display the current notation.\r\n    if (null != (getNotationPanel())) {\r\n        getNotationPanel().setText(toString());\r\n    }\r\n}"},
 {"id":415, "name":"getMove(int,boolean)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * \t\tThe index of the move.\r\n * @param boolean\r\n * \t\twhite Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}"},
 {"id":416, "name":"getNotationPanel()", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.getNotationPanel()", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get the panel for the output.\r\n *\r\n * @return The panel for the output.\r\n */\r\npublic final NotationPanel getNotationPanel() {\r\n    return _notationPanel;\r\n}"},
 {"id":417, "name":"getOpeningInfo()", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.getOpeningInfo()", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get the info on the used opening.\r\n *\r\n * @return The name of the used opening.\r\n */\r\npublic final String getOpeningInfo() {\r\n    return _openingName;\r\n}"},
 {"id":418, "name":"getPGNheader()", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.getPGNheader()", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get some extended PGN compatible info on the game.\r\n *\r\n * @return Extended PGN compatible info on the game.\r\n */\r\npublic final String getPGNheader() {\r\n    // Create a buffer for the result.\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Add a empty event to the header\r\n    resultBuffer.append(\"[Event \"?\"]\n\");\r\n    // Info on the site\r\n    resultBuffer.append(\"[Site \"?\"]\n\");\r\n    // Add the current date to the header\r\n    resultBuffer.append(\"[Date \"\").append(new SimpleDateFormat(\"yyyy.MM.dd\").format(new Date())).append(\"\"]\n\");\r\n    // Add the round to the header\r\n    resultBuffer.append(\"[Round \"?\"]\n\");\r\n    // Add the name of the white player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(true)))) {\r\n        resultBuffer.append(\"[White \"\").append(getPlayerInfo(true)).append(\"\"]\n\");\r\n    }\r\n    // Add the name of the black player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(false)))) {\r\n        resultBuffer.append(\"[Black \"\").append(getPlayerInfo(false)).append(\"\"]\n\");\r\n    }\r\n    // Info on the result\r\n    resultBuffer.append(\"[Result \"?\"]\n\");\r\n    // Convert the header to a String and return it.\r\n    return resultBuffer.toString();\r\n}"},
 {"id":419, "name":"getPlayerInfo(boolean)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.getPlayerInfo(boolean)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\npublic final String getPlayerInfo(boolean white) {\r\n    return _playerInfo[(white ? 1 : 0)];\r\n}"},
 {"id":420, "name":"getPly(int)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.getPly(int)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get the ply with the given index.\r\n *\r\n * @param plyIndex\r\n * \t\tThe index of the ply.\r\n * @return The notation for the ply as a string.\r\n */\r\nprivate final String getPly(int plyIndex) {\r\n    return _plies.get(plyIndex).toString();\r\n}"},
 {"id":421, "name":"getPlyNotation(int)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * \t\tThe index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}"},
 {"id":422, "name":"reset()", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.reset()", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"// Methods\r\n/**\r\n * Reset the game notation for a new game.\r\n */\r\npublic void reset() {\r\n    _plies.clear();\r\n    // Remove all the plies.\r\n    _notation = new StringBuffer();// Remove the text.\r\n\r\n    // Remove the text from the panel.\r\n    getNotationPanel().setText(\"\");\r\n    // Remove the player info.\r\n    setPlayerInfo(null, true);\r\n    setPlayerInfo(null, false);\r\n    // Remove the opening name.\r\n    setOpeningInfo(null);\r\n}"},
 {"id":423, "name":"setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Set the panel for the notation output.\r\n *\r\n * @param notationPanel\r\n * \t\tThe panel for the output.\r\n */\r\npublic final void setNotationPanel(NotationPanel notationPanel) {\r\n    _notationPanel = notationPanel;\r\n}"},
 {"id":424, "name":"setOpeningInfo(java.lang.String)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.setOpeningInfo(java.lang.String)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * \t\tThe name of the opening.\r\n */\r\npublic final void setOpeningInfo(String name) {\r\n    _openingName = name;\r\n}"},
 {"id":425, "name":"setPlayerInfo(java.lang.String,boolean)", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.setPlayerInfo(java.lang.String,boolean)", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * \t\tThe player info.\r\n * @param white\r\n * \t\tFlag to indicate, if its the player\r\n * \t\twith the white pieces.\r\n */\r\npublic final void setPlayerInfo(String playerInfo, boolean white) {\r\n    _playerInfo[(white ? 1 : 0)] = playerInfo;\r\n}"},
 {"id":426, "name":"size()", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.size()", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get the number of plies in this notation.\r\n *\r\n * @return The number of plies.\r\n */\r\npublic int size() {\r\n    return _plies.size();\r\n}"},
 {"id":427, "name":"toString()", "fullmethod":"de.java_chess.javaChess.notation.GameNotationImpl.toString()", "ownerclassid":"56", "ownerclassname":"GameNotationImpl", "sourcecode":"/**\r\n * Get the entire game as a string.\r\n *\r\n * @return The entire game as a string.\r\n */\r\npublic final String toString() {\r\n    return _notation.toString();\r\n}"},
 {"id":428, "name":"getPiece()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.getPiece()", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Get the piece of this ply.\r\n *\r\n * @return The piece, that is moved with this ply.\r\n */\r\nPiece getPiece();"},
 {"id":429, "name":"getPieceTypeNotation(byte)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.getPieceTypeNotation(byte)", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Get the notation for a piece type.\r\n *\r\n * @param pieceType\r\n * \t\tThe piece type.\r\n * @return The notation for a piece type.\r\n */\r\nString getPieceTypeNotation(byte pieceType);"},
 {"id":430, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.getPly()", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Get the ply of this notation.\r\n *\r\n * @return The ply for this notation.\r\n */\r\nPly getPly();"},
 {"id":431, "name":"isCapture()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.isCapture()", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Check if the piece captures another piece with this ply.\r\n *\r\n * @return true, if another piece is captureed with this ply.\r\n */\r\nboolean isCapture();"},
 {"id":432, "name":"isCheck()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.isCheck()", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Get the flag for a check.\r\n *\r\n * @return true, if the opponent is in check.\r\n */\r\nboolean isCheck();"},
 {"id":433, "name":"isCheckMate()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.isCheckMate()", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Get the flag for a checkmate.\r\n *\r\n * @return true, if the opponent is checkmate.\r\n */\r\nboolean isCheckMate();"},
 {"id":434, "name":"setCheck(boolean)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.setCheck(boolean)", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is in check.\r\n */\r\nvoid setCheck(boolean check);"},
 {"id":435, "name":"setCheckMate(boolean)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.setCheckMate(boolean)", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is checkmate.\r\n */\r\nvoid setCheckMate(boolean checkMate);"},
 {"id":436, "name":"setPiece(de.java_chess.javaChess.piece.Piece)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.setPiece(de.java_chess.javaChess.piece.Piece)", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * \t\tThe moved ply.\r\n */\r\nvoid setPiece(Piece piece);"},
 {"id":437, "name":"setPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.setPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this notation.\r\n */\r\nvoid setPly(Ply ply);"},
 {"id":438, "name":"toString()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotation.toString()", "ownerclassid":"57", "ownerclassname":"PlyNotation", "sourcecode":"// Methods\r\n/**\r\n * Render this ply as a string.\r\n *\r\n * @return The notated ply as a string.\r\n */\r\nString toString();"},
 {"id":439, "name":"-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)", "fullmethod":"de.java_chess.javaChess.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n * @param piece\r\n * \t\tThe moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}"},
 {"id":440, "name":"computeStringRepresentation()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.computeStringRepresentation()", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Render this ply as a string.\r\n */\r\nprivate final void computeStringRepresentation() {\r\n    StringBuffer notation = new StringBuffer();\r\n    if (!((getPly()) instanceof CastlingPly)) {\r\n        // Start with the type of the piece, if it is not a pawn.\r\n        if ((getPiece().getType()) != (Piece.PAWN)) {\r\n            notation.append(getPieceTypeNotation(getPiece().getType()));\r\n        }\r\n        // Get this ply as a string.\r\n        String plyString = getPly().toString();\r\n        // If its a capture, indicate it with an x\r\n        notation.append((isCapture() ? plyString.replace(-, x) : plyString));\r\n        // If its a pawn transforming to a new piece type, append the new type.\r\n        if ((getPly()) instanceof TransformationPly) {\r\n            notation.append(\"=\");\r\n            notation.append(getPieceTypeNotation(((TransformationPly) (getPly())).getTypeAfterTransformation()));\r\n        }\r\n    } else {\r\n        notation.append(getPly().toString());\r\n    }\r\n    // Add the check(-mate) signs.\r\n    if (isCheckMate()) {\r\n        notation.append(#);\r\n    } else {\r\n        if (isCheck()) {\r\n            notation.append(+);\r\n        }\r\n    }\r\n    // Convert the buffer to a string and store it.\r\n    _stringRepresentation = notation.toString();\r\n}"},
 {"id":441, "name":"getPiece()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.getPiece()", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Get the piece of this ply.\r\n *\r\n * @return The piece, that is moved with this ply.\r\n */\r\npublic final Piece getPiece() {\r\n    return _piece;\r\n}"},
 {"id":442, "name":"getPieceTypeNotation(byte)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.getPieceTypeNotation(byte)", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Get the notation for a piece type.\r\n *\r\n * @return The notation for a piece type.\r\n */\r\npublic final String getPieceTypeNotation(byte pieceType) {\r\n    String notation = \"\";// The result;\r\n\r\n    // Convert the piece type to a string.\r\n    switch (pieceType) {\r\n        case Piece.PAWN :\r\n            notation = \"P\";\r\n            break;\r\n        case Piece.KNIGHT :\r\n            notation = \"N\";\r\n            break;\r\n        case Piece.BISHOP :\r\n            notation = \"B\";\r\n            break;\r\n        case Piece.ROOK :\r\n            notation = \"R\";\r\n            break;\r\n        case Piece.QUEEN :\r\n            notation = \"Q\";\r\n            break;\r\n        case Piece.KING :\r\n            notation = \"K\";\r\n            break;\r\n    }\r\n    return notation;\r\n}"},
 {"id":443, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.getPly()", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Get the ply of this notation.\r\n *\r\n * @return The ply for this notation.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":444, "name":"isCapture()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.isCapture()", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Check if the piece captures another piece with this ply.\r\n *\r\n * @return true, if another piece is captureed with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return getPly().isCapture();\r\n}"},
 {"id":445, "name":"isCheck()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.isCheck()", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Get the flag for a check.\r\n *\r\n * @return true, if the opponent is in check.\r\n */\r\npublic final boolean isCheck() {\r\n    return _check;\r\n}"},
 {"id":446, "name":"isCheckMate()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.isCheckMate()", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Get the flag for a checkmate.\r\n *\r\n * @return true, if the opponent is checkmate.\r\n */\r\npublic final boolean isCheckMate() {\r\n    return _checkMate;\r\n}"},
 {"id":447, "name":"setCheck(boolean)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.setCheck(boolean)", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is in check.\r\n */\r\npublic final void setCheck(boolean check) {\r\n    _check = check;\r\n    // If we are not in check, we are also no checkmate.\r\n    if (check == false) {\r\n        setCheckMate(false);\r\n    }\r\n    // Recompute the string representation to make sure, that\r\n    // it is still correct.\r\n    computeStringRepresentation();\r\n}"},
 {"id":448, "name":"setCheckMate(boolean)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.setCheckMate(boolean)", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * \t\ttrue if the oppenent is checkmate.\r\n */\r\npublic final void setCheckMate(boolean checkMate) {\r\n    _checkMate = checkMate;\r\n    // If the opponent is checkmate, he is also in check.\r\n    if (checkMate == true) {\r\n        setCheck(true);\r\n    }\r\n}"},
 {"id":449, "name":"setPiece(de.java_chess.javaChess.piece.Piece)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.setPiece(de.java_chess.javaChess.piece.Piece)", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * \t\tThe moved ply.\r\n */\r\npublic final void setPiece(Piece piece) {\r\n    _piece = piece;\r\n}"},
 {"id":450, "name":"setPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.setPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * \t\tThe ply for this notation.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":451, "name":"toString()", "fullmethod":"de.java_chess.javaChess.notation.PlyNotationImpl.toString()", "ownerclassid":"58", "ownerclassname":"PlyNotationImpl", "sourcecode":"// Methods\r\n/**\r\n * Render this notation as a string.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic String toString() {\r\n    return _stringRepresentation;\r\n}"},
 {"id":452, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.GameLoader.-init-()", "ownerclassid":"59", "ownerclassname":"GameLoader", "sourcecode":"// Constructors\r\n/**\r\n * Create a new game loader instance.\r\n */\r\npublic GameLoader() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(10));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n}"},
 {"id":453, "name":"completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "fullmethod":"de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)", "ownerclassid":"59", "ownerclassname":"GameLoader", "sourcecode":"// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * \t\tThe info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}"},
 {"id":454, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.pgn.GameLoader.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"59", "ownerclassname":"GameLoader", "sourcecode":"/**\r\n * Perform a ply, when it is completely loaded.\r\n *\r\n * param ply The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n    // The other color is about to move now.\r\n    _whiteMoves = !(_whiteMoves);\r\n}"},
 {"id":455, "name":"-init-(java.io.Reader)", "fullmethod":"de.java_chess.javaChess.PGNFile.-init-(java.io.Reader)", "ownerclassid":"60", "ownerclassname":"PGNFile", "sourcecode":"// Constructors\r\n/**\r\n * Create a new instance.\r\n *\r\n * @param reader\r\n * \t\tThe reader for the file.\r\n */\r\npublic PGNFile(Reader reader) {\r\n    setReader(reader);\r\n}"},
 {"id":456, "name":"getPGNParser()", "fullmethod":"de.java_chess.javaChess.pgn.PGNFile.getPGNParser()", "ownerclassid":"60", "ownerclassname":"PGNFile", "sourcecode":"/**\r\n * Get the current parser, if theres already one, or\r\n * create a new parser and return it.\r\n *\r\n * @return The current PGN parser.\r\n */\r\nprivate final PGNParser getPGNParser() {\r\n    if ((_parser) == null) {\r\n        // If there is no parser yet, create one.\r\n        _parser = new PGNParser(new PGNLexer(getReader()));\r\n    }\r\n    return _parser;// And return it.\r\n\r\n}"},
 {"id":457, "name":"getReader()", "fullmethod":"de.java_chess.javaChess.pgn.PGNFile.getReader()", "ownerclassid":"60", "ownerclassname":"PGNFile", "sourcecode":"/**\r\n * Get the reader for the current file.\r\n *\r\n * @return The current reader.\r\n */\r\nprivate final Reader getReader() {\r\n    return _reader;\r\n}"},
 {"id":458, "name":"readGame()", "fullmethod":"de.java_chess.javaChess.pgn.PGNFile.readGame()", "ownerclassid":"60", "ownerclassname":"PGNFile", "sourcecode":"// Methods\r\n/**\r\n * Read one game from the current file.\r\n *\r\n * @return The notation of the game.\r\n * @throws RecognitionException\r\n * \t\tIf a parser problem occured.\r\n * @throws TokenStreamException\r\n * \t\tIf a scanner problem occured.\r\n */\r\npublic final GameNotation readGame() throws RecognitionException, TokenStreamException {\r\n    // A buffer for the result.\r\n    GameNotation notationBuffer = new GameNotationImpl();\r\n    // Start the parsing of the file.\r\n    getPGNParser().pgnGame(notationBuffer);\r\n    return notationBuffer;\r\n}"},
 {"id":459, "name":"setPGNParser(de.java_chess.javaChess.pgn.PGNParser)", "fullmethod":"de.java_chess.javaChess.pgn.PGNFile.setPGNParser(de.java_chess.javaChess.pgn.PGNParser)", "ownerclassid":"60", "ownerclassname":"PGNFile", "sourcecode":"/**\r\n * Set the current parser.\r\n *\r\n * @param parser\r\n * \t\tThe new PGN parser.\r\n */\r\nprivate final void setPGNParser(PGNParser parser) {\r\n    _parser = parser;\r\n}"},
 {"id":460, "name":"setReader(java.io.Reader)", "fullmethod":"de.java_chess.javaChess.pgn.PGNFile.setReader(java.io.Reader)", "ownerclassid":"60", "ownerclassname":"PGNFile", "sourcecode":"/**\r\n * Set a new reader for a file.\r\n *\r\n * @param reader\r\n * \t\tThe new reader.\r\n */\r\nprivate final void setReader(Reader reader) {\r\n    _reader = reader;\r\n}"},
 {"id":461, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PGNFileFilter.-init-()", "ownerclassid":"61", "ownerclassname":"PGNFileFilter", "sourcecode":"PGNFileFilter() {\r\n}"},
 {"id":462, "name":"accept(java.io.File)", "fullmethod":"de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)", "ownerclassid":"61", "ownerclassname":"PGNFileFilter", "sourcecode":"// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * \t\tThe file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}"},
 {"id":463, "name":"getDescription()", "fullmethod":"de.java_chess.javaChess.pgn.PGNFileFilter.getDescription()", "ownerclassid":"61", "ownerclassname":"PGNFileFilter", "sourcecode":"/**\r\n * Get a description of this file filter.\r\n *\r\n * @return A description of this file filter.\r\n */\r\npublic String getDescription() {\r\n    return \"PGN - Portable Game Notation format\";\r\n}"},
 {"id":464, "name":"-init-(java.io.InputStream)", "fullmethod":"de.java_chess.javaChess.PGNLexer.-init-(java.io.InputStream)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public PGNLexer(InputStream in) {\r\n    this(new ByteBuffer(in));\r\n}"},
 {"id":465, "name":"-init-(java.io.Reader)", "fullmethod":"de.java_chess.javaChess.PGNLexer.-init-(java.io.Reader)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public PGNLexer(Reader in) {\r\n    this(new CharBuffer(in));\r\n}"},
 {"id":466, "name":"-init-(antlr.InputBuffer)", "fullmethod":"de.java_chess.javaChess.PGNLexer.-init-(antlr.InputBuffer)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public PGNLexer(InputBuffer ib) {\r\n    this(new antlr.LexerSharedInputState(ib));\r\n}"},
 {"id":467, "name":"-init-(antlr.LexerSharedInputState)", "fullmethod":"de.java_chess.javaChess.PGNLexer.-init-(antlr.LexerSharedInputState)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public PGNLexer(LexerSharedInputState state) {\r\n    super(state);\r\n    literals = new Hashtable();\r\n    caseSensitiveLiterals = true;\r\n    setCaseSensitive(true);\r\n}"},
 {"id":468, "name":"mDOT(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mDOT(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mDOT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.DOT;\r\n    int _saveIndex;\r\n    match(.);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":469, "name":"mFIGURINE_LETTER_CODE(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mFIGURINE_LETTER_CODE(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mFIGURINE_LETTER_CODE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.FIGURINE_LETTER_CODE;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case P :\r\n                {\r\n                    match(P);\r\n                    break;\r\n                }\r\n            case N :\r\n                {\r\n                    match(N);\r\n                    break;\r\n                }\r\n            case B :\r\n                {\r\n                    match(B);\r\n                    break;\r\n                }\r\n            case R :\r\n                {\r\n                    match(R);\r\n                    break;\r\n                }\r\n            case Q :\r\n                {\r\n                    match(Q);\r\n                    break;\r\n                }\r\n            case K :\r\n                {\r\n                    match(K);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":470, "name":"mGAME_TERMINATOR(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mGAME_TERMINATOR(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mGAME_TERMINATOR(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.GAME_TERMINATOR;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case * :\r\n                {\r\n                    match(\"*\");\r\n                    break;\r\n                }\r\n            case 0 :\r\n                {\r\n                    match(\"0-1\");\r\n                    break;\r\n                }\r\n            default :\r\n                if (((LA(1)) == 1) && ((LA(2)) == -)) {\r\n                    match(\"1-0\");\r\n                } else\r\n                    if (((LA(1)) == 1) && ((LA(2)) == /)) {\r\n                        match(\"1/2-1/2\");\r\n                    } else {\r\n                        throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                    }\r\n\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":471, "name":"mLBRACK(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mLBRACK(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mLBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.LBRACK;\r\n    int _saveIndex;\r\n    match([);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":472, "name":"mMOVE_INDEX(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mMOVE_INDEX(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mMOVE_INDEX(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.MOVE_INDEX;\r\n    int _saveIndex;\r\n    {\r\n        matchRange(1, 9);\r\n        {\r\n            _loop57 : do {\r\n                if (((LA(1)) >= 0) && ((LA(1)) <= 9)) {\r\n                    matchRange(0, 9);\r\n                } else {\r\n                    break _loop57;\r\n                }\r\n            } while (true );\r\n        }\r\n        mDOT(false);\r\n    }\r\n    // Remove the trailing dot.\r\n    String index = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    index = index.substring(0, ((index.length()) - 1));\r\n    text.setLength(_begin);\r\n    text.append(index);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":473, "name":"mPAWN_PROMOTION(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mPAWN_PROMOTION(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mPAWN_PROMOTION(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PAWN_PROMOTION;\r\n    int _saveIndex;\r\n    match(=);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":474, "name":"mPIECE_CAPTURE(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mPIECE_CAPTURE(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mPIECE_CAPTURE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_CAPTURE;\r\n    int _saveIndex;\r\n    match(x);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":475, "name":"mPIECE_MOVE(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mPIECE_MOVE(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mPIECE_MOVE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_MOVE;\r\n    int _saveIndex;\r\n    match(-);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":476, "name":"mRBRACK(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mRBRACK(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mRBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RBRACK;\r\n    int _saveIndex;\r\n    match(]);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":477, "name":"mRIGHT_CASTLING(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mRIGHT_CASTLING(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mRIGHT_CASTLING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RIGHT_CASTLING;\r\n    int _saveIndex;\r\n    match(\"O-O\");\r\n    {\r\n        if ((LA(1)) == -) {\r\n            match(\"-O\");\r\n            _ttype = PGNTokenTypes.LEFT_CASTLING;\r\n        } else {\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":478, "name":"mSL_COMMENT(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mSL_COMMENT(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mSL_COMMENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SL_COMMENT;\r\n    int _saveIndex;\r\n    match(\";\");\r\n    {\r\n        _loop39 : do {\r\n            if (PGNLexer._tokenSet_2.member(LA(1))) {\r\n                {\r\n                    match(PGNLexer._tokenSet_2);\r\n                }\r\n            } else {\r\n                break _loop39;\r\n            }\r\n        } while (true );\r\n    }\r\n    {\r\n        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n            match(\"\r\n\");\r\n        } else\r\n            if ((LA(1)) == \n) {\r\n                match(\"\n\");\r\n            } else\r\n                if (((LA(1)) == \r) && true) {\r\n                    match(\"\r\");\r\n                } else {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n\r\n\r\n    }\r\n    _ttype = Token.SKIP;\r\n    newline();\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":479, "name":"mSQUARE_NAME(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mSQUARE_NAME(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mSQUARE_NAME(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SQUARE_NAME;\r\n    int _saveIndex;\r\n    matchRange(a, h);\r\n    matchRange(1, 8);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":480, "name":"mSTRING_LITERAL(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mSTRING_LITERAL(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mSTRING_LITERAL(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.STRING_LITERAL;\r\n    int _saveIndex;\r\n    {\r\n        match(\");\r\n        {\r\n            _loop45 : do {\r\n                if (PGNLexer._tokenSet_3.member(LA(1))) {\r\n                    {\r\n                        match(PGNLexer._tokenSet_3);\r\n                    }\r\n                } else {\r\n                    break _loop45;\r\n                }\r\n            } while (true );\r\n        }\r\n        match(\");\r\n    }\r\n    // Remove the leadind and trailing quote.\r\n    String literal = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    literal = ((literal.length()) == 2) ? \"\" : literal.substring(1, ((literal.length()) - 2));\r\n    text.setLength(_begin);\r\n    text.append(literal);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":481, "name":"mTAG_BLACK(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_BLACK(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_BLACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_BLACK;\r\n    int _saveIndex;\r\n    match(\"Black\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":482, "name":"mTAG_DATE(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_DATE(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_DATE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_DATE;\r\n    int _saveIndex;\r\n    match(\"Date\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":483, "name":"mTAG_EVENT(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_EVENT(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_EVENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_EVENT;\r\n    int _saveIndex;\r\n    match(\"Event\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":484, "name":"mTAG_OPENING(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_OPENING(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_OPENING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_OPENING;\r\n    int _saveIndex;\r\n    match(\"Opening\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":485, "name":"mTAG_RESULT(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_RESULT(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_RESULT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_RESULT;\r\n    int _saveIndex;\r\n    match(\"Result\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":486, "name":"mTAG_ROUND(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_ROUND(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_ROUND(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_ROUND;\r\n    int _saveIndex;\r\n    match(\"Round\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":487, "name":"mTAG_SITE(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_SITE(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_SITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_SITE;\r\n    int _saveIndex;\r\n    match(\"Site\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":488, "name":"mTAG_WHITE(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mTAG_WHITE(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mTAG_WHITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_WHITE;\r\n    int _saveIndex;\r\n    match(\"White\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":489, "name":"mWS(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.mWS(boolean)", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public final void mWS(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.WS;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case   :\r\n                {\r\n                    match( );\r\n                    break;\r\n                }\r\n            case \t :\r\n                {\r\n                    match(\t);\r\n                    break;\r\n                }\r\n            case f :\r\n                {\r\n                    match(f);\r\n                    break;\r\n                }\r\n            case \n :\r\n            case \r :\r\n                {\r\n                    {\r\n                        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n                            match(\"\r\n\");\r\n                        } else\r\n                            if (((LA(1)) == \r) && true) {\r\n                                match(\r);\r\n                            } else\r\n                                if ((LA(1)) == \n) {\r\n                                    match(\n);\r\n                                } else {\r\n                                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                                }\r\n\r\n\r\n                    }\r\n                    newline();\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    /* $setType(Token.SKIP); */\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}"},
 {"id":490, "name":"nextToken()", "fullmethod":"de.java_chess.javaChess.pgn.PGNLexer.nextToken()", "ownerclassid":"62", "ownerclassname":"PGNLexer", "sourcecode":"public Token nextToken() throws TokenStreamException {\r\n    Token theRetToken = null;\r\n    tryAgain : for (; ;) {\r\n        Token _token = null;\r\n        int _ttype = Token.INVALID_TYPE;\r\n        resetText();\r\n        try {\r\n            // for char stream error handling\r\n            try {\r\n                // for lexical error handling\r\n                switch (LA(1)) {\r\n                    case \t :\r\n                    case \n :\r\n                    case f :\r\n                    case \r :\r\n                    case   :\r\n                        {\r\n                            mWS(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case . :\r\n                        {\r\n                            mDOT(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case [ :\r\n                        {\r\n                            mLBRACK(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case ] :\r\n                        {\r\n                            mRBRACK(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case ; :\r\n                        {\r\n                            mSL_COMMENT(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case \" :\r\n                        {\r\n                            mSTRING_LITERAL(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case a :\r\n                    case b :\r\n                    case c :\r\n                    case d :\r\n                    case e :\r\n                    case f :\r\n                    case g :\r\n                    case h :\r\n                        {\r\n                            mSQUARE_NAME(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case - :\r\n                        {\r\n                            mPIECE_MOVE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case x :\r\n                        {\r\n                            mPIECE_CAPTURE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case = :\r\n                        {\r\n                            mPAWN_PROMOTION(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case W :\r\n                        {\r\n                            mTAG_WHITE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case D :\r\n                        {\r\n                            mTAG_DATE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case E :\r\n                        {\r\n                            mTAG_EVENT(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case S :\r\n                        {\r\n                            mTAG_SITE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    default :\r\n                        if (((LA(1)) == O) && ((LA(2)) == -)) {\r\n                            mRIGHT_CASTLING(true);\r\n                            theRetToken = _returnToken;\r\n                        } else\r\n                            if ((((LA(1)) >= 1) && ((LA(1)) <= 9)) && (PGNLexer._tokenSet_0.member(LA(2)))) {\r\n                                mMOVE_INDEX(true);\r\n                                theRetToken = _returnToken;\r\n                            } else\r\n                                if (((LA(1)) == B) && ((LA(2)) == l)) {\r\n                                    mTAG_BLACK(true);\r\n                                    theRetToken = _returnToken;\r\n                                } else\r\n                                    if (((LA(1)) == R) && ((LA(2)) == o)) {\r\n                                        mTAG_ROUND(true);\r\n                                        theRetToken = _returnToken;\r\n                                    } else\r\n                                        if (((LA(1)) == R) && ((LA(2)) == e)) {\r\n                                            mTAG_RESULT(true);\r\n                                            theRetToken = _returnToken;\r\n                                        } else\r\n                                            if (((LA(1)) == O) && ((LA(2)) == p)) {\r\n                                                mTAG_OPENING(true);\r\n                                                theRetToken = _returnToken;\r\n                                            } else\r\n                                                if ((PGNLexer._tokenSet_1.member(LA(1))) && true) {\r\n                                                    mFIGURINE_LETTER_CODE(true);\r\n                                                    theRetToken = _returnToken;\r\n                                                } else\r\n                                                    if (((((LA(1)) == *) || ((LA(1)) == 0)) || ((LA(1)) == 1)) && true) {\r\n                                                        mGAME_TERMINATOR(true);\r\n                                                        theRetToken = _returnToken;\r\n                                                    } else {\r\n                                                        if ((LA(1)) == (EOF_CHAR)) {\r\n                                                            uponEOF();\r\n                                                            _returnToken = makeToken(Token.EOF_TYPE);\r\n                                                        } else {\r\n                                                            throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                                                        }\r\n                                                    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                }\r\n                if ((_returnToken) == null)\r\n                    continue tryAgain;\r\n                // found SKIP token\r\n\r\n                _ttype = _returnToken.getType();\r\n                _ttype = testLiteralsTable(_ttype);\r\n                _returnToken.setType(_ttype);\r\n                return _returnToken;\r\n            } catch (RecognitionException e) {\r\n                throw new antlr.TokenStreamRecognitionException(e);\r\n            }\r\n        } catch (CharStreamException cse) {\r\n            if (cse instanceof CharStreamIOException) {\r\n                throw new antlr.TokenStreamIOException(((CharStreamIOException) (cse)).io);\r\n            } else {\r\n                throw new TokenStreamException(cse.getMessage());\r\n            }\r\n        }\r\n    }\r\n}"},
 {"id":491, "name":"-init-(java.io.File)", "fullmethod":"de.java_chess.javaChess.PGNOutputStream.-init-(java.io.File)", "ownerclassid":"63", "ownerclassname":"PGNOutputStream", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new PGNOutputStream instance.\r\n *\r\n * @param file\r\n * \t\tThe file to write into.\r\n */\r\npublic PGNOutputStream(File file) throws IOException {\r\n    super(file);\r\n}"},
 {"id":492, "name":"write(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.pgn.PGNOutputStream.write(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"63", "ownerclassname":"PGNOutputStream", "sourcecode":"// Methods\r\n/**\r\n * Write the notation of a game.\r\n *\r\n * @param gameNotation\r\n * \t\tThe notation of the game.\r\n */\r\npublic final void write(GameNotation gameNotation) throws IOException {\r\n    // Check, if there is some header available.\r\n    String header = gameNotation.getPGNheader();\r\n    if (!(\"\".equals(header))) {\r\n        header += \"\n\";\r\n        write(header.getBytes());\r\n    }\r\n    write(gameNotation.toString().getBytes());\r\n}"},
 {"id":493, "name":"-init-(antlr.TokenBuffer,int)", "fullmethod":"de.java_chess.javaChess.PGNParser.-init-(antlr.TokenBuffer,int)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"protected PGNParser(TokenBuffer tokenBuf, int k) {\r\n    super(tokenBuf, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":494, "name":"-init-(antlr.TokenBuffer)", "fullmethod":"de.java_chess.javaChess.PGNParser.-init-(antlr.TokenBuffer)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public PGNParser(TokenBuffer tokenBuf) {\r\n    this(tokenBuf, 2);\r\n}"},
 {"id":495, "name":"-init-(antlr.TokenStream,int)", "fullmethod":"de.java_chess.javaChess.PGNParser.-init-(antlr.TokenStream,int)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"protected PGNParser(TokenStream lexer, int k) {\r\n    super(lexer, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":496, "name":"-init-(antlr.TokenStream)", "fullmethod":"de.java_chess.javaChess.PGNParser.-init-(antlr.TokenStream)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public PGNParser(TokenStream lexer) {\r\n    this(lexer, 2);\r\n}"},
 {"id":497, "name":"-init-(antlr.ParserSharedInputState)", "fullmethod":"de.java_chess.javaChess.PGNParser.-init-(antlr.ParserSharedInputState)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public PGNParser(ParserSharedInputState state) {\r\n    super(state, 2);\r\n    tokenNames = PGNParser._tokenNames;\r\n}"},
 {"id":498, "name":"blackTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.blackTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void blackTag() throws RecognitionException, TokenStreamException {\r\n    Token name = null;\r\n    match(PGNTokenTypes.TAG_BLACK);\r\n    whiteSpaces();\r\n    name = LT(1);\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n    getNotation().setPlayerInfo(name.getText(), false);\r\n}"},
 {"id":499, "name":"dateTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.dateTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void dateTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_DATE);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}"},
 {"id":500, "name":"eventTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.eventTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void eventTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_EVENT);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}"},
 {"id":501, "name":"getGameLoader()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.getGameLoader()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"/**\r\n * Get the current game loader.\r\n *\r\n * @return The current game loader.\r\n */\r\nprivate final GameLoader getGameLoader() {\r\n    return _gameLoader;\r\n}"},
 {"id":502, "name":"getNotation()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.getNotation()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"/**\r\n * Get the current notation.\r\n *\r\n * @return The current notation.\r\n */\r\npublic final GameNotation getNotation() {\r\n    return _notation;\r\n}"},
 {"id":503, "name":"move()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.move()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void move() throws RecognitionException, TokenStreamException {\r\n    Token mI = null;\r\n    PlyNotation notation = null;\r\n    mI = LT(1);\r\n    match(PGNTokenTypes.MOVE_INDEX);\r\n    if (!((++(_moveIndex)) == (Integer.parseInt(mI.getText()))))\r\n        throw new SemanticException(\" ++_moveIndex == Integer.parseInt( mI.getText()) \");\r\n\r\n    whiteSpaces();\r\n    notation = ply();\r\n    getNotation().addPly(notation);\r\n    whiteSpaces();\r\n    notation = ply();\r\n    getNotation().addPly(notation);\r\n    whiteSpaces();\r\n}"},
 {"id":504, "name":"moveTextSection()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.moveTextSection()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void moveTextSection() throws RecognitionException, TokenStreamException {\r\n    _moveIndex = 0;\r\n    {\r\n        _loop17 : do {\r\n            if ((LA(1)) == (PGNTokenTypes.MOVE_INDEX)) {\r\n                move();\r\n            } else {\r\n                break _loop17;\r\n            }\r\n        } while (true );\r\n    }\r\n    match(PGNTokenTypes.GAME_TERMINATOR);\r\n}"},
 {"id":505, "name":"openingTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.openingTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void openingTag() throws RecognitionException, TokenStreamException {\r\n    Token name = null;\r\n    match(PGNTokenTypes.TAG_OPENING);\r\n    whiteSpaces();\r\n    name = LT(1);\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n    getNotation().setOpeningInfo(name.getText());\r\n}"},
 {"id":506, "name":"pgnGame(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.pgnGame(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void pgnGame(GameNotation notationBuffer) throws RecognitionException, TokenStreamException {\r\n    setNotation(notationBuffer);\r\n    setGameLoader(new GameLoader());\r\n    whiteSpaces();\r\n    tagPairSection();\r\n    moveTextSection();\r\n}"},
 {"id":507, "name":"ply()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.ply()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final PlyNotation ply() throws RecognitionException, TokenStreamException {\r\n    PlyNotation notation = null;\r\n    Token lc = null;\r\n    Token snOrg = null;\r\n    Token snDest = null;\r\n    Token lc2 = null;\r\n    PGNPlyFragment plyFragment = new PGNPlyFragment();\r\n    {\r\n        switch (LA(1)) {\r\n            case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n            case PGNTokenTypes.SQUARE_NAME :\r\n            case PGNTokenTypes.PIECE_MOVE :\r\n            case PGNTokenTypes.PIECE_CAPTURE :\r\n                {\r\n                    {\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                    {\r\n                                        lc = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        plyFragment.setPieceTypeFromLetter(lc.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                        {\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.SQUARE_NAME :\r\n                                        {\r\n                                            snOrg = LT(1);\r\n                                            match(PGNTokenTypes.SQUARE_NAME);\r\n                                            plyFragment.setOrigin(snOrg.getText());\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_MOVE);\r\n                                            plyFragment.setCapture(false);\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_CAPTURE);\r\n                                            plyFragment.setCapture(true);\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            snDest = LT(1);\r\n                            match(PGNTokenTypes.SQUARE_NAME);\r\n                            plyFragment.setDestination(snDest.getText());\r\n                        }\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.PAWN_PROMOTION :\r\n                                    {\r\n                                        match(PGNTokenTypes.PAWN_PROMOTION);\r\n                                        lc2 = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        if (!((!(\"P\".equals(lc2.getText()))) && (!(\"K\".equals(lc2.getText())))))\r\n                                            throw new SemanticException(\" ! \"P\".equals( lc2.getText()) && ! \"K\".equals( lc2.getText())\");\r\n\r\n                                        plyFragment.setPawnPromotion(lc2.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.GAME_TERMINATOR :\r\n                                case PGNTokenTypes.MOVE_INDEX :\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                case PGNTokenTypes.LEFT_CASTLING :\r\n                                case PGNTokenTypes.RIGHT_CASTLING :\r\n                                case PGNTokenTypes.WS :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.LEFT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.LEFT_CASTLING);\r\n                    plyFragment.setCastling(true);\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.RIGHT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.RIGHT_CASTLING);\r\n                    plyFragment.setCastling(false);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                }\r\n        }\r\n    }\r\n    // When we have all the info from the PGN file, we can try to\r\n    // create a ply notation from it.\r\n    notation = getGameLoader().completePly(plyFragment);\r\n    if (!(notation != null))\r\n        throw new SemanticException(\"notation != null\");\r\n\r\n    return notation;\r\n}"},
 {"id":508, "name":"resultTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.resultTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void resultTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_RESULT);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}"},
 {"id":509, "name":"roundTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.roundTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void roundTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_ROUND);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}"},
 {"id":510, "name":"setGameLoader(de.java_chess.javaChess.pgn.GameLoader)", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.setGameLoader(de.java_chess.javaChess.pgn.GameLoader)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"/**\r\n * Set a new game loader.\r\n *\r\n * @param loader\r\n * \t\tThe new game loader.\r\n */\r\nprivate final void setGameLoader(GameLoader loader) {\r\n    _gameLoader = loader;\r\n}"},
 {"id":511, "name":"setNotation(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.setNotation(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"/**\r\n * Set a new buffer for the game notation.\r\n *\r\n * @param notation\r\n * \t\tThe new notation buffer.\r\n */\r\npublic final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}"},
 {"id":512, "name":"siteTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.siteTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void siteTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_SITE);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}"},
 {"id":513, "name":"tagPair()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.tagPair()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void tagPair() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.LBRACK);\r\n    whiteSpaces();\r\n    {\r\n        switch (LA(1)) {\r\n            case PGNTokenTypes.TAG_EVENT :\r\n                {\r\n                    eventTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_SITE :\r\n                {\r\n                    siteTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_DATE :\r\n                {\r\n                    dateTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_ROUND :\r\n                {\r\n                    roundTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_WHITE :\r\n                {\r\n                    whiteTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_BLACK :\r\n                {\r\n                    blackTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_RESULT :\r\n                {\r\n                    resultTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_OPENING :\r\n                {\r\n                    openingTag();\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                }\r\n        }\r\n    }\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.RBRACK);\r\n}"},
 {"id":514, "name":"tagPairSection()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.tagPairSection()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void tagPairSection() throws RecognitionException, TokenStreamException {\r\n    {\r\n        _loop4 : do {\r\n            if ((LA(1)) == (PGNTokenTypes.LBRACK)) {\r\n                tagPair();\r\n                whiteSpaces();\r\n            } else {\r\n                break _loop4;\r\n            }\r\n        } while (true );\r\n    }\r\n}"},
 {"id":515, "name":"whiteSpaces()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.whiteSpaces()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void whiteSpaces() throws RecognitionException, TokenStreamException {\r\n    {\r\n        _loop29 : do {\r\n            if ((LA(1)) == (PGNTokenTypes.WS)) {\r\n                match(PGNTokenTypes.WS);\r\n            } else {\r\n                break _loop29;\r\n            }\r\n        } while (true );\r\n    }\r\n}"},
 {"id":516, "name":"whiteTag()", "fullmethod":"de.java_chess.javaChess.pgn.PGNParser.whiteTag()", "ownerclassid":"64", "ownerclassname":"PGNParser", "sourcecode":"public final void whiteTag() throws RecognitionException, TokenStreamException {\r\n    Token name = null;\r\n    match(PGNTokenTypes.TAG_WHITE);\r\n    whiteSpaces();\r\n    name = LT(1);\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n    getNotation().setPlayerInfo(name.getText(), true);\r\n}"},
 {"id":517, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PGNPlyFragment.-init-()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"PGNPlyFragment() {\r\n}"},
 {"id":518, "name":"getDestination()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.getDestination()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Get the current destination of this ply.\r\n *\r\n * @return The currently known destination of this ply.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}"},
 {"id":519, "name":"getNewPieceType()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.getNewPieceType()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Get the new piece type after the pawn promotion.\r\n *\r\n * @return The new piece type after the pawn promotion.\r\n */\r\npublic final byte getNewPieceType() {\r\n    return _newPieceType;\r\n}"},
 {"id":520, "name":"getOrigin()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.getOrigin()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Get the current origin of this ply.\r\n *\r\n * @return The currently known origin of this ply.\r\n */\r\npublic final Position getOrigin() {\r\n    return _origin;\r\n}"},
 {"id":521, "name":"getPieceType()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceType()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Get the type of the moved piece.\r\n *\r\n * @return The type of the moved piece.\r\n */\r\npublic final byte getPieceType() {\r\n    return _pieceType;\r\n}"},
 {"id":522, "name":"getPieceTypeFromLetter(char)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}"},
 {"id":523, "name":"isCapture()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.isCapture()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Check, if this ply fragment is a capture.\r\n *\r\n * @return true, if this move is a capture.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}"},
 {"id":524, "name":"isCastling()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.isCastling()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Check, if this ply fragment is a castling.\r\n *\r\n * @return true, if this ply fragment represents a castling. False otherwise.\r\n */\r\npublic final boolean isCastling() {\r\n    return _castling;\r\n}"},
 {"id":525, "name":"isLeftCastling()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.isLeftCastling()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Check, if this castling goes to the left.\r\n *\r\n * @return true, if this castling goes to the left.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _leftCastling;\r\n}"},
 {"id":526, "name":"isPawnPromotion()", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.isPawnPromotion()", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Check, if this move is a pawn promotion.\r\n *\r\n * @return true, if this move is a pawn promotion. False otherwise.\r\n */\r\npublic final boolean isPawnPromotion() {\r\n    return _pawnPromotion;\r\n}"},
 {"id":527, "name":"setCapture(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setCapture(boolean)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Set the flag, if this move captures a piece.\r\n *\r\n * @param capture\r\n * \t\ttrue, if this move capures a piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}"},
 {"id":528, "name":"setCastling(boolean)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setCastling(boolean)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Set this ply as a castling.\r\n *\r\n * @param goesLeft\r\n * \t\ttrue, if the castling goes to the left.\r\n */\r\npublic final void setCastling(boolean left) {\r\n    _castling = true;\r\n    _leftCastling = left;\r\n}"},
 {"id":529, "name":"setDestination(java.lang.String)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setDestination(java.lang.String)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Set the name of the destination square.\r\n *\r\n * @param squareName\r\n * \t\tThe name of the destination square.\r\n */\r\npublic final void setDestination(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _destination = new PositionImpl(squareName);\r\n}"},
 {"id":530, "name":"setOrigin(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(de.java_chess.javaChess.position.Position)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Set the name of the origin square.\r\n *\r\n * @param position\r\n * \t\tThe position of the origin square.\r\n */\r\npublic final void setOrigin(Position position) {\r\n    // Store the position.\r\n    _origin = position;\r\n}"},
 {"id":531, "name":"setOrigin(java.lang.String)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(java.lang.String)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Set the name of the origin square.\r\n *\r\n * @param squareName\r\n * \t\tThe name of the origin square.\r\n */\r\npublic final void setOrigin(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _origin = new PositionImpl(squareName);\r\n}"},
 {"id":532, "name":"setPawnPromotion(char)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setPawnPromotion(char)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Make this ply a pawn promotion and set the piece type after the promotion.\r\n *\r\n * @param newPieceTypeLetter\r\n * \t\tThe piece type after the pawn promotion as a figurine letter code.\r\n */\r\npublic final void setPawnPromotion(char newPieceTypeLetter) {\r\n    _pawnPromotion = true;\r\n    _newPieceType = getPieceTypeFromLetter(newPieceTypeLetter);\r\n}"},
 {"id":533, "name":"setPieceType(byte)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceType(byte)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"/**\r\n * Set the type of the moved piece.\r\n *\r\n * @param type\r\n * \t\tThe type of the moved piece.\r\n */\r\nprivate final void setPieceType(byte type) {\r\n    _pieceType = type;\r\n}"},
 {"id":534, "name":"setPieceTypeFromLetter(char)", "fullmethod":"de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceTypeFromLetter(char)", "ownerclassid":"65", "ownerclassname":"PGNPlyFragment", "sourcecode":"// Constructors\r\n// Methods\r\n/**\r\n * Set the piece type from a figurine letter code.\r\n *\r\n * @param letter\r\n * \t\tThe figurine letter code.\r\n */\r\npublic final void setPieceTypeFromLetter(char letter) {\r\n    setPieceType(getPieceTypeFromLetter(letter));\r\n}"},
 {"id":535, "name":"getColor()", "fullmethod":"de.java_chess.javaChess.piece.Piece.getColor()", "ownerclassid":"67", "ownerclassname":"Piece", "sourcecode":"/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic byte getColor();"},
 {"id":536, "name":"getType()", "fullmethod":"de.java_chess.javaChess.piece.Piece.getType()", "ownerclassid":"67", "ownerclassname":"Piece", "sourcecode":"// Methods\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of the piece.\r\n */\r\npublic byte getType();"},
 {"id":537, "name":"getTypeAndColor()", "fullmethod":"de.java_chess.javaChess.piece.Piece.getTypeAndColor()", "ownerclassid":"67", "ownerclassname":"Piece", "sourcecode":"/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic byte getTypeAndColor();"},
 {"id":538, "name":"isWhite()", "fullmethod":"de.java_chess.javaChess.piece.Piece.isWhite()", "ownerclassid":"67", "ownerclassname":"Piece", "sourcecode":"/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic boolean isWhite();"},
 {"id":539, "name":"setColor(byte)", "fullmethod":"de.java_chess.javaChess.piece.Piece.setColor(byte)", "ownerclassid":"67", "ownerclassname":"Piece", "sourcecode":"/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * \t\tnew color of this piece.\r\n */\r\npublic void setColor(byte color);"},
 {"id":540, "name":"setType(byte)", "fullmethod":"de.java_chess.javaChess.piece.Piece.setType(byte)", "ownerclassid":"67", "ownerclassname":"Piece", "sourcecode":"/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * \t\tThe new type of this piece.\r\n */\r\npublic void setType(byte type);"},
 {"id":541, "name":"-init-(byte)", "fullmethod":"de.java_chess.javaChess.PieceImpl.-init-(byte)", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece instance.\r\n *\r\n * @param typeColor\r\n * \t\tThe color and type of piece, with color in bit 0\r\n * \t\tand the type color in bit 1-3.\r\n */\r\npublic PieceImpl(byte typeColor) {\r\n    _typeColor = typeColor;\r\n}"},
 {"id":542, "name":"-init-(byte,byte)", "fullmethod":"de.java_chess.javaChess.PieceImpl.-init-(byte,byte)", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"/**\r\n * Create a new Piece instance from type and color.\r\n *\r\n * @param type\r\n * \t\tThe type of the piece.\r\n * @param color\r\n * \t\tThe color of the piece.\r\n */\r\npublic PieceImpl(byte type, byte color) {\r\n    this(((byte) ((type << 1) + color)));\r\n}"},
 {"id":543, "name":"getColor()", "fullmethod":"de.java_chess.javaChess.piece.PieceImpl.getColor()", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic final byte getColor() {\r\n    return ((byte) ((_typeColor) & ((byte) (1))));\r\n}"},
 {"id":544, "name":"getType()", "fullmethod":"de.java_chess.javaChess.piece.PieceImpl.getType()", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic final byte getType() {\r\n    return ((byte) ((_typeColor) >> 1));\r\n}"},
 {"id":545, "name":"getTypeAndColor()", "fullmethod":"de.java_chess.javaChess.piece.PieceImpl.getTypeAndColor()", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic final byte getTypeAndColor() {\r\n    return _typeColor;\r\n}"},
 {"id":546, "name":"isWhite()", "fullmethod":"de.java_chess.javaChess.piece.PieceImpl.isWhite()", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic final boolean isWhite() {\r\n    return ((_typeColor) & 1) != 0;\r\n}"},
 {"id":547, "name":"setColor(byte)", "fullmethod":"de.java_chess.javaChess.piece.PieceImpl.setColor(byte)", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * \t\tnew color of this piece.\r\n */\r\npublic final void setColor(byte color) {\r\n    _typeColor &= ((byte) (14));\r\n    _typeColor |= color;\r\n}"},
 {"id":548, "name":"setType(byte)", "fullmethod":"de.java_chess.javaChess.piece.PieceImpl.setType(byte)", "ownerclassid":"68", "ownerclassname":"PieceImpl", "sourcecode":"/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * \t\tThe type of this piece as defined as\r\n * \t\tconstants in the Piece interface.\r\n */\r\npublic final void setType(byte type) {\r\n    _typeColor &= ((byte) (1));\r\n    _typeColor |= type << 1;\r\n}"},
 {"id":549, "name":"clone()", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPly.clone()", "ownerclassid":"69", "ownerclassname":"AnalyzedPly", "sourcecode":"/**\r\n * Clone this ply.\r\n *\r\n * @return A clone of this ply.\r\n */\r\nObject clone();"},
 {"id":550, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPly.getPly()", "ownerclassid":"69", "ownerclassname":"AnalyzedPly", "sourcecode":"// Methods\r\n/**\r\n * Get the analyzed ply.\r\n *\r\n * @return The analyzed ply.\r\n */\r\nPly getPly();"},
 {"id":551, "name":"getScore()", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPly.getScore()", "ownerclassid":"69", "ownerclassname":"AnalyzedPly", "sourcecode":"/**\r\n * Get the scrore of this ply.\r\n *\r\n * @return The score of this ply.\r\n */\r\nshort getScore();"},
 {"id":552, "name":"setPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPly.setPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"69", "ownerclassname":"AnalyzedPly", "sourcecode":"/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * \t\tThe new ply.\r\n */\r\nvoid setPly(Ply ply);"},
 {"id":553, "name":"setScore(short)", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPly.setScore(short)", "ownerclassid":"69", "ownerclassname":"AnalyzedPly", "sourcecode":"/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * \t\tThe new score for this ply.\r\n */\r\nvoid setScore(short score);"},
 {"id":554, "name":"-init-(de.java_chess.javaChess.ply.Ply,short)", "fullmethod":"de.java_chess.javaChess.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)", "ownerclassid":"70", "ownerclassname":"AnalyzedPlyImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}"},
 {"id":555, "name":"clone()", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.clone()", "ownerclassid":"70", "ownerclassname":"AnalyzedPlyImpl", "sourcecode":"/**\r\n * Clone this ply.\r\n *\r\n * @return A clone of this ply.\r\n */\r\npublic Object clone() {\r\n    return new AnalyzedPlyImpl(getPly(), getScore());\r\n}"},
 {"id":556, "name":"getPly()", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.getPly()", "ownerclassid":"70", "ownerclassname":"AnalyzedPlyImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the analyzed ply.\r\n *\r\n * @return The analyzed ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}"},
 {"id":557, "name":"getScore()", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.getScore()", "ownerclassid":"70", "ownerclassname":"AnalyzedPlyImpl", "sourcecode":"/**\r\n * Get the scrore of this ply.\r\n *\r\n * @return The score of this ply.\r\n */\r\npublic final short getScore() {\r\n    return _score;\r\n}"},
 {"id":558, "name":"setPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.setPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"70", "ownerclassname":"AnalyzedPlyImpl", "sourcecode":"/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * \t\tThe new ply.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":559, "name":"setScore(short)", "fullmethod":"de.java_chess.javaChess.ply.AnalyzedPlyImpl.setScore(short)", "ownerclassid":"70", "ownerclassname":"AnalyzedPlyImpl", "sourcecode":"/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * \t\tThe new score for this ply.\r\n */\r\npublic final void setScore(short score) {\r\n    _score = score;\r\n}"},
 {"id":560, "name":"isLeftCastling()", "fullmethod":"de.java_chess.javaChess.ply.CastlingPly.isLeftCastling()", "ownerclassid":"71", "ownerclassname":"CastlingPly", "sourcecode":"// Static variables\r\n// Methods\r\n/**\r\n * Check, if this castling goes to the left side of the board.\r\n *\r\n * @return true, if the castling goes to the left side, false otherwise.\r\n */\r\nboolean isLeftCastling();"},
 {"id":561, "name":"setLeftCastling(boolean)", "fullmethod":"de.java_chess.javaChess.ply.CastlingPly.setLeftCastling(boolean)", "ownerclassid":"71", "ownerclassname":"CastlingPly", "sourcecode":"/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\nvoid setLeftCastling(boolean goesLeft);"},
 {"id":562, "name":"-init-(de.java_chess.javaChess.position.Position,boolean)", "fullmethod":"de.java_chess.javaChess.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)", "ownerclassid":"72", "ownerclassname":"CastlingPlyImpl", "sourcecode":"// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}"},
 {"id":563, "name":"isLeftCastling()", "fullmethod":"de.java_chess.javaChess.ply.CastlingPlyImpl.isLeftCastling()", "ownerclassid":"72", "ownerclassname":"CastlingPlyImpl", "sourcecode":"// Methods\r\n/**\r\n * Check, if this castling goes to the left side of the board.\r\n *\r\n * @return true, if the castling goes to the left side, false otherwise.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _goesLeft;\r\n}"},
 {"id":564, "name":"setLeftCastling(boolean)", "fullmethod":"de.java_chess.javaChess.ply.CastlingPlyImpl.setLeftCastling(boolean)", "ownerclassid":"72", "ownerclassname":"CastlingPlyImpl", "sourcecode":"/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * \t\tFlag to indicate if the castling goes left.\r\n */\r\npublic final void setLeftCastling(boolean goesLeft) {\r\n    _goesLeft = goesLeft;\r\n}"},
 {"id":565, "name":"toString()", "fullmethod":"de.java_chess.javaChess.ply.CastlingPlyImpl.toString()", "ownerclassid":"72", "ownerclassname":"CastlingPlyImpl", "sourcecode":"/**\r\n * Get a string representation of this castling.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic final String toString() {\r\n    return isLeftCastling() ? \"O-O-O\" : \"O-O\";\r\n}"},
 {"id":566, "name":"getAttackedPosition()", "fullmethod":"de.java_chess.javaChess.ply.EnPassantPly.getAttackedPosition()", "ownerclassid":"73", "ownerclassname":"EnPassantPly", "sourcecode":"// Methods\r\n/**\r\n * Get the position of the attacked pawn.\r\n *\r\n * @return Get the position of the attacked pawn.\r\n */\r\nPosition getAttackedPosition();"},
 {"id":567, "name":"setAttackedPosition(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.ply.EnPassantPly.setAttackedPosition(de.java_chess.javaChess.position.Position)", "ownerclassid":"73", "ownerclassname":"EnPassantPly", "sourcecode":"/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * \t\tThe position of the attacked pawn.\r\n */\r\nvoid setAttackedPosition(Position attackedPosition);"},
 {"id":568, "name":"-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)", "ownerclassid":"74", "ownerclassname":"EnPassantPlyImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square of the attacking pawn.\r\n * @param destination\r\n * \t\tThe destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}"},
 {"id":569, "name":"getAttackedPosition()", "fullmethod":"de.java_chess.javaChess.ply.EnPassantPlyImpl.getAttackedPosition()", "ownerclassid":"74", "ownerclassname":"EnPassantPlyImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the position of the attacked pawn.\r\n *\r\n * @return Get the position of the attacked pawn.\r\n */\r\npublic final Position getAttackedPosition() {\r\n    return _attackedPosition;\r\n}"},
 {"id":570, "name":"setAttackedPosition(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.ply.EnPassantPlyImpl.setAttackedPosition(de.java_chess.javaChess.position.Position)", "ownerclassid":"74", "ownerclassname":"EnPassantPlyImpl", "sourcecode":"/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * \t\tThe position of the attacked pawn.\r\n */\r\npublic final void setAttackedPosition(Position attackedPosition) {\r\n    _attackedPosition = attackedPosition;\r\n}"},
 {"id":571, "name":"equals(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.ply.Ply.equals(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"75", "ownerclassname":"Ply", "sourcecode":"/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * \t\tThe other ply.\r\n * @return true, if the 2 plies are equal. False otherwise.\r\n */\r\nboolean equals(Ply ply);"},
 {"id":572, "name":"getDestination()", "fullmethod":"de.java_chess.javaChess.ply.Ply.getDestination()", "ownerclassid":"75", "ownerclassname":"Ply", "sourcecode":"/**\r\n * Get the destination of the piece.\r\n *\r\n * @return The destination square of this ply.\r\n */\r\nPosition getDestination();"},
 {"id":573, "name":"getSource()", "fullmethod":"de.java_chess.javaChess.ply.Ply.getSource()", "ownerclassid":"75", "ownerclassname":"Ply", "sourcecode":"// Static variables\r\n// Methods\r\n/**\r\n * Get the source of the ply.\r\n *\r\n * @return The source square of this ply.\r\n */\r\nPosition getSource();"},
 {"id":574, "name":"isCapture()", "fullmethod":"de.java_chess.javaChess.ply.Ply.isCapture()", "ownerclassid":"75", "ownerclassname":"Ply", "sourcecode":"/**\r\n * Check, if this ply captures another piece.\r\n *\r\n * @return true, if another piece is captured with this ply.\r\n */\r\nboolean isCapture();"},
 {"id":575, "name":"setDestination(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.ply.Ply.setDestination(de.java_chess.javaChess.position.Position)", "ownerclassid":"75", "ownerclassname":"Ply", "sourcecode":"/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * \t\tThe new destination square of this ply.\r\n */\r\nvoid setDestination(Position destination);"},
 {"id":576, "name":"setSource(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.ply.Ply.setSource(de.java_chess.javaChess.position.Position)", "ownerclassid":"75", "ownerclassname":"Ply", "sourcecode":"/**\r\n * Set the source of the ply.\r\n *\r\n * @param source\r\n * \t\tThe new source square for this ply.\r\n */\r\nvoid setSource(Position source);"},
 {"id":577, "name":"-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)", "fullmethod":"de.java_chess.javaChess.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * \t\tThe source of the ply.\r\n * @param destination\r\n * \t\tThe destination of the ply.\r\n * @param capture\r\n * \t\tFlag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}"},
 {"id":578, "name":"equals(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * \t\tThe other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}"},
 {"id":579, "name":"getDestination()", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.getDestination()", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"/**\r\n * Get the destination of the piece.\r\n *\r\n * @return The destination of the piece.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}"},
 {"id":580, "name":"getSource()", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.getSource()", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the source of the ply.\r\n *\r\n * @return The source of the piece.\r\n */\r\npublic final Position getSource() {\r\n    return _source;\r\n}"},
 {"id":581, "name":"isCapture()", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.isCapture()", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"/**\r\n * Check, if this ply captures another piece.\r\n *\r\n * @return true, if another piece is captured with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}"},
 {"id":582, "name":"setCapture(boolean)", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.setCapture(boolean)", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"/**\r\n * Set a flag, if this ply captures another piece.\r\n *\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}"},
 {"id":583, "name":"setDestination(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.setDestination(de.java_chess.javaChess.position.Position)", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * \t\tThe new destination of the piece.\r\n */\r\npublic final void setDestination(Position destination) {\r\n    _destination = destination;\r\n}"},
 {"id":584, "name":"setSource(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.setSource(de.java_chess.javaChess.position.Position)", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"/**\r\n * Set the source of the ply.\r\n *\r\n * @param The\r\n * \t\tnew source of the piece.\r\n */\r\npublic final void setSource(Position source) {\r\n    _source = source;\r\n}"},
 {"id":585, "name":"toString()", "fullmethod":"de.java_chess.javaChess.ply.PlyImpl.toString()", "ownerclassid":"76", "ownerclassname":"PlyImpl", "sourcecode":"/**\r\n * Convert the ply into something human readable. Its not exactly chess\r\n * notation, since we dont have a board to check, if it is a move or\r\n * a attack.\r\n *\r\n * @return The ply as a string.\r\n */\r\npublic String toString() {\r\n    return ((getSource().toSquareName()) + \"-\") + (getDestination().toSquareName());\r\n}"},
 {"id":586, "name":"getTypeAfterTransformation()", "fullmethod":"de.java_chess.javaChess.ply.TransformationPly.getTypeAfterTransformation()", "ownerclassid":"77", "ownerclassname":"TransformationPly", "sourcecode":"// Methods\r\n/**\r\n * Get the new type of the piece after the transformation.\r\n *\r\n * @return The new piece after the transformation.\r\n */\r\nbyte getTypeAfterTransformation();"},
 {"id":587, "name":"setTypeAfterTransformation(byte)", "fullmethod":"de.java_chess.javaChess.ply.TransformationPly.setTypeAfterTransformation(byte)", "ownerclassid":"77", "ownerclassname":"TransformationPly", "sourcecode":"/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * \t\tThe new piece type after the transformation.\r\n */\r\nvoid setTypeAfterTransformation(byte pieceType);"},
 {"id":588, "name":"-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "fullmethod":"de.java_chess.javaChess.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)", "ownerclassid":"78", "ownerclassname":"TransformationPlyImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * \t\tThe source square.\r\n * @param destination\r\n * \t\tThe destination square.\r\n * @param pieceType\r\n * \t\tThe piece type after the transformation.\r\n * @param capture\r\n * \t\tFlag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}"},
 {"id":589, "name":"getTypeAfterTransformation()", "fullmethod":"de.java_chess.javaChess.ply.TransformationPlyImpl.getTypeAfterTransformation()", "ownerclassid":"78", "ownerclassname":"TransformationPlyImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the new type of the piece after the transformation.\r\n *\r\n * @return The new piece after the transformation.\r\n */\r\npublic final byte getTypeAfterTransformation() {\r\n    return _newPieceType;\r\n}"},
 {"id":590, "name":"setTypeAfterTransformation(byte)", "fullmethod":"de.java_chess.javaChess.ply.TransformationPlyImpl.setTypeAfterTransformation(byte)", "ownerclassid":"78", "ownerclassname":"TransformationPlyImpl", "sourcecode":"/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * \t\tThe new piece type after the transformation.\r\n */\r\npublic final void setTypeAfterTransformation(byte pieceType) {\r\n    _newPieceType = pieceType;\r\n}"},
 {"id":591, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.IllegalPositionException.-init-()", "ownerclassid":"79", "ownerclassname":"IllegalPositionException", "sourcecode":"IllegalPositionException() {\r\n}"},
 {"id":592, "name":"equals(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.position.Position.equals(de.java_chess.javaChess.position.Position)", "ownerclassid":"80", "ownerclassname":"Position", "sourcecode":"/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * \t\tposition.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\nboolean equals(Position pos);"},
 {"id":593, "name":"getLineIndex()", "fullmethod":"de.java_chess.javaChess.position.Position.getLineIndex()", "ownerclassid":"80", "ownerclassname":"Position", "sourcecode":"/**\r\n * Get the line index of this position.\r\n *\r\n * @return The line index of this position (0-7).\r\n */\r\nint getLineIndex();"},
 {"id":594, "name":"getRowIndex()", "fullmethod":"de.java_chess.javaChess.position.Position.getRowIndex()", "ownerclassid":"80", "ownerclassname":"Position", "sourcecode":"/**\r\n * Get the row index of this position.\r\n *\r\n * @return The row index of this position (0-7).\r\n */\r\nint getRowIndex();"},
 {"id":595, "name":"getSquareIndex()", "fullmethod":"de.java_chess.javaChess.position.Position.getSquareIndex()", "ownerclassid":"80", "ownerclassname":"Position", "sourcecode":"// Methods\r\n/**\r\n * Get the square index of this position instance.\r\n *\r\n * @return The square index of this piece position (0-63).\r\n */\r\nint getSquareIndex();"},
 {"id":596, "name":"setSquareIndex(int)", "fullmethod":"de.java_chess.javaChess.position.Position.setSquareIndex(int)", "ownerclassid":"80", "ownerclassname":"Position", "sourcecode":"/**\r\n * The square index of this position instance.\r\n *\r\n * @param index\r\n * \t\tThe square index of this position (0-63).\r\n */\r\nvoid setSquareIndex(int index);"},
 {"id":597, "name":"toSquareName()", "fullmethod":"de.java_chess.javaChess.position.Position.toSquareName()", "ownerclassid":"80", "ownerclassname":"Position", "sourcecode":"/**\r\n * Get the name of this square.\r\n *\r\n * @return The suare name of this position (i.e. a4).\r\n */\r\nString toSquareName();"},
 {"id":598, "name":"-init-(int)", "fullmethod":"de.java_chess.javaChess.PositionImpl.-init-(int)", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"// Constructors\r\n/**\r\n * Create a position from a given square index.\r\n *\r\n * @param squareIndex\r\n * \t\tThe index of the square (0..63).\r\n */\r\npublic PositionImpl(int squareIndex) {\r\n    setSquareIndex(squareIndex);\r\n}"},
 {"id":599, "name":"-init-(java.lang.String)", "fullmethod":"de.java_chess.javaChess.PositionImpl.-init-(java.lang.String)", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"/**\r\n * Create a position from a given square name (i.e. d4).\r\n *\r\n * @param squareName\r\n * \t\tThe name of the square.\r\n * @throws IllegalPositionException\r\n * \t\tIf the argument is not a valid square name.\r\n */\r\npublic PositionImpl(String squareName) throws IllegalPositionException {\r\n    // -1 indicates an error here.\r\n    int squareIndex = -1;\r\n    // Trim and convert the name to lower case.\r\n    squareName = squareName.trim().toLowerCase();\r\n    // Check if the name has no extra characters\r\n    if ((squareName.length()) != 2) {\r\n        throw new IllegalPositionException();\r\n    } else {\r\n        // Get the line.\r\n        char lineLetter = squareName.charAt(0);\r\n        if ((lineLetter < a) || (lineLetter > h)) {\r\n            throw new IllegalPositionException();\r\n        } else {\r\n            // Compute the index of the line.\r\n            int lineIndex = lineLetter - a;\r\n            // Get the name of the row.\r\n            char rowLetter = squareName.charAt(1);\r\n            if ((rowLetter < 1) || (rowLetter > 8)) {\r\n                throw new IllegalPositionException();\r\n            } else {\r\n                int rowIndex = rowLetter - 1;\r\n                // The square index is 8 * row + line.\r\n                squareIndex = (rowIndex << 3) + lineIndex;\r\n            }\r\n        }\r\n    }\r\n    // Set the computed square index.\r\n    setSquareIndex(squareIndex);\r\n}"},
 {"id":600, "name":"equals(de.java_chess.javaChess.position.Position)", "fullmethod":"de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * \t\tposition.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}"},
 {"id":601, "name":"getLineIndex()", "fullmethod":"de.java_chess.javaChess.position.PositionImpl.getLineIndex()", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"/**\r\n * Get the line index of this postion (0-7).\r\n *\r\n * @return The line index of this position.\r\n */\r\npublic final int getLineIndex() {\r\n    return (_squareIndex) & 7;\r\n}"},
 {"id":602, "name":"getRowIndex()", "fullmethod":"de.java_chess.javaChess.position.PositionImpl.getRowIndex()", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"/**\r\n * Get the row index of this position (0-7).\r\n *\r\n * @return The row index of this position.\r\n */\r\npublic final int getRowIndex() {\r\n    return (_squareIndex) >> 3;\r\n}"},
 {"id":603, "name":"getSquareIndex()", "fullmethod":"de.java_chess.javaChess.position.PositionImpl.getSquareIndex()", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"// Methods\r\n/**\r\n * Get the square index of this position (0-63).\r\n *\r\n * @return The square index of this position.\r\n */\r\npublic final int getSquareIndex() {\r\n    return _squareIndex;\r\n}"},
 {"id":604, "name":"setSquareIndex(int)", "fullmethod":"de.java_chess.javaChess.position.PositionImpl.setSquareIndex(int)", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"/**\r\n * Set the square index of this position.\r\n *\r\n * @param squareIndex\r\n * \t\tThe new square index of this position.\r\n */\r\npublic final void setSquareIndex(int squareIndex) {\r\n    _squareIndex = squareIndex;\r\n}"},
 {"id":605, "name":"toSquareName()", "fullmethod":"de.java_chess.javaChess.position.PositionImpl.toSquareName()", "ownerclassid":"81", "ownerclassname":"PositionImpl", "sourcecode":"/**\r\n * Convert this position to a square name (like a4).\r\n *\r\n * @return The suare name of this position.\r\n */\r\npublic final String toSquareName() {\r\n    byte[] byteRepresentation = new byte[2];\r\n    byteRepresentation[0] = ((byte) (((int) (a)) + (getLineIndex())));\r\n    byteRepresentation[1] = ((byte) (((int) (1)) + (getRowIndex())));\r\n    return new String(byteRepresentation);\r\n}"},
 {"id":606, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.renderer.ChessBoardRenderer.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"82", "ownerclassname":"ChessBoardRenderer", "sourcecode":"/**\r\n * Render a piece move.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\nvoid doPly(Ply ply);"},
 {"id":607, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.renderer.ChessBoardRenderer.getBoard()", "ownerclassid":"82", "ownerclassname":"ChessBoardRenderer", "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nBoard getBoard();"},
 {"id":608, "name":"repaintBoard()", "fullmethod":"de.java_chess.javaChess.renderer.ChessBoardRenderer.repaintBoard()", "ownerclassid":"82", "ownerclassname":"ChessBoardRenderer", "sourcecode":"/**\r\n * Repaint the current board.\r\n */\r\nvoid repaintBoard();"},
 {"id":609, "name":"reset()", "fullmethod":"de.java_chess.javaChess.renderer.ChessBoardRenderer.reset()", "ownerclassid":"82", "ownerclassname":"ChessBoardRenderer", "sourcecode":"/**\r\n * Reset the renderer for a new game.\r\n */\r\nvoid reset();"},
 {"id":610, "name":"setBoard(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.renderer.ChessBoardRenderer.setBoard(de.java_chess.javaChess.board.Board)", "ownerclassid":"82", "ownerclassname":"ChessBoardRenderer", "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\nvoid setBoard(Board board);"},
 {"id":611, "name":"-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)", "fullmethod":"de.java_chess.javaChess.AnimationLayer.-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)", "ownerclassid":"83", "ownerclassname":"AnimationLayer", "sourcecode":"// Constructors\r\n/**\r\n * Create a new AnimationLayer instance.\r\n *\r\n * @param piecesLayer\r\n * \t\tThe layer with the pieces.\r\n */\r\nAnimationLayer(PiecesLayer piecesLayer) {\r\n    setPiecesLayer(piecesLayer);\r\n}"},
 {"id":612, "name":"animatePly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.renderer2d.AnimationLayer.animatePly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"83", "ownerclassname":"AnimationLayer", "sourcecode":"// Methods\r\n/**\r\n * Animate the move of a piece.\r\n */\r\nvoid animatePly(Ply ply) {\r\n    _ply = ply;\r\n}"},
 {"id":613, "name":"getPiecesLayer()", "fullmethod":"de.java_chess.javaChess.renderer2d.AnimationLayer.getPiecesLayer()", "ownerclassid":"83", "ownerclassname":"AnimationLayer", "sourcecode":"/**\r\n * Paint the animated piece.\r\n *\r\n * @param g\r\n * \t\tThe graphics context.\r\n */\r\n/* public void paint( Graphics g) {\nSystem.out.println( \"Repaint piece at \" + _currentPoint.x + \",\" + _currentPoint.y);\n// g.drawImage( _piece, _currentPoint.x, _currentPoint.y, this);\n}\n */\r\n/**\r\n * Get the current pieces layer.\r\n *\r\n * @return The current pieces layer.\r\n */\r\nPiecesLayer getPiecesLayer() {\r\n    return _piecesLayer;\r\n}"},
 {"id":614, "name":"run()", "fullmethod":"de.java_chess.javaChess.renderer2d.AnimationLayer.run()", "ownerclassid":"83", "ownerclassname":"AnimationLayer", "sourcecode":"/**\r\n * The run method to start the animation thread.\r\n */\r\npublic void run() {\r\n    ImageIcon icon = ((ImageIcon) (getPiecesLayer().getPositionRenderer(_ply.getSource().getSquareIndex()).getIcon()));\r\n    JLabel movingPiece = new JLabel(icon);\r\n    // _piece = (PieceRenderer)icon.getImage();\r\n    getPiecesLayer().getPositionRenderer(_ply.getSource().getSquareIndex()).setIcon(null);\r\n    getPiecesLayer().repaint();\r\n    int xOffset = ((ChessBoardRenderer2D.getSquareSize()) - (icon.getIconWidth())) / 2;\r\n    int yOffset = ((ChessBoardRenderer2D.getSquareSize()) - (icon.getIconHeight())) / 2;\r\n    _currentPoint = new Point(((((_ply.getSource().getSquareIndex()) & 7) * (ChessBoardRenderer2D.getSquareSize())) + xOffset), (((7 - ((_ply.getSource().getSquareIndex()) >> 3)) * (ChessBoardRenderer2D.getSquareSize())) + yOffset));\r\n    Point endPoint = new Point(((((_ply.getDestination().getSquareIndex()) & 7) * (ChessBoardRenderer2D.getSquareSize())) + xOffset), (((7 - ((_ply.getDestination().getSquareIndex()) >> 3)) * (ChessBoardRenderer2D.getSquareSize())) + yOffset));\r\n    int xMoveOffset = ((_currentPoint.x) < (endPoint.x)) ? 1 : (_currentPoint.x) > (endPoint.x) ? -1 : 0;\r\n    int yMoveOffset = ((_currentPoint.y) < (endPoint.y)) ? 1 : (_currentPoint.y) > (endPoint.y) ? -1 : 0;\r\n    movingPiece.setLocation(_currentPoint);\r\n    while (!(_currentPoint.equals(endPoint))) {\r\n        if ((_currentPoint.x) == (endPoint.x)) {\r\n            xMoveOffset = 0;\r\n        }\r\n        if ((_currentPoint.y) == (endPoint.y)) {\r\n            yMoveOffset = 0;\r\n        }\r\n        _currentPoint.x += xMoveOffset;\r\n        _currentPoint.y += yMoveOffset;\r\n        // invalidate();\r\n        // repaint();\r\n        // paint( getGraphics());\r\n        // getGraphics().drawImage( _piece, _currentPoint.x, _currentPoint.y, this);\r\n        movingPiece.setLocation(_currentPoint);\r\n        paintImmediately(((_currentPoint.x) - 1), ((_currentPoint.y) - 1), ChessBoardRenderer2D.getSquareSize(), ChessBoardRenderer2D.getSquareSize());\r\n        try {\r\n            Thread.sleep(5);\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n        // getGraphics().clearRect( _currentPoint.x - 1, _currentPoint.y - 1, ChessBoardRenderer2D.getSquareSize() + 1, ChessBoardRenderer2D.getSquareSize() + 1);\r\n    } \r\n    movingPiece.setVisible(false);\r\n    getPiecesLayer().getPositionRenderer(_ply.getDestination().getSquareIndex()).setIcon(icon);\r\n    _ply = null;\r\n    _animationThread = null;\r\n}"},
 {"id":615, "name":"setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)", "fullmethod":"de.java_chess.javaChess.renderer2d.AnimationLayer.setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)", "ownerclassid":"83", "ownerclassname":"AnimationLayer", "sourcecode":"/**\r\n * Set a new pieces layer.\r\n *\r\n * @param piecesLayer\r\n * \t\tThe new pieces layer.\r\n */\r\nvoid setPiecesLayer(PiecesLayer piecesLayer) {\r\n    _piecesLayer = piecesLayer;\r\n}"},
 {"id":616, "name":"start()", "fullmethod":"de.java_chess.javaChess.renderer2d.AnimationLayer.start()", "ownerclassid":"83", "ownerclassname":"AnimationLayer", "sourcecode":"/**\r\n * The method to start the thread.\r\n */\r\npublic void start() {\r\n    if ((_animationThread) == null) {\r\n        _animationThread = new Thread(this);\r\n        _animationThread.start();\r\n    }\r\n}"},
 {"id":617, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.BoardLayer.-init-()", "ownerclassid":"84", "ownerclassname":"BoardLayer", "sourcecode":"// Constructors\r\nBoardLayer() {\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n}"},
 {"id":618, "name":"getBoardSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.BoardLayer.getBoardSize()", "ownerclassid":"84", "ownerclassname":"BoardLayer", "sourcecode":"/**\r\n * Get the board size.\r\n *\r\n * @return The board size.\r\n */\r\nfinal int getBoardSize() {\r\n    return _boardSize;\r\n}"},
 {"id":619, "name":"getMaximumSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.BoardLayer.getMaximumSize()", "ownerclassid":"84", "ownerclassname":"BoardLayer", "sourcecode":"/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":620, "name":"getMinimumSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.BoardLayer.getMinimumSize()", "ownerclassid":"84", "ownerclassname":"BoardLayer", "sourcecode":"/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(getBoardSize(), getBoardSize());\r\n}"},
 {"id":621, "name":"getPreferredSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.BoardLayer.getPreferredSize()", "ownerclassid":"84", "ownerclassname":"BoardLayer", "sourcecode":"/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":622, "name":"getSquareSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.BoardLayer.getSquareSize()", "ownerclassid":"84", "ownerclassname":"BoardLayer", "sourcecode":"/**\r\n * Get the square size.\r\n *\r\n * @return The square size.\r\n */\r\nfinal int getSquareSize() {\r\n    return _squareSize;\r\n}"},
 {"id":623, "name":"paintComponent(java.awt.Graphics)", "fullmethod":"de.java_chess.javaChess.renderer2d.BoardLayer.paintComponent(java.awt.Graphics)", "ownerclassid":"84", "ownerclassname":"BoardLayer", "sourcecode":"// Methods\r\npublic void paintComponent(Graphics g) {\r\n    // g.setColor( new Color( 190, 190, 140) );\r\n    // g.setColor( new Color( 229, 229, 225) );\r\n    g.setColor(new Color(247, 247, 245));\r\n    g.fillRect(0, 0, _boardSize, _boardSize);\r\n    // g.setColor( new Color( 122, 80, 44));\r\n    // g.setColor( new Color( 250, 105, 86));\r\n    // g.setColor( new Color( 235, 142, 9));\r\n    g.setColor(new Color(249, 134, 89));\r\n    for (int i = 0; i < 8; i++)\r\n        for (int j = 0; j < 8; j++)\r\n            if (((i % 2) != 0) && ((j % 2) == 0))\r\n                g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n            else\r\n                if (((i % 2) == 0) && ((j % 2) != 0))\r\n                    g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n\r\n\r\n\r\n\r\n}"},
 {"id":624, "name":"-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * \t\tThe game controller.\r\n * @param board\r\n * \t\tThe current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}"},
 {"id":625, "name":"clearBoard()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.clearBoard()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Repaint the board after a game position change.\r\n */\r\npublic final void clearBoard() {\r\n    _piecesLayer.clearBoard();\r\n    repaint();\r\n}"},
 {"id":626, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Render a ply (the move of a piece).\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    _piecesLayer.doPly(ply);\r\n    repaint();\r\n}"},
 {"id":627, "name":"getBoard()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getBoard()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}"},
 {"id":628, "name":"getMaximumSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMaximumSize()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":629, "name":"getMinimumSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMinimumSize()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)), ((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)));\r\n}"},
 {"id":630, "name":"getPreferredSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getPreferredSize()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}"},
 {"id":631, "name":"getSquareSize()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getSquareSize()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Get the size of a square.\r\n *\r\n * @return The size of a square as a int (since height and width are the same).\r\n */\r\npublic static final int getSquareSize() {\r\n    return ChessBoardRenderer2D._squareSize;\r\n}"},
 {"id":632, "name":"repaintBoard()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.repaintBoard()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Repaint the board after a game position change.\r\n */\r\npublic final void repaintBoard() {\r\n    _piecesLayer.repaintBoard();\r\n    repaint();\r\n}"},
 {"id":633, "name":"reset()", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.reset()", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Reset the renderer for a new game.\r\n */\r\npublic void reset() {\r\n    repaintBoard();\r\n}"},
 {"id":634, "name":"setBoard(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.setBoard(de.java_chess.javaChess.board.Board)", "ownerclassid":"85", "ownerclassname":"ChessBoardRenderer2D", "sourcecode":"/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * \t\tThe new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}"},
 {"id":635, "name":"-init-(java.awt.Component)", "fullmethod":"de.java_chess.javaChess.ChessSet.-init-(java.awt.Component)", "ownerclassid":"86", "ownerclassname":"ChessSet", "sourcecode":"// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new chess set component.\r\n *\r\n * @param c\r\n * \t\tThe parent component.\r\n */\r\npublic ChessSet(Component c) {\r\n    super(240, 80, BufferedImage.TYPE_INT_ARGB);\r\n    Image im = null;\r\n    // try {\r\n    // URL url = getClass().getResource(\"ChessPieces_neu.gif\");\r\n    // im = Toolkit.getDefaultToolkit().getImage( url );\r\n    // im = Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/ChessPieces02.gif\"));\r\n    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // original\r\n    // im = ResourceLoader.getInstance().loadImage( \"ChessPieces02.gif\");\r\n    // achraf\r\n    URL urlStart = getClass().getResource(\"images/ChessPieces02.gif\");\r\n    im = Toolkit.getDefaultToolkit().getImage(urlStart);\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // } catch( MalformedURLException ignored) {}\r\n    MediaTracker mT = new MediaTracker(c);\r\n    mT.addImage(im, 0);\r\n    try {\r\n        mT.waitForID(0);\r\n    } catch (InterruptedException ie) {\r\n    }\r\n    Graphics g = getGraphics();\r\n    g.drawImage(im, 0, 0, c);\r\n}"},
 {"id":636, "name":"-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)", "fullmethod":"de.java_chess.javaChess.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)", "ownerclassid":"87", "ownerclassname":"ControlLayer", "sourcecode":"// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}"},
 {"id":637, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.ControlLayer.-init-()", "ownerclassid":"87", "ownerclassname":"ControlLayer", "sourcecode":"1() {\r\n}"},
 {"id":638, "name":"getController()", "fullmethod":"de.java_chess.javaChess.renderer2d.ControlLayer.getController()", "ownerclassid":"87", "ownerclassname":"ControlLayer", "sourcecode":"/**\r\n * Get the game controller.\r\n *\r\n * @return The game controller.\r\n */\r\nprivate final GameController getController() {\r\n    return _controller;\r\n}"},
 {"id":639, "name":"markSquare(int,java.awt.Graphics)", "fullmethod":"de.java_chess.javaChess.renderer2d.ControlLayer.markSquare(int,java.awt.Graphics)", "ownerclassid":"87", "ownerclassname":"ControlLayer", "sourcecode":"/**\r\n * Draw a marker at the given square.\r\n *\r\n * @param square\r\n * \t\tThe square to mark.\r\n * @param g\r\n * \t\tThe graphics context.\r\n */\r\nprivate final void markSquare(int square, Graphics g) {\r\n    int xpos = (square & 7) * (_squareSize);\r\n    // Compute the location of the\r\n    int ypos = (7 - (square >> 3)) * (_squareSize);// square\r\n\r\n    int rectSize = (_squareSize) - 1;\r\n    // and its size.\r\n    g.setColor(Color.blue);\r\n    // Simply draw a blue frame there.\r\n    for (int i = 0; i < 3; i++) {\r\n        g.drawRect((xpos++), (ypos++), rectSize, rectSize);\r\n        rectSize -= 2;\r\n    }\r\n}"},
 {"id":640, "name":"paintComponent(java.awt.Graphics)", "fullmethod":"de.java_chess.javaChess.renderer2d.ControlLayer.paintComponent(java.awt.Graphics)", "ownerclassid":"87", "ownerclassname":"ControlLayer", "sourcecode":"// Methods\r\n/**\r\n * Overridden  paintComponent method to draw the marker for\r\n * the source square.\r\n *\r\n * @param g\r\n * \t\tThe graphics context.\r\n */\r\npublic void paintComponent(Graphics g) {\r\n    if ((_sourceSquare) != (-1)) {\r\n        // If a source square is selected,\r\n        markSquare(_sourceSquare, g);// mark it.\r\n\r\n    }\r\n}"},
 {"id":641, "name":"setController(de.java_chess.javaChess.GameController)", "fullmethod":"de.java_chess.javaChess.renderer2d.ControlLayer.setController(de.java_chess.javaChess.GameController)", "ownerclassid":"87", "ownerclassname":"ControlLayer", "sourcecode":"/**\r\n * Set a new game controller.\r\n *\r\n * @param The\r\n * \t\tnew game controller.\r\n */\r\nprivate final void setController(GameController controller) {\r\n    _controller = controller;\r\n}"},
 {"id":642, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.CountdownTimerPanel.-init-()", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * The start time of the thread.\r\n */\r\n// long _startTime;\r\n// Constructors\r\n/**\r\n * Create a new countdown timer panel.\r\n */\r\npublic CountdownTimerPanel() {\r\n    _actionListeners = new ArrayList();\r\n    // _startTime = -1L;\r\n    _display = new JLabel(\"0:00:00\", JLabel.RIGHT);\r\n    _display.setPreferredSize(new Dimension(CountdownTimerPanel._displayWidth, CountdownTimerPanel._displayHeight));\r\n    _display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    add(_display);\r\n}"},
 {"id":643, "name":"addActionListener(java.awt.event.ActionListener)", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.addActionListener(java.awt.event.ActionListener)", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}"},
 {"id":644, "name":"alignText()", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.alignText()", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"public void alignText() {\r\n    this._display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    this._display.setHorizontalAlignment(SwingConstants.CENTER);\r\n}"},
 {"id":645, "name":"display(long)", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.display(long)", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * \t\tThe current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, CountdownTimerPanel._displayWidth, CountdownTimerPanel._displayHeight);\r\n}"},
 {"id":646, "name":"getRemainingTime()", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.getRemainingTime()", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}"},
 {"id":647, "name":"notifyListeners(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.notifyListeners(java.awt.event.ActionEvent)", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * \t\tThe action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}"},
 {"id":648, "name":"run()", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.run()", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * The actual thread method.\r\n */\r\npublic void run() {\r\n    long startTime = System.currentTimeMillis();// The time when this run started.\r\n\r\n    long runningTime;\r\n    // The length of this run.\r\n    try {\r\n        // While theres still time left and noone stopped the thread.\r\n        do {\r\n            Thread.sleep(100);// Wait 1/10 of a second.\r\n\r\n            runningTime = (System.currentTimeMillis()) - startTime;\r\n            display(((_remainingTime) - runningTime));// decrease the time by a second and display it.\r\n\r\n        } while (((_remainingTime) >= runningTime) && ((Thread.currentThread()) == (_timerThread)) );\r\n        _remainingTime -= runningTime;// Substract the length of this thinking time.\r\n\r\n        // Now notify all the action listeners, that the timer has stopped.\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((_remainingTime) < 0L ? \"timeout\" : \"interrupted\")));\r\n    } catch (InterruptedException ignored) {\r\n    }\r\n}"},
 {"id":649, "name":"setCountdown(int)", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.setCountdown(int)", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * \t\tThe length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    // _startTime = -1L;\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}"},
 {"id":650, "name":"start()", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.start()", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * Start the timer.\r\n */\r\npublic void start() {\r\n    if ((_time) > 0L) {\r\n        // if( _startTime == -1L) {\r\n        // _startTime = System.currentTimeMillis();\r\n        // }\r\n        if ((_timerThread) == null) {\r\n            _timerThread = new Thread(this);\r\n            _timerThread.start();\r\n        }\r\n    }\r\n}"},
 {"id":651, "name":"stop()", "fullmethod":"de.java_chess.javaChess.renderer2d.CountdownTimerPanel.stop()", "ownerclassid":"88", "ownerclassname":"CountdownTimerPanel", "sourcecode":"/**\r\n * Stop the timer.\r\n */\r\npublic void stop() {\r\n    // If there is a running thread.\r\n    if ((_timerThread) != null) {\r\n        Thread timerThread = _timerThread;// Copy it.\r\n\r\n        _timerThread = null;\r\n        // Signal to stop the thread.\r\n        try {\r\n            timerThread.join();// And wait for the thread to end.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n}"},
 {"id":652, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.EnginePanel.-init-()", "ownerclassid":"89", "ownerclassname":"EnginePanel", "sourcecode":"/**\r\n * Standardconstructor\r\n */\r\npublic EnginePanel() {\r\n    super();\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":653, "name":"getText()", "fullmethod":"de.java_chess.javaChess.renderer2d.EnginePanel.getText()", "ownerclassid":"89", "ownerclassname":"EnginePanel", "sourcecode":"/**\r\n * Get the current text of the panel.\r\n *\r\n * @return The current text of the panel.\r\n */\r\npublic final String getText() {\r\n    return this.jtEngine.getText();\r\n}"},
 {"id":654, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.renderer2d.EnginePanel.jbInit()", "ownerclassid":"89", "ownerclassname":"EnginePanel", "sourcecode":"/**\r\n * Construction a la JBuilder to be able to use the JBuilder designer\r\n *\r\n * @throws Exception\r\n * \t\t\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagEngine);\r\n    this.jtEngine.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.jtEngine.setEditable(false);\r\n    this.jtEngine.setLineWrap(true);\r\n    this.jtEngine.setWrapStyleWord(true);\r\n    this.jScrollPane = new JScrollPane(this.jtEngine);\r\n    this.jlHeadline = new JLabel(\"Engine and debug output:\");\r\n    this.add(this.jScrollPane, new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(this.jlHeadline, new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    // ,GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n}"},
 {"id":655, "name":"modifyText(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.EnginePanel.modifyText(java.lang.String)", "ownerclassid":"89", "ownerclassname":"EnginePanel", "sourcecode":"/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * \t\tThe text to add\r\n */\r\npublic final void modifyText(String newText) {\r\n    String sCurrentText = getText();\r\n    if (!(sCurrentText.equals(\"\"))) {\r\n        setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtEngine.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        setText(newText);\r\n    }\r\n}"},
 {"id":656, "name":"setText(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.EnginePanel.setText(java.lang.String)", "ownerclassid":"89", "ownerclassname":"EnginePanel", "sourcecode":"/**\r\n * Set the current text of the engine panel.\r\n *\r\n * @param newText\r\n * \t\tThe new text to set.\r\n */\r\npublic final void setText(String newText) {\r\n    this.jtEngine.setText(newText);\r\n}"},
 {"id":657, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.GameTimerPanel.-init-()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"// Constructors\r\n/**\r\n * Create a new timer instance for a game.\r\n */\r\npublic GameTimerPanel() {\r\n    super();\r\n    // Create a new array for the action listeners.\r\n    _actionListeners = new ArrayList();\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":658, "name":"-init-(int)", "fullmethod":"de.java_chess.javaChess.GameTimerPanel.-init-(int)", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Create a given game timer with a countdown time.\r\n *\r\n * @param maxTime\r\n * \t\tThe remaining time.\r\n */\r\npublic GameTimerPanel(int maxTime) {\r\n    this();\r\n    setCountdown(maxTime);\r\n}"},
 {"id":659, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Get a event from one of the timers.\r\n *\r\n * ActionEvent event The event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    if (!(\"interrupted\".equals(event.getActionCommand()))) {\r\n        // This event means, that the timer sending the event has stopped,\r\n        // so stop the entire timer for now.\r\n        stop();\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((event.getSource()) == (_white) ? \"timeout white\" : \"timeout black\")));\r\n    }\r\n}"},
 {"id":660, "name":"addActionListener(java.awt.event.ActionListener)", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.addActionListener(java.awt.event.ActionListener)", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}"},
 {"id":661, "name":"isRunning()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.isRunning()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Get the active state of this timer.\r\n *\r\n * @return The active state of this timer.\r\n */\r\npublic boolean isRunning() {\r\n    return _running;\r\n}"},
 {"id":662, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.jbInit()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Construction a la JBuilder to be able to use JBuilder designer\r\n *\r\n * @throws Exception\r\n * \t\t\r\n */\r\nprivate void jbInit() throws Exception {\r\n    _white = new TimerPanel(false);\r\n    _white.addActionListener(this);\r\n    _black = new TimerPanel(false);\r\n    _black.addActionListener(this);\r\n    _white.setBackground(Color.white);\r\n    _white.alignText();\r\n    _black.setBackground(Color.white);\r\n    _black.alignText();\r\n    _white.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    _black.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    this.jlWhite.setText(\"White: \");\r\n    this.jlWhite.setForeground(Color.white);\r\n    jlWhite.setHorizontalAlignment(SwingConstants.CENTER);\r\n    this.jlBlack.setText(\"Black: \");\r\n    this.jlBlack.setForeground(Color.black);\r\n    jlBlack.setHorizontalAlignment(SwingConstants.CENTER);\r\n    // Layout the entire timer.\r\n    setLayout(new GridLayout(1, 4));\r\n    // Add the timers with a label for each of them\r\n    this.add(jlWhite, null);\r\n    add(_white);\r\n    this.add(jlBlack, null);\r\n    add(_black);\r\n}"},
 {"id":663, "name":"notifyListeners(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.notifyListeners(java.awt.event.ActionEvent)", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * \t\tThe action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}"},
 {"id":664, "name":"reset(int)", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.reset(int)", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"// Methods\r\n/**\r\n * Reset to a given time.\r\n *\r\n * @param time\r\n * \t\tThe time to reset to.\r\n */\r\npublic void reset(int time) {\r\n    stop();// Stop the timer.\r\n\r\n    setCountdown(time);\r\n    setNoClockRunning();\r\n}"},
 {"id":665, "name":"setBlackClockRunning()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.setBlackClockRunning()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"public void setBlackClockRunning() {\r\n    _white.setBackground(Color.lightGray);\r\n    _black.setBackground(Color.white);\r\n}"},
 {"id":666, "name":"setCountdown(int)", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.setCountdown(int)", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Set the remaining time for each timer.\r\n *\r\n * @param time\r\n * \t\tThe remaining time for each time.\r\n */\r\npublic void setCountdown(int time) {\r\n    _white.setCountdown(time);\r\n    _black.setCountdown(time);\r\n}"},
 {"id":667, "name":"setNoClockRunning()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.setNoClockRunning()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Set both timers inactive.\r\n */\r\npublic void setNoClockRunning() {\r\n    _white.setBackground(Color.white);\r\n    _black.setBackground(Color.white);\r\n}"},
 {"id":668, "name":"setRunning(boolean)", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.setRunning(boolean)", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Set the new running state of the timer.\r\n *\r\n * @param active\r\n * \t\tThe new state of the timer panel.\r\n */\r\npublic void setRunning(boolean active) {\r\n    _running = active;\r\n}"},
 {"id":669, "name":"setWhiteClockRunning()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.setWhiteClockRunning()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"public void setWhiteClockRunning() {\r\n    _white.setBackground(Color.white);\r\n    _black.setBackground(Color.lightGray);\r\n}"},
 {"id":670, "name":"start()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.start()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Start the game\r\n */\r\npublic void start() {\r\n    _black.start();\r\n    _whiteActive = false;\r\n    setBlackClockRunning();\r\n    setRunning(true);\r\n}"},
 {"id":671, "name":"stop()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.stop()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Stop the entire timer.\r\n */\r\npublic void stop() {\r\n    _white.stop();\r\n    _black.stop();\r\n    setRunning(false);\r\n}"},
 {"id":672, "name":"toggle()", "fullmethod":"de.java_chess.javaChess.renderer2d.GameTimerPanel.toggle()", "ownerclassid":"90", "ownerclassname":"GameTimerPanel", "sourcecode":"/**\r\n * Toggle the timer for one player to the other.\r\n */\r\npublic void toggle() {\r\n    if (_whiteActive) {\r\n        setBlackClockRunning();\r\n        _white.stop();\r\n        _black.start();\r\n    } else {\r\n        setWhiteClockRunning();\r\n        _black.stop();\r\n        _white.start();\r\n    }\r\n    _whiteActive = !(_whiteActive);\r\n}"},
 {"id":673, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.NavigationPanel.-init-()", "ownerclassid":"91", "ownerclassname":"NavigationPanel", "sourcecode":"/**\r\n * Standardconstructor\r\n */\r\npublic NavigationPanel() {\r\n    super();\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":674, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.renderer2d.NavigationPanel.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"91", "ownerclassname":"NavigationPanel", "sourcecode":"/**\r\n * React on mouseclick\r\n */\r\npublic void actionPerformed(ActionEvent ae) {\r\n    if (ae.getSource().equals(jbStart))\r\n        moveToStart();\r\n\r\n    if (ae.getSource().equals(jbBack))\r\n        moveOnePlyBack();\r\n\r\n    if (ae.getSource().equals(jbForward))\r\n        moveOnePlyForward();\r\n\r\n    if (ae.getSource().equals(jbEnd))\r\n        moveToEnd();\r\n\r\n}"},
 {"id":675, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.renderer2d.NavigationPanel.jbInit()", "ownerclassid":"91", "ownerclassname":"NavigationPanel", "sourcecode":"/**\r\n * Construction a la JBuilder to be able to use the JBuilder designer\r\n *\r\n * @throws Exception\r\n * \t\t\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagNavigation);\r\n    jbBack.setBackground(Color.white);\r\n    jbBack.setToolTipText(\"one ply back\");\r\n    jbStart.setBackground(Color.white);\r\n    jbStart.setToolTipText(\"to start position\");\r\n    jbForward.setBackground(Color.white);\r\n    jbForward.setToolTipText(\"one ply forward\");\r\n    jbEnd.setBackground(Color.white);\r\n    jbEnd.setToolTipText(\"to end position\");\r\n    URL urlBack = getClass().getResource(\"images/back03.gif\");\r\n    Image imBack = Toolkit.getDefaultToolkit().getImage(urlBack);\r\n    jbBack.setIcon(new ImageIcon(imBack));\r\n    URL urlStart = getClass().getResource(\"images/start03.gif\");\r\n    Image imStart = Toolkit.getDefaultToolkit().getImage(urlStart);\r\n    jbStart.setIcon(new ImageIcon(imStart));\r\n    URL urlForward = getClass().getResource(\"images/forward03.gif\");\r\n    Image imForward = Toolkit.getDefaultToolkit().getImage(urlForward);\r\n    jbForward.setIcon(new ImageIcon(imForward));\r\n    URL urlEnd = getClass().getResource(\"images/end03.gif\");\r\n    Image imEnd = Toolkit.getDefaultToolkit().getImage(urlEnd);\r\n    jbEnd.setIcon(new ImageIcon(imEnd));\r\n    // jbBack.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/back02.gif\"))));\r\n    // jbStart.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/start02.gif\"))));\r\n    // jbForward.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/forward02.gif\"))));\r\n    // jbEnd.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/end02.gif\"))));\r\n    jbBack.addActionListener(this);\r\n    jbStart.addActionListener(this);\r\n    jbForward.addActionListener(this);\r\n    jbEnd.addActionListener(this);\r\n    this.add(jbStart, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jbBack, new GridBagConstraints(1, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jbForward, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jbEnd, new GridBagConstraints(3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n}"},
 {"id":676, "name":"moveOnePlyBack()", "fullmethod":"de.java_chess.javaChess.renderer2d.NavigationPanel.moveOnePlyBack()", "ownerclassid":"91", "ownerclassname":"NavigationPanel", "sourcecode":"/**\r\n * Moves one half move back in the game history\r\n */\r\nprivate void moveOnePlyBack() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    // System.out.println( \"Einen Halbzug zur\ufffdck\" );\r\n}"},
 {"id":677, "name":"moveOnePlyForward()", "fullmethod":"de.java_chess.javaChess.renderer2d.NavigationPanel.moveOnePlyForward()", "ownerclassid":"91", "ownerclassname":"NavigationPanel", "sourcecode":"/**\r\n * Moves one half move forward in the game\r\n */\r\nprivate void moveOnePlyForward() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    System.out.println(\"Einen Halbzug vor\");\r\n}"},
 {"id":678, "name":"moveToEnd()", "fullmethod":"de.java_chess.javaChess.renderer2d.NavigationPanel.moveToEnd()", "ownerclassid":"91", "ownerclassname":"NavigationPanel", "sourcecode":"/**\r\n * Moves to the end position of the game\r\n */\r\nprivate void moveToEnd() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    System.out.println(\"Zum Partieende\");\r\n}"},
 {"id":679, "name":"moveToStart()", "fullmethod":"de.java_chess.javaChess.renderer2d.NavigationPanel.moveToStart()", "ownerclassid":"91", "ownerclassname":"NavigationPanel", "sourcecode":"/**\r\n * Moves to the beginning of the game\r\n */\r\nprivate void moveToStart() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    // System.out.println( \"Zum Partieanfang\" );\r\n}"},
 {"id":680, "name":"-init-(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.NotationPanel.-init-(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Standardconstructor\r\n */\r\npublic NotationPanel(GameNotation gameNotation) {\r\n    super();\r\n    // Store the game notation in this instance.\r\n    setGameNotation(gameNotation);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":681, "name":"actionPerformed(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.actionPerformed(java.awt.event.ActionEvent)", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"public void actionPerformed(ActionEvent e) {\r\n    boolean bWhiteOrBlack = true;\r\n    PlayerDialog playerDialog = null;\r\n    if (e.getSource().equals(jbWhite)) {\r\n        playerDialog = new PlayerDialog(1, getWhitePlayerName());\r\n        bWhiteOrBlack = true;\r\n    } else\r\n        if (e.getSource().equals(jbBlack)) {\r\n            playerDialog = new PlayerDialog(2, getBlackPlayerName());\r\n            bWhiteOrBlack = false;\r\n        }\r\n\r\n    if (playerDialog != null) {\r\n        Tools.setDialogToCenter(playerDialog);\r\n        playerDialog.show();\r\n        if (bWhiteOrBlack == true) {\r\n            jbWhite.setText(playerDialog.getNewName());\r\n        } else {\r\n            jbBlack.setText(playerDialog.getNewName());\r\n        }\r\n    }\r\n}"},
 {"id":682, "name":"getBlackPlayerName()", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.getBlackPlayerName()", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Returns the black players name\r\n *\r\n * @return The String for the black player\r\n */\r\npublic String getBlackPlayerName() {\r\n    return this.jbBlack.getText();\r\n}"},
 {"id":683, "name":"getWhitePlayerName()", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.getWhitePlayerName()", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Returns the white players name\r\n *\r\n * @return The String for the white player\r\n */\r\npublic String getWhitePlayerName() {\r\n    return this.jbWhite.getText();\r\n}"},
 {"id":684, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.jbInit()", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Construction a la JBuilder to be able to use JBuilder designer\r\n *\r\n * @throws Exception\r\n * \t\t\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagText);\r\n    this.jtNotation.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.jtNotation.setEditable(false);\r\n    this.jtNotation.setLineWrap(true);\r\n    this.jtNotation.setWrapStyleWord(true);\r\n    this.jScrollPane = new JScrollPane(this.jtNotation);\r\n    this.jlHeadline = new JLabel(\"Notation and game details:\");\r\n    jlHeadline.setFont(new Font(\"Dialog\", 1, 12));\r\n    jpPlayers.setLayout(gridBagLayout1);\r\n    jlWhite.setText(\"White:\");\r\n    try {\r\n        // Get the account of the user.\r\n        String username = System.getProperty(\"user.name\");\r\n        // Capitalize the name.\r\n        username = (Character.toUpperCase(username.charAt(0))) + (username.substring(1));\r\n        // Use it as the default player name.\r\n        setWhitePlayerName(username);\r\n    } catch (Exception e) {\r\n        setWhitePlayerName(\"white player name\");\r\n    }\r\n    // jbWhite.setText(\"white player name\");\r\n    jbWhite.setBackground(Color.white);\r\n    jbWhite.setForeground(Color.black);\r\n    jbWhite.setFocusPainted(false);\r\n    jbWhite.addActionListener(this);\r\n    jlBlack.setText(\"Black:\");\r\n    // jbBlack.setText(\"black player name\");\r\n    setBlackPlayerName(\"Java-Chess\");\r\n    jbBlack.setBackground(Color.black);\r\n    jbBlack.setForeground(Color.white);\r\n    jbBlack.setFocusPainted(false);\r\n    jbBlack.addActionListener(this);\r\n    this.add(jScrollPane, new GridBagConstraints(0, 2, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jlHeadline, new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jpPlayers, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    jpPlayers.add(jlWhite, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 4));\r\n    jpPlayers.add(jbWhite, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 5, 0, 5), 0, 0));\r\n    jpPlayers.add(jlBlack, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 5, 0, 0), 0, 0));\r\n    jpPlayers.add(jbBlack, new GridBagConstraints(3, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 5, 0, 5), 0, 0));\r\n}"},
 {"id":685, "name":"modifyText(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.modifyText(java.lang.String)", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * \t\tThe text to add\r\n */\r\npublic void modifyText(String newText) {\r\n    String sCurrentText = this.jtNotation.getText();\r\n    if ((sCurrentText.equals(\"\")) == false) {\r\n        this.jtNotation.setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtNotation.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        this.jtNotation.setText(newText);\r\n    }\r\n}"},
 {"id":686, "name":"setBlackPlayerName(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.setBlackPlayerName(java.lang.String)", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Sets the black players name\r\n *\r\n * @param newName\r\n * \t\tThe new string for the black player\r\n */\r\npublic void setBlackPlayerName(String newName) {\r\n    this.jbBlack.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, false);\r\n    }\r\n}"},
 {"id":687, "name":"setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.setGameNotation(de.java_chess.javaChess.notation.GameNotation)", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Set a new notation object.\r\n *\r\n * @param gameNotation\r\n * \t\tThe new game notation.\r\n */\r\npublic void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}"},
 {"id":688, "name":"setText(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.setText(java.lang.String)", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Set a new notation.\r\n *\r\n * @param newNotation\r\n * \t\tThe new notation.\r\n */\r\npublic void setText(String newNotation) {\r\n    this.jtNotation.setText(newNotation);\r\n}"},
 {"id":689, "name":"setWhitePlayerName(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.NotationPanel.setWhitePlayerName(java.lang.String)", "ownerclassid":"92", "ownerclassname":"NotationPanel", "sourcecode":"/**\r\n * Sets the white players name\r\n *\r\n * @param newName\r\n * \t\tThe new string for the white player\r\n */\r\npublic void setWhitePlayerName(String newName) {\r\n    this.jbWhite.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, true);\r\n    }\r\n}"},
 {"id":690, "name":"-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)", "fullmethod":"de.java_chess.javaChess.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)", "ownerclassid":"93", "ownerclassname":"PieceRenderer", "sourcecode":"// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * \t\tThe color of the piece.\r\n * @param piece\r\n * \t\tThe type of the piece.\r\n * @param set\r\n * \t\tThe set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}"},
 {"id":691, "name":"-init-(de.java_chess.javaChess.board.Board)", "fullmethod":"de.java_chess.javaChess.PiecesLayer.-init-(de.java_chess.javaChess.board.Board)", "ownerclassid":"94", "ownerclassname":"PiecesLayer", "sourcecode":"PiecesLayer(Board board) {\r\n    super(new GridLayout(8, 8));\r\n    _set = new ChessSet(this);\r\n    _animationLayer = new AnimationLayer(this);\r\n    _board = board;\r\n    int _boardSize = 8 * (ChessBoardRenderer2D.getSquareSize());\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    setOpaque(false);\r\n    repaintBoard();\r\n}"},
 {"id":692, "name":"clearBoard()", "fullmethod":"de.java_chess.javaChess.renderer2d.PiecesLayer.clearBoard()", "ownerclassid":"94", "ownerclassname":"PiecesLayer", "sourcecode":"final void clearBoard() {\r\n    // Create a renderer for each chessboard square\r\n    Position pos = new PositionImpl(0);// Avoid to create new position instances for each square\r\n\r\n    for (int s = 0; s < 64; s++) {\r\n        pos.setSquareIndex(s);\r\n        _square[s] = new PositionRenderer();\r\n    }\r\n    // Remove all the squares, in case this is a reset and the pieces layer already contains the\r\n    // squares of an existing board.\r\n    removeAll();\r\n    // The order of the component adding is different then the order of the chessboard squares.\r\n    // _square[0] = square a1 of the chessboard, but the components are added from the left\r\n    // upper square (= a8)\r\n    for (int s = 63; s >= 0; s--) {\r\n        add(_square[((s & (~7)) + (7 - (s & 7)))]);\r\n    }\r\n    repaint();\r\n}"},
 {"id":693, "name":"doPly(de.java_chess.javaChess.ply.Ply)", "fullmethod":"de.java_chess.javaChess.renderer2d.PiecesLayer.doPly(de.java_chess.javaChess.ply.Ply)", "ownerclassid":"94", "ownerclassname":"PiecesLayer", "sourcecode":"/**\r\n * Render a ply.\r\n *\r\n * @param ply\r\n * \t\tThe ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    if (_animatedMoves) {\r\n        getAnimationLayer().animatePly(ply);\r\n        getAnimationLayer().start();\r\n        repaint();\r\n    } else {\r\n        // Check, if it was a castling\r\n        if (ply instanceof CastlingPly) {\r\n            int source = ply.getSource().getSquareIndex();\r\n            if (((CastlingPly) (ply)).isLeftCastling()) {\r\n                _square[(source - 2)].getPieceFrom(_square[source]);\r\n                _square[(source - 1)].getPieceFrom(_square[(source - 4)]);// Move the rook to the right\r\n\r\n            } else {\r\n                _square[(source + 2)].getPieceFrom(_square[source]);\r\n                _square[(source + 1)].getPieceFrom(_square[(source + 3)]);// Move the rook to the left\r\n\r\n            }\r\n        } else {\r\n            // If a pawn has just reached the last row\r\n            if (ply instanceof TransformationPly) {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // Now change the rendering to the new piece type.\r\n                _square[ply.getDestination().getSquareIndex()].setIcon(new ImageIcon(new PieceRenderer(((ply.getDestination().getSquareIndex()) < 8 ? Piece.BLACK : Piece.WHITE), ((TransformationPly) (ply)).getTypeAfterTransformation(), _set, this)));\r\n            } else {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // If its a en passant ply, remove the attacked pawn.\r\n                if (ply instanceof EnPassantPly) {\r\n                    _square[((EnPassantPly) (ply)).getAttackedPosition().getSquareIndex()].setIcon(null);\r\n                }\r\n            }\r\n        }\r\n        repaint();\r\n    }\r\n}"},
 {"id":694, "name":"getAnimationLayer()", "fullmethod":"de.java_chess.javaChess.renderer2d.PiecesLayer.getAnimationLayer()", "ownerclassid":"94", "ownerclassname":"PiecesLayer", "sourcecode":"/**\r\n * Get the current animation layer.\r\n *\r\n * @return The current animation layer.\r\n */\r\nfinal AnimationLayer getAnimationLayer() {\r\n    return _animationLayer;\r\n}"},
 {"id":695, "name":"getPositionRenderer(int)", "fullmethod":"de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)", "ownerclassid":"94", "ownerclassname":"PiecesLayer", "sourcecode":"/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * \t\tThe index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}"},
 {"id":696, "name":"repaintBoard()", "fullmethod":"de.java_chess.javaChess.renderer2d.PiecesLayer.repaintBoard()", "ownerclassid":"94", "ownerclassname":"PiecesLayer", "sourcecode":"final void repaintBoard() {\r\n    // removeAll();\r\n    // Create a renderer for each chessboard square\r\n    Position pos = new PositionImpl(0);// Avoid to create new position instances for each square\r\n\r\n    for (int s = 0; s < 64; s++) {\r\n        pos.setSquareIndex(s);\r\n        Piece p = _board.getPiece(pos);\r\n        _square[s] = (p != null) ? new PositionRenderer(new PieceRenderer(p.getColor(), p.getType(), _set, this)) : new PositionRenderer();\r\n    }\r\n    // Remove all the squares, in case this is a reset and the pieces layer already contains the\r\n    // squares of an existing board.\r\n    removeAll();\r\n    // The order of the component adding is different then the order of the chessboard squares.\r\n    // _square[0] = square a1 of the chessboard, but the components are added from the left\r\n    // upper square (= a8)\r\n    for (int s = 63; s >= 0; s--) {\r\n        add(_square[((s & (~7)) + (7 - (s & 7)))]);\r\n    }\r\n    repaint();\r\n}"},
 {"id":697, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.PositionRenderer.-init-()", "ownerclassid":"95", "ownerclassname":"PositionRenderer", "sourcecode":"// Instance variables.\r\n// Constructors\r\n/**\r\n * Create a new position rendering for a empty position.\r\n */\r\nPositionRenderer() {\r\n    super();// Create a empty JLabel instance.\r\n\r\n    // Even if we do not have to render an image yet, it might\r\n    // get added later, when a piece moves on this square.\r\n    setHorizontalAlignment(SwingConstants.CENTER);\r\n    setVerticalAlignment(SwingConstants.CENTER);\r\n}"},
 {"id":698, "name":"-init-(java.awt.Image)", "fullmethod":"de.java_chess.javaChess.PositionRenderer.-init-(java.awt.Image)", "ownerclassid":"95", "ownerclassname":"PositionRenderer", "sourcecode":"/**\r\n * Create a new position rendering with a given image of a piece.\r\n *\r\n * image The image for the rendering.\r\n */\r\nPositionRenderer(Image image) {\r\n    super(new ImageIcon(image));\r\n}"},
 {"id":699, "name":"getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)", "fullmethod":"de.java_chess.javaChess.renderer2d.PositionRenderer.getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)", "ownerclassid":"95", "ownerclassname":"PositionRenderer", "sourcecode":"// Methods\r\n/**\r\n * Move a piece from another position to this one.\r\n *\r\n * positionRenderer The position renderer for the source.\r\n */\r\nvoid getPieceFrom(PositionRenderer positionRenderer) {\r\n    setIcon(positionRenderer.getIcon());\r\n    positionRenderer.setIcon(null);\r\n}"},
 {"id":700, "name":"setIcon(javax.swing.ImageIcon)", "fullmethod":"de.java_chess.javaChess.renderer2d.PositionRenderer.setIcon(javax.swing.ImageIcon)", "ownerclassid":"95", "ownerclassname":"PositionRenderer", "sourcecode":"/**\r\n * Set a new icon and align it properly.\r\n *\r\n * @param icon\r\n * \t\tThe new icon.\r\n */\r\npublic void setIcon(ImageIcon icon) {\r\n    super.setIcon(icon);\r\n    if (icon != null) {\r\n        invalidate();\r\n    } else {\r\n        revalidate();\r\n    }\r\n}"},
 {"id":701, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.StatusPanel.-init-()", "ownerclassid":"96", "ownerclassname":"StatusPanel", "sourcecode":"public StatusPanel() {\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":702, "name":"-init-(java.lang.String)", "fullmethod":"de.java_chess.javaChess.StatusPanel.-init-(java.lang.String)", "ownerclassid":"96", "ownerclassname":"StatusPanel", "sourcecode":"public StatusPanel(String sVersionNumber) {\r\n    this.sVersion = sVersionNumber;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"},
 {"id":703, "name":"jbInit()", "fullmethod":"de.java_chess.javaChess.renderer2d.StatusPanel.jbInit()", "ownerclassid":"96", "ownerclassname":"StatusPanel", "sourcecode":"/**\r\n * Die GUI nach Nomenklatur des JBuilder\r\n *\r\n * @throws Exception\r\n * \t\t\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagLayout);\r\n    jlAction.setBorder(BorderFactory.createLoweredBevelBorder());\r\n    this.jlStatus.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.jlStatus.setText(\" Your turn! \");\r\n    this.jlStatus.setForeground(Color.black);\r\n    this.jlStatus.setFont(this.textFont);\r\n    this.jlAction.setText(\"Placeholder for action(s) in progress\");\r\n    this.jlAction.setFont(this.textFont);\r\n    this.jlAction.setForeground(Color.black);\r\n    this.jlVersion.setBorder(BorderFactory.createLoweredBevelBorder());\r\n    this.jlVersion.setText((\"Version: \" + (this.sVersion)));\r\n    this.jlVersion.setFont(this.textFont);\r\n    this.jlVersion.setForeground(Color.black);\r\n    add(jlAction, new GridBagConstraints(0, 0, 1, 1, 0.6, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    add(jlStatus, new GridBagConstraints(1, 0, 1, 1, 0.2, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    add(jlVersion, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    setBackground(Color.lightGray);\r\n}"},
 {"id":704, "name":"setActionText(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.StatusPanel.setActionText(java.lang.String)", "ownerclassid":"96", "ownerclassname":"StatusPanel", "sourcecode":"public void setActionText(String newActionText) {\r\n    this.jlAction.setText(newActionText);\r\n}"},
 {"id":705, "name":"setStatusText(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.StatusPanel.setStatusText(java.lang.String)", "ownerclassid":"96", "ownerclassname":"StatusPanel", "sourcecode":"public void setStatusText(String newStatusText) {\r\n    this.jlStatus.setText(newStatusText);\r\n}"},
 {"id":706, "name":"setVersionInfo(java.lang.String)", "fullmethod":"de.java_chess.javaChess.renderer2d.StatusPanel.setVersionInfo(java.lang.String)", "ownerclassid":"96", "ownerclassname":"StatusPanel", "sourcecode":"public void setVersionInfo(String newVersionText) {\r\n    this.jlVersion.setText(newVersionText);\r\n}"},
 {"id":707, "name":"-init-(boolean)", "fullmethod":"de.java_chess.javaChess.TimerPanel.-init-(boolean)", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"// Constructors\r\n/**\r\n * Create a new timer panel.\r\n *\r\n * @param countdown\r\n * \t\tFlag to indicate, if we count downwards.\r\n */\r\npublic TimerPanel(boolean countdown) {\r\n    setCountingDirection(countdown);\r\n    _actionListeners = new ArrayList();\r\n    _display = new JLabel(\"0:00:00\", JLabel.RIGHT);\r\n    _display.setPreferredSize(new Dimension(TimerPanel._displayWidth, TimerPanel._displayHeight));\r\n    _display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    add(_display);\r\n}"},
 {"id":708, "name":"addActionListener(java.awt.event.ActionListener)", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.addActionListener(java.awt.event.ActionListener)", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}"},
 {"id":709, "name":"alignText()", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.alignText()", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"public void alignText() {\r\n    this._display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    this._display.setHorizontalAlignment(SwingConstants.CENTER);\r\n}"},
 {"id":710, "name":"display(long)", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.display(long)", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * \t\tThe current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    if (!(isCountdown())) {\r\n        time = (_time) - time;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, TimerPanel._displayWidth, TimerPanel._displayHeight);\r\n}"},
 {"id":711, "name":"getRemainingTime()", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.getRemainingTime()", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}"},
 {"id":712, "name":"isCountdown()", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.isCountdown()", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Check, if this timer counts downwards.\r\n *\r\n * @return true, if the counter counts downwards.\r\n */\r\nprivate final boolean isCountdown() {\r\n    return _countdown;\r\n}"},
 {"id":713, "name":"notifyListeners(java.awt.event.ActionEvent)", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.notifyListeners(java.awt.event.ActionEvent)", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * \t\tThe action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}"},
 {"id":714, "name":"run()", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.run()", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * The actual thread method.\r\n */\r\npublic void run() {\r\n    long startTime = System.currentTimeMillis();// The time when this run started.\r\n\r\n    long runningTime;\r\n    // The length of this run.\r\n    try {\r\n        // While theres still time left and noone stopped the thread.\r\n        do {\r\n            Thread.sleep(100);// Wait 1/10 of a second.\r\n\r\n            runningTime = (System.currentTimeMillis()) - startTime;\r\n            display(((_remainingTime) - runningTime));// decrease the time by a second and display it.\r\n\r\n        } while (((_remainingTime) >= runningTime) && ((Thread.currentThread()) == (_timerThread)) );\r\n        _remainingTime -= runningTime;// Substract the length of this thinking time.\r\n\r\n        // Now notify all the action listeners, that the timer has stopped.\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((_remainingTime) < 0L ? \"timeout\" : \"interrupted\")));\r\n    } catch (InterruptedException ignored) {\r\n    }\r\n}"},
 {"id":715, "name":"setCountdown(int)", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.setCountdown(int)", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * \t\tThe length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}"},
 {"id":716, "name":"setCountingDirection(boolean)", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.setCountingDirection(boolean)", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Set the counting direction.\r\n *\r\n * @param countdown\r\n * \t\tFlag to indicate, if we want a countdown.\r\n */\r\nprivate final void setCountingDirection(boolean countdown) {\r\n    _countdown = countdown;\r\n}"},
 {"id":717, "name":"start()", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.start()", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Start the timer.\r\n */\r\npublic void start() {\r\n    if ((_time) > 0L) {\r\n        if ((_timerThread) == null) {\r\n            _timerThread = new Thread(this);\r\n            _timerThread.start();\r\n        }\r\n    }\r\n}"},
 {"id":718, "name":"stop()", "fullmethod":"de.java_chess.javaChess.renderer2d.TimerPanel.stop()", "ownerclassid":"97", "ownerclassname":"TimerPanel", "sourcecode":"/**\r\n * Stop the timer.\r\n */\r\npublic void stop() {\r\n    // If there is a running thread.\r\n    if ((_timerThread) != null) {\r\n        Thread timerThread = _timerThread;// Copy it.\r\n\r\n        _timerThread = null;\r\n        // Signal to stop the thread.\r\n        try {\r\n            timerThread.join();// And wait for the thread to end.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n}"},
 {"id":719, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.JavaChessTest.-init-()", "ownerclassid":"98", "ownerclassname":"JavaChessTest", "sourcecode":"JavaChessTest() {\r\n}"},
 {"id":720, "name":"suite()", "fullmethod":"de.java_chess.javaChess.test.JavaChessTest.suite()", "ownerclassid":"98", "ownerclassname":"JavaChessTest", "sourcecode":"// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Create the main test suite.\r\n *\r\n * @return The main test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite.\r\n    TestSuite suite = new TestSuite();\r\n    // Add the test suite for the engine.\r\n    suite.addTest(ChessEngineTest.suite());\r\n    return suite;\r\n}"},
 {"id":721, "name":"addActionListener(java.awt.event.ActionListener)", "fullmethod":"de.java_chess.javaChess.timer.GameTimer.addActionListener(java.awt.event.ActionListener)", "ownerclassid":"99", "ownerclassname":"GameTimer", "sourcecode":"/**\r\n * Add a action listener to the timer.\r\n *\r\n * @param listener\r\n * \t\tThe action listener to add.\r\n */\r\nvoid addActionListener(ActionListener listener);"},
 {"id":722, "name":"isRunning()", "fullmethod":"de.java_chess.javaChess.timer.GameTimer.isRunning()", "ownerclassid":"99", "ownerclassname":"GameTimer", "sourcecode":"/**\r\n * Check if the timer is actually running.\r\n *\r\n * @return true, if the timer is active, false otherwise.\r\n */\r\nboolean isRunning();"},
 {"id":723, "name":"start()", "fullmethod":"de.java_chess.javaChess.timer.GameTimer.start()", "ownerclassid":"99", "ownerclassname":"GameTimer", "sourcecode":"// Methods\r\n/**\r\n * Start the entire timer.\r\n */\r\nvoid start();"},
 {"id":724, "name":"stop()", "fullmethod":"de.java_chess.javaChess.timer.GameTimer.stop()", "ownerclassid":"99", "ownerclassname":"GameTimer", "sourcecode":"/**\r\n * Stop the entire timer.\r\n */\r\nvoid stop();"},
 {"id":725, "name":"toggle()", "fullmethod":"de.java_chess.javaChess.timer.GameTimer.toggle()", "ownerclassid":"99", "ownerclassname":"GameTimer", "sourcecode":"/**\r\n * Toggle from one player to the other.\r\n */\r\nvoid toggle();"},
 {"id":726, "name":"-init-(java.lang.Object[],int)", "fullmethod":"de.java_chess.javaChess.ArrayStackIterator.-init-(java.lang.Object[],int)", "ownerclassid":"100", "ownerclassname":"ArrayStackIterator", "sourcecode":"// Constructors\r\n/**\r\n * Create a new iterator instance.\r\n *\r\n * @param items\r\n * \t\tThe array with the items.\r\n * @param nItems\r\n * \t\tThe number of items (since the array is most likely longer).\r\n */\r\npublic ArrayStackIterator(Object[] items, int nItems) {\r\n    _items = items;\r\n    _nItems = nItems;\r\n    _curElement = 0;\r\n}"},
 {"id":727, "name":"hasNext()", "fullmethod":"de.java_chess.javaChess.util.ArrayStackIterator.hasNext()", "ownerclassid":"100", "ownerclassname":"ArrayStackIterator", "sourcecode":"// Methods\r\n/**\r\n * Check, if there are more elements to iterate over.\r\n *\r\n * @return true, if there are more elements.\r\n */\r\npublic final boolean hasNext() {\r\n    return (_curElement) < (_nItems);\r\n}"},
 {"id":728, "name":"next()", "fullmethod":"de.java_chess.javaChess.util.ArrayStackIterator.next()", "ownerclassid":"100", "ownerclassname":"ArrayStackIterator", "sourcecode":"/**\r\n * Get the next elements from the collection.\r\n *\r\n * @return The next element from the collection.\r\n */\r\npublic final Object next() {\r\n    return _items[((_curElement)++)];\r\n}"},
 {"id":729, "name":"remove()", "fullmethod":"de.java_chess.javaChess.util.ArrayStackIterator.remove()", "ownerclassid":"100", "ownerclassname":"ArrayStackIterator", "sourcecode":"/**\r\n * Remove the returned object (just a dummy in this case).\r\n */\r\npublic final void remove() {\r\n    // Do nothing...\r\n}"},
 {"id":730, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.ResourceLoader.-init-()", "ownerclassid":"101", "ownerclassname":"ResourceLoader", "sourcecode":"// Constructors\r\n/**\r\n * Create a new loader instance.\r\n */\r\nprivate ResourceLoader() {\r\n    _locations = new ArrayList();\r\n}"},
 {"id":731, "name":"addLocation(java.lang.String)", "fullmethod":"de.java_chess.javaChess.util.ResourceLoader.addLocation(java.lang.String)", "ownerclassid":"101", "ownerclassname":"ResourceLoader", "sourcecode":"/**\r\n * Add a new location to load resources from.\r\n *\r\n * @param location\r\n * \t\tThe location to use.\r\n */\r\npublic final void addLocation(String location) {\r\n    if (!(location.endsWith(\"/\"))) {\r\n        location += \"/\";\r\n    }\r\n    _locations.add(location);\r\n}"},
 {"id":732, "name":"getInstance()", "fullmethod":"de.java_chess.javaChess.util.ResourceLoader.getInstance()", "ownerclassid":"101", "ownerclassname":"ResourceLoader", "sourcecode":"// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final ResourceLoader getInstance() {\r\n    if ((ResourceLoader._instance) == null) {\r\n        ResourceLoader._instance = new ResourceLoader();\r\n    }\r\n    return ResourceLoader._instance;\r\n}"},
 {"id":733, "name":"loadImage(java.lang.String)", "fullmethod":"de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)", "ownerclassid":"101", "ownerclassname":"ResourceLoader", "sourcecode":"/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}"},
 {"id":734, "name":"-init-(int,int)", "fullmethod":"de.java_chess.javaChess.StringTextDocument.-init-(int,int)", "ownerclassid":"102", "ownerclassname":"StringTextDocument", "sourcecode":"/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * \t\tThe number of allowed character to enter in the JTextField\r\n */\r\npublic StringTextDocument(int type, int characterCount) {\r\n    super();\r\n    iCharacterCount = characterCount;\r\n    iType = type;\r\n}"},
 {"id":735, "name":"canBecomeValid(java.lang.String)", "fullmethod":"de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)", "ownerclassid":"102", "ownerclassname":"StringTextDocument", "sourcecode":"/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * \t\tThe string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}"},
 {"id":736, "name":"insertString(int,java.lang.String,javax.swing.text.AttributeSet)", "fullmethod":"de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)", "ownerclassid":"102", "ownerclassname":"StringTextDocument", "sourcecode":"/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * \t\tThe number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * \t\tFlag whether the string to enter has to be parsed for\r\n * \t\tnumbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}"},
 {"id":737, "name":"isValid(java.lang.String)", "fullmethod":"de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)", "ownerclassid":"102", "ownerclassname":"StringTextDocument", "sourcecode":"/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * \t\tThe string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"},
 {"id":738, "name":"isValidLine(char)", "fullmethod":"de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)", "ownerclassid":"102", "ownerclassname":"StringTextDocument", "sourcecode":"/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * \t\tThe character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"},
 {"id":739, "name":"isValidSquare(java.lang.String,boolean)", "fullmethod":"de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)", "ownerclassid":"102", "ownerclassname":"StringTextDocument", "sourcecode":"/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * \t\tThe string to parse\r\n * @param bEnPassantSquare\r\n * \t\tFlag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"},
 {"id":740, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.Tools.-init-()", "ownerclassid":"103", "ownerclassname":"Tools", "sourcecode":"public Tools() {\r\n}"},
 {"id":741, "name":"setDialogToCenter(javax.swing.JDialog)", "fullmethod":"de.java_chess.javaChess.util.Tools.setDialogToCenter(javax.swing.JDialog)", "ownerclassid":"103", "ownerclassname":"Tools", "sourcecode":"/**\r\n * Sets the Dialog to the center of the screen\r\n *\r\n * @param dialog\r\n * \t\tThe dialog which is to be centered on the screen\r\n */\r\npublic static void setDialogToCenter(JDialog dialog) {\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    Dimension dialogSize = dialog.getSize();\r\n    dialog.setLocation((((screenSize.width) - (dialogSize.width)) / 2), (((screenSize.height) - (dialogSize.height)) / 2));\r\n}"},
 {"id":742, "name":"-init-()", "fullmethod":"de.java_chess.javaChess.UnsynchronizedArrayStack.-init-()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"// Constructors\r\n/**\r\n * Create a new stack instance.\r\n */\r\npublic UnsynchronizedArrayStack() {\r\n    this(30);\r\n}"},
 {"id":743, "name":"-init-(int)", "fullmethod":"de.java_chess.javaChess.UnsynchronizedArrayStack.-init-(int)", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Create a new stack instance with a given initial\r\n * capacity.\r\n *\r\n * @param capacity\r\n * \t\tThe initial capacity.\r\n */\r\npublic UnsynchronizedArrayStack(int capacity) {\r\n    _nItems = 0;\r\n    _items = new Object[capacity];\r\n}"},
 {"id":744, "name":"clear()", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.clear()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Remove all the elements of the stack.\r\n */\r\npublic final void clear() {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        _items[i] = null;\r\n    }\r\n    _nItems = 0;\r\n}"},
 {"id":745, "name":"empty()", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.empty()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"// Methods\r\n/**\r\n * Test, if this stack is empty.\r\n *\r\n * @return true, if the stack is empty. False otherwise.\r\n */\r\npublic final boolean empty() {\r\n    return (_nItems) == 0;\r\n}"},
 {"id":746, "name":"increaseCapacity()", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.increaseCapacity()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Increase the capacity of the stack.\r\n */\r\nprivate final void increaseCapacity() {\r\n    // Create a new bigger array.\r\n    Object[] newStack = new Object[(_items.length) + (_incSize)];\r\n    // Copy the content of the old array to the new one.\r\n    System.arraycopy(_items, 0, newStack, 0, _nItems);\r\n    // Set the new array.\r\n    _items = newStack;\r\n}"},
 {"id":747, "name":"iterator()", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.iterator()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Get a iterator for the elements of this stack.\r\n *\r\n * @return A iterator for the elements of this stack.\r\n */\r\npublic final Iterator iterator() {\r\n    return new ArrayStackIterator(_items, _nItems);\r\n}"},
 {"id":748, "name":"peek()", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.peek()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Look at the object, that is at the top of the stack without removing it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object peek() {\r\n    return empty() ? null : _items[((_nItems) - 1)];\r\n}"},
 {"id":749, "name":"pop()", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.pop()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Remove the object at the top of the stack and return it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object pop() {\r\n    if (!(empty())) {\r\n        Object item = _items[(--(_nItems))];\r\n        _items[_nItems] = null;\r\n        return item;\r\n    }\r\n    return null;\r\n}"},
 {"id":750, "name":"push(java.lang.Object)", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.push(java.lang.Object)", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Push an item on the stack.\r\n *\r\n * @param item\r\n * \t\tThe item to push on the stack.\r\n */\r\npublic final void push(Object item) {\r\n    try {\r\n        _items[_nItems] = item;\r\n        (_nItems)++;\r\n    } catch (ArrayIndexOutOfBoundsException ae) {\r\n        increaseCapacity();\r\n        push(item);\r\n    }\r\n}"},
 {"id":751, "name":"search(java.lang.Object)", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"},
 {"id":752, "name":"size()", "fullmethod":"de.java_chess.javaChess.util.UnsynchronizedArrayStack.size()", "ownerclassid":"104", "ownerclassname":"UnsynchronizedArrayStack", "sourcecode":"/**\r\n * Get the current number of elements on the stack.\r\n *\r\n * @param The\r\n * \t\tcurrent size of the stack.\r\n */\r\npublic final int size() {\r\n    return _nItems;\r\n}"}]