-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: new_databasechess
-- ------------------------------------------------------
-- Server version	8.0.11

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `methods`
--

DROP TABLE IF EXISTS `methods`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `methods` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` longtext,
  `fullmethod` longtext,
  `ownerclassid` longtext,
  `ownerclassname` longtext,
  `sourcecode` longtext,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=759 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `methods`
--

LOCK TABLES `methods` WRITE;
/*!40000 ALTER TABLE `methods` DISABLE KEYS */;
INSERT INTO `methods` VALUES (1,'-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)','de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)','1','GameController','// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(2,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.GameController.actionPerformed(java.awt.event.ActionEvent)','1','GameController','/**\r\n * Process a event, that we are listening to.\r\n *\r\n * @param event\r\n * 		The event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    System.out.println((\"Got event \" + (event.getActionCommand())));\r\n    // If the timer fired the event, check for timeout.\r\n    if ((event.getSource()) == (getGameTimer())) {\r\n        String command = event.getActionCommand();\r\n        if (\"timeout white\".equals(command)) {\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for you! I win!\");\r\n        }\r\n        if (\"timeout black\".equals(command)) {\r\n            System.out.println(\"Black timeout!\");\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for me! You win!\");\r\n        }\r\n    }\r\n}'),(3,'computerPly()','de.java_chess.javaChess.GameController.computerPly()','1','GameController','/**\r\n * Let the computer make a move.\r\n */\r\npublic final boolean computerPly() {\r\n    Ply nextPly = getEngine().computeBestPly();\r\n    if (nextPly == null) {\r\n        System.out.println(\"No computer move returned\");\r\n        return false;\r\n    } else {\r\n        doPly(nextPly);\r\n        getEngine().startPermanentBrain();\r\n        return true;\r\n    }\r\n}'),(4,'convertUserPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)','1','GameController','/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(5,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.GameController.doPly(de.java_chess.javaChess.ply.Ply)','1','GameController','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to do.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    // If the game is over, stop here.\r\n    if ((_gameState) == (GameState.TIMEOUT)) {\r\n        return;\r\n    }\r\n    // Store the ply notation to set the check flags a bit later, since they are computed in the gameOver()\r\n    // call in the move right toggle.\r\n    PlyNotation plyNotation = new PlyNotationImpl(ply, getBoard().getPiece(ply.getSource()));\r\n    getGame().doPly(ply);\r\n    getBoard().doPly(ply);\r\n    getRenderer().doPly(ply);\r\n    // Now try to get some info on the current game state.\r\n    boolean gameOver = gameOver((!(_moveRight)));\r\n    // Set check info for this ply.\r\n    if ((_gameState) == (GameState.CHECKMATE)) {\r\n        plyNotation.setCheckMate(true);\r\n    } else {\r\n        if ((_gameState) == (GameState.CHECK)) {\r\n            plyNotation.setCheck(true);\r\n        }\r\n    }\r\n    // Add the ply to the notation.\r\n    getGameNotation().addPly(plyNotation);\r\n    if (gameOver) {\r\n        getGameTimer().stop();// The game has ended.\r\n\r\n        if ((_gameState) == (GameState.DRAW)) {\r\n            signalGameOver(\"Draw! Use File -> Reset to play again!\");\r\n        } else {\r\n            signalGameOver(((_moveRight) == (_computerIsWhite) ? \"Checkmate! I win! :-)\" : \"Checkmate! I lose... :-(\"));\r\n        }\r\n    } else {\r\n        toggleMoveRight();\r\n    }\r\n}'),(6,'gameOver(boolean)','de.java_chess.javaChess.GameController.gameOver(boolean)','1','GameController','/**\r\n * Check if the game is over.\r\n *\r\n * @param white\r\n * 		True, if white is about to move.\r\n * @return true, if the game is over.\r\n */\r\nprivate final boolean gameOver(boolean white) {\r\n    _gameState = getEngine().getCurrentGameState(white);\r\n    return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW));\r\n}'),(7,'getBoard()','de.java_chess.javaChess.GameController.getBoard()','1','GameController','/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal Board getBoard() {\r\n    return _board;\r\n}'),(8,'getEngine()','de.java_chess.javaChess.GameController.getEngine()','1','GameController','/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nfinal ChessEngine getEngine() {\r\n    return _engine;\r\n}'),(9,'getGame()','de.java_chess.javaChess.GameController.getGame()','1','GameController','// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(10,'getGameNotation()','de.java_chess.javaChess.GameController.getGameNotation()','1','GameController','/**\r\n * Get the current game notation.\r\n *\r\n * @return The current game notation.\r\n */\r\npublic final GameNotation getGameNotation() {\r\n    return _gameNotation;\r\n}'),(11,'getGameTimer()','de.java_chess.javaChess.GameController.getGameTimer()','1','GameController','/**\r\n * Get the current game timer.\r\n *\r\n * @return The current game timer.\r\n */\r\nfinal GameTimer getGameTimer() {\r\n    return _gameTimer;\r\n}'),(12,'getRenderer()','de.java_chess.javaChess.GameController.getRenderer()','1','GameController','/**\r\n * Get the renderer.\r\n *\r\n * @return The current renderer.\r\n */\r\nfinal ChessBoardRenderer getRenderer() {\r\n    return _renderer;\r\n}'),(13,'reset()','de.java_chess.javaChess.GameController.reset()','1','GameController','/**\r\n * Reset the game controller.\r\n */\r\npublic final void reset() {\r\n    _moveRight = true;\r\n    // White has the first move.\r\n    _gameState = GameState.STOPPED;// The game is stopped until white moves.\r\n\r\n}'),(14,'setBoard(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.GameController.setBoard(de.java_chess.javaChess.board.Board)','1','GameController','/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nfinal void setBoard(Board board) {\r\n    _board = board;\r\n}'),(15,'setEngine(de.java_chess.javaChess.engine.ChessEngine)','de.java_chess.javaChess.GameController.setEngine(de.java_chess.javaChess.engine.ChessEngine)','1','GameController','/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * 		The new engine.\r\n */\r\nfinal void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}'),(16,'setGame(de.java_chess.javaChess.game.Game)','de.java_chess.javaChess.GameController.setGame(de.java_chess.javaChess.game.Game)','1','GameController','/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(17,'setGameNotation(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.GameController.setGameNotation(de.java_chess.javaChess.notation.GameNotation)','1','GameController','/**\r\n * Set the current game notation.\r\n *\r\n * @param gameNotation\r\n * 		The new game notation.\r\n */\r\npublic final void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}'),(18,'setGameTimer(de.java_chess.javaChess.timer.GameTimer)','de.java_chess.javaChess.GameController.setGameTimer(de.java_chess.javaChess.timer.GameTimer)','1','GameController','/**\r\n * Set a new game timer.\r\n *\r\n * @param timer\r\n * 		The new game timer.\r\n */\r\nfinal void setGameTimer(GameTimer timer) {\r\n    _gameTimer = timer;\r\n    timer.addActionListener(this);\r\n}'),(19,'setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)','de.java_chess.javaChess.GameController.setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)','1','GameController','/**\r\n * Set a new renderer.\r\n *\r\n * @param renderer\r\n * 		The new renderer.\r\n */\r\nfinal void setRenderer(ChessBoardRenderer renderer) {\r\n    _renderer = renderer;\r\n}'),(20,'signalGameOver(java.lang.String)','de.java_chess.javaChess.GameController.signalGameOver(java.lang.String)','1','GameController','/**\r\n * Signal the end if the game.\r\n *\r\n * @param gameOverMessage\r\n * 		Some info how and why the game has ended.\r\n */\r\npublic final void signalGameOver(String gameOverMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, gameOverMessage, \"Game over\", JOptionPane.INFORMATION_MESSAGE);\r\n}'),(21,'signalUserInputError(java.lang.String)','de.java_chess.javaChess.GameController.signalUserInputError(java.lang.String)','1','GameController','/**\r\n * Signal a input error to the user.\r\n *\r\n * @param errorMessage\r\n * 		More information on the error.\r\n */\r\npublic final void signalUserInputError(String errorMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, errorMessage, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n}'),(22,'toggleMoveRight()','de.java_chess.javaChess.GameController.toggleMoveRight()','1','GameController','/**\r\n * Turn the right to move from one player to the other.\r\n */\r\npublic void toggleMoveRight() {\r\n    _moveRight = !(_moveRight);\r\n    if (getGameTimer().isRunning()) {\r\n        getGameTimer().toggle();\r\n    } else {\r\n        getGameTimer().start();\r\n        _gameState = GameState.ONGOING;// Change the game state to running.\r\n\r\n    }\r\n    // Check if the computer has the next move.\r\n    if ((_moveRight) == (_computerIsWhite)) {\r\n        if (!(computerPly())) {\r\n            System.out.println(\"Computer cannot move!\");\r\n        }\r\n    }\r\n}'),(23,'userPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.GameController.userPly(de.java_chess.javaChess.ply.Ply)','1','GameController','/**\r\n * The user moved a piece.\r\n *\r\n * @param ply\r\n * 		The ply of the user.\r\n */\r\npublic final void userPly(Ply ply) {\r\n    // Before any user ply can be applied, we have to stop\r\n    // the permanent brain, so the engine is free to process\r\n    // the user ply.\r\n    getEngine().stopPermanentBrain();\r\n    // plyInterpretation\r\n    ply = convertUserPly(ply);\r\n    // Check if the user has the right to move a piece\r\n    // and made a valid move.\r\n    if ((_moveRight) != (_computerIsWhite)) {\r\n        if ((((_gameState) != (GameState.CHECKMATE)) && ((_gameState) != (GameState.DRAW))) && ((_gameState) != (GameState.TIMEOUT))) {\r\n            if (getEngine().validateUserPly(ply)) {\r\n                doPly(ply);// Ok => move the piece.\r\n\r\n            } else {\r\n                // The user had to right to move or made an invalid move.\r\n                signalUserInputError(\"invalid move\");\r\n            }\r\n        } else {\r\n            signalUserInputError(\"game is already over\");\r\n        }\r\n    } else {\r\n        signalUserInputError(\"user is not about to move\");\r\n    }\r\n}'),(24,'-init-()','de.java_chess.javaChess.JavaChess.-init-()','3','JavaChess','1() {\r\n}'),(25,'busy()','de.java_chess.javaChess.JavaChess.busy()','3','JavaChess','private void busy() {\r\n    glasspane.requestFocus();\r\n    glasspane.setVisible(true);\r\n}'),(26,'engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)','de.java_chess.javaChess.JavaChess.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)','3','JavaChess','public void engineStatusChanged(ChessEngineImpl engine) {\r\n    if ((this.jpStatus) != null) {\r\n        this.jpStatus.setActionText(engine.getStatusDisplayString());\r\n    }\r\n}'),(27,'free()','de.java_chess.javaChess.JavaChess.free()','3','JavaChess','private void free() {\r\n    glasspane.setVisible(false);\r\n}'),(28,'getInstance()','de.java_chess.javaChess.JavaChess.getInstance()','3','JavaChess','/**\r\n * Get the instance of this chess app.\r\n *\r\n * @return The instance of this chess app.\r\n */\r\npublic static final JavaChess getInstance() {\r\n    return JavaChess._instance;\r\n}'),(29,'getMenuItem(de.java_chess.javaChess.action.JavaChessAction)','de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)','3','JavaChess','/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * 		The action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}'),(30,'jbInit()','de.java_chess.javaChess.JavaChess.jbInit()','3','JavaChess','/**\r\n * Die GUI nach Nomenklatur des JBuilder\r\n *\r\n * @throws Exception\r\n * 		\r\n */\r\nprivate void jbInit() throws Exception {\r\n    // Add some location for resources to the resource loader.\r\n    ResourceLoader.getInstance().addLocation(\"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/\");\r\n    _game = new GameImpl();\r\n    _gameNotation = new GameNotationImpl();\r\n    _board = new BitBoardImpl();\r\n    _engine = new ChessEngineImpl(_game, _gameNotation, _board, false);\r\n    ((ChessEngineImpl) (_engine)).addEngineStatusListener(this);\r\n    // Create a timer with 40 min for each player.\r\n    _gameTimer = new GameTimerPanel((40 * 60));\r\n    _controller = new GameController(_game, _gameNotation, _engine, _board, _gameTimer);\r\n    _renderer = new ChessBoardRenderer2D(_controller, _board);\r\n    _controller.setRenderer(_renderer);\r\n    editMenu = new EditMenu();\r\n    this.jpNotation = new NotationPanel(_gameNotation);\r\n    ((GameNotationImpl) (_gameNotation)).setNotationPanel(jpNotation);\r\n    editMenu.setNotationPanel(jpNotation);\r\n    this.jpEngine = new EnginePanel();\r\n    ((ChessEngineImpl) (_engine)).setEnginePanel(jpEngine);\r\n    ((ChessEngineImpl) (_engine)).setStatusPanel(jpStatus);\r\n    this.jpNavigation = new NavigationPanel();\r\n    // setIconImage(Toolkit.getDefaultToolkit().createImage(VisFrame.class.getResource(\"jclogo.gif\")));\r\n    contentPane = ((JPanel) (this.getContentPane()));\r\n    contentPane.setLayout(new GridBagLayout());\r\n    this.setSize(new Dimension(800, 600));\r\n    this.addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent e) {\r\n            this_windowClosing(e);\r\n        }\r\n    });\r\n    JMenuBar menuBar = new JMenuBar();\r\n    JMenu fileMenu = new JMenu(\"File\");\r\n    fileMenu.setMnemonic(KeyEvent.VK_F);// Shortcut Alt-F\r\n\r\n    fileMenu.add(getMenuItem(new ResetGameAction()));\r\n    fileMenu.addSeparator();\r\n    fileMenu.add(getMenuItem(new LoadGameAction()));\r\n    fileMenu.addSeparator();\r\n    fileMenu.add(getMenuItem(new SaveGameAction(_gameNotation)));\r\n    fileMenu.add(getMenuItem(new SaveGameAsAction(_gameNotation)));\r\n    _exitItem = new JMenuItem(\"Exit\");\r\n    // Shortcut f�r ALT-X zum Beenden:\r\n    this._exitItem.setAccelerator(KeyStroke.getKeyStroke(88, KeyEvent.ALT_MASK, false));\r\n    _exitItem.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            System.exit(0);\r\n        }\r\n    });\r\n    // Create a separated exit item\r\n    fileMenu.addSeparator();\r\n    this.jpBrett.setLayout(gridBagBrett);\r\n    // this.jpBrett.setPreferredSize( new Dimension(520,520) );\r\n    // this.jpBrett.setMaximumSize( new Dimension(520,520) );\r\n    // this.jpBrett.setMinimumSize( new Dimension(520,520) );\r\n    this.jpBrett.setPreferredSize(new Dimension(430, 430));\r\n    // this.jpBrett.setMaximumSize( new Dimension(400,400) );\r\n    this.jpBrett.setMinimumSize(new Dimension(430, 430));\r\n    this.jpStatus.setPreferredSize(new Dimension(780, 20));\r\n    this.jpStatus.setMinimumSize(new Dimension(780, 20));\r\n    this.jpStatus.setMaximumSize(new Dimension(780, 20));\r\n    this.jpEngine.setPreferredSize(new Dimension(780, 150));\r\n    this.jpEngine.setMinimumSize(new Dimension(780, 150));\r\n    this.jpEngine.setMaximumSize(new Dimension(780, 150));\r\n    this.jpNavigation.setLayout(gridBagNavigation);\r\n    fileMenu.add(_exitItem);\r\n    // Add the file menu to the menu bar.\r\n    menuBar.add(fileMenu);\r\n    // Get the Edit menu from the according class and add to the menu bar.\r\n    menuBar.add(editMenu.getMenu());\r\n    // Get the menu from the chess engine and add it to the menu bar.\r\n    menuBar.add(_engine.getMenu());\r\n    this.engineStatusChanged(((ChessEngineImpl) (_engine)));\r\n    // Create and add a help menu\r\n    JMenu helpMenu = new JMenu(\"Help\");\r\n    helpMenu.add(new HelpAction());\r\n    helpMenu.addSeparator();\r\n    helpMenu.add(new AboutAction());\r\n    menuBar.add(Box.createHorizontalGlue());// Move the help menu to the right.\r\n\r\n    menuBar.add(helpMenu);\r\n    // Create and set the menu.\r\n    this.setJMenuBar(menuBar);\r\n    contentPane.setForeground(Color.black);\r\n    contentPane.add(jpBrett, new GridBagConstraints(0, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));// Brett\r\n\r\n    contentPane.add(_gameTimer, new GridBagConstraints(1, 1, 1, 1, 1.0, 0.0, GridBagConstraints.NORTH, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));// The Clock\r\n\r\n    contentPane.add(jpEngine, new GridBagConstraints(0, 2, 2, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(2, 2, 2, 2), 0, 0));// Engineoutput\r\n\r\n    contentPane.add(jpStatus, new GridBagConstraints(0, 3, 2, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(2, 2, 2, 2), 0, 0));// Statuszeile\r\n\r\n    contentPane.add(jpNotation, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(2, 2, 2, 2), 0, 0));\r\n    contentPane.add(jpNavigation, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));// Notation etc.\r\n\r\n    jpBrett.add(((ChessBoardRenderer2D) (_renderer)), new GridBagConstraints(0, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    jpBrett.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.pack();\r\n    this.setVisible(true);\r\n}'),(31,'main(java.lang.String[])','de.java_chess.javaChess.JavaChess.main(java.lang.String[])','3','JavaChess','// Methods\r\n/**\r\n * The main method.\r\n *\r\n * @param args\r\n * 		The commandline arguments.\r\n */\r\npublic static void main(String[] args) {\r\n    JavaChess._instance = new JavaChess();\r\n}'),(32,'packFrame()','de.java_chess.javaChess.JavaChess.packFrame()','3','JavaChess','private Dimension packFrame() {\r\n    boolean packFrame = true;\r\n    if (packFrame) {\r\n        pack();\r\n    } else {\r\n        validate();\r\n    }\r\n    return this.getSize();\r\n}'),(33,'placeFrame(java.awt.Dimension,java.awt.Dimension)','de.java_chess.javaChess.JavaChess.placeFrame(java.awt.Dimension,java.awt.Dimension)','3','JavaChess','private void placeFrame(Dimension screenSize, Dimension frameSize) {\r\n    setLocation((((screenSize.width) - (frameSize.width)) / 2), (((screenSize.height) - (frameSize.height)) / 2));\r\n}'),(34,'reset()','de.java_chess.javaChess.JavaChess.reset()','3','JavaChess','/**\r\n * Reset the game.\r\n */\r\npublic void reset() {\r\n    // Reset all the game components.\r\n    _game.reset();\r\n    _gameNotation.reset();\r\n    _board.initialPosition();\r\n    _engine.reset();\r\n    // Reset the timer to 40 min for each player.\r\n    _gameTimer.reset((40 * 60));\r\n    _controller.reset();\r\n    _renderer.reset();\r\n}'),(35,'setDefaultFrameCoordinates()','de.java_chess.javaChess.JavaChess.setDefaultFrameCoordinates()','3','JavaChess','private void setDefaultFrameCoordinates() {\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    Dimension frameSize = packFrame();\r\n    setFrameSize(screenSize, frameSize);\r\n    placeFrame(screenSize, frameSize);\r\n}'),(36,'setFrameSize(java.awt.Dimension,java.awt.Dimension)','de.java_chess.javaChess.JavaChess.setFrameSize(java.awt.Dimension,java.awt.Dimension)','3','JavaChess','private void setFrameSize(Dimension screenSize, Dimension frameSize) {\r\n    if ((frameSize.height) > (screenSize.height)) {\r\n        frameSize.height = screenSize.height;\r\n    }\r\n    if ((frameSize.width) > (screenSize.width)) {\r\n        frameSize.width = screenSize.width;\r\n    }\r\n}'),(37,'this_windowClosing(java.awt.event.WindowEvent)','de.java_chess.javaChess.JavaChess.this_windowClosing(java.awt.event.WindowEvent)','3','JavaChess','/**\r\n * If Java-Chess is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * 		The Window event\r\n */\r\nvoid this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}'),(38,'-init-()','de.java_chess.javaChess.action.AboutAction.-init-()','4','AboutAction','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic AboutAction() {\r\n    super(\"About\");\r\n}'),(39,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.action.AboutAction.actionPerformed(java.awt.event.ActionEvent)','4','AboutAction','// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    DialogAbout dialog = DialogAbout.getInstance();\r\n    if (dialog != null) {\r\n        Tools.setDialogToCenter(dialog);\r\n        dialog.show();\r\n    }\r\n}'),(40,'-init-()','de.java_chess.javaChess.action.HelpAction.-init-()','5','HelpAction','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic HelpAction() {\r\n    super(\"Help\");\r\n}'),(41,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.action.HelpAction.actionPerformed(java.awt.event.ActionEvent)','5','HelpAction','// Methods\r\n/**\r\n * The action action.\r\n *\r\n * @param event\r\n * 		The event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Just a dummy so far...\r\n}'),(42,'-init-(java.lang.String)','de.java_chess.javaChess.action.JavaChessAction.-init-(java.lang.String)','6','JavaChessAction','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new Java-Chess action.\r\n *\r\n * @param name\r\n * 		The name of the action.\r\n */\r\npublic JavaChessAction(String name) {\r\n    super(name);\r\n    putValue(Action.SHORT_DESCRIPTION, name);\r\n}'),(43,'getName()','de.java_chess.javaChess.action.JavaChessAction.getName()','6','JavaChessAction','/**\r\n * Get the name of this action (which is currently the short description).\r\n *\r\n * @return The name of this action.\r\n */\r\npublic final String getName() {\r\n    return getShortDescription();\r\n}'),(44,'getShortDescription()','de.java_chess.javaChess.action.JavaChessAction.getShortDescription()','6','JavaChessAction','// Methods\r\n/**\r\n * Get the short description (the name) of this action.\r\n *\r\n * @return The short description of this action.\r\n */\r\npublic String getShortDescription() {\r\n    return ((String) (getValue(Action.SHORT_DESCRIPTION)));\r\n}'),(45,'-init-()','de.java_chess.javaChess.action.LoadGameAction.-init-()','7','LoadGameAction','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic LoadGameAction() {\r\n    super(\"Load game\");\r\n}'),(46,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.action.LoadGameAction.actionPerformed(java.awt.event.ActionEvent)','7','LoadGameAction','// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Missing: save current project?\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        try {\r\n            PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n            GameNotation notation = pgnFile.readGame();\r\n        } catch (FileNotFoundException fe) {\r\n            JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n        } catch (RecognitionException re) {\r\n        } catch (TokenStreamException te) {\r\n        }\r\n    }\r\n}'),(47,'-init-()','de.java_chess.javaChess.action.ResetGameAction.-init-()','8','ResetGameAction','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new action instance.\r\n */\r\npublic ResetGameAction() {\r\n    super(\"Reset game\");\r\n}'),(48,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.action.ResetGameAction.actionPerformed(java.awt.event.ActionEvent)','8','ResetGameAction','// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JavaChess.getInstance().reset();\r\n}'),(49,'-init-(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.action.SaveGameAction.-init-(de.java_chess.javaChess.notation.GameNotation)','9','SaveGameAction','// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * 		The game notation.\r\n */\r\npublic SaveGameAction(GameNotation gameNotation) {\r\n    super(\"Save game\");\r\n    _gameNotation = gameNotation;\r\n}'),(50,'-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.action.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)','9','SaveGameAction','/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * 		The name of the action.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}'),(51,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.action.SaveGameAction.actionPerformed(java.awt.event.ActionEvent)','9','SaveGameAction','// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n}'),(52,'trySave(java.io.File)','de.java_chess.javaChess.action.SaveGameAction.trySave(java.io.File)','9','SaveGameAction','/**\r\n * Try to save the game into the given file.\r\n *\r\n * @param file\r\n * 		The file to write into.\r\n */\r\npublic void trySave(File file) {\r\n    try {\r\n        PGNOutputStream PGNOutput = new PGNOutputStream(file);\r\n        // Write the notation of the game.\r\n        PGNOutput.write(_gameNotation);\r\n    } catch (IOException exception) {\r\n        JOptionPane.showMessageDialog(null, (\"Error while writing file: \" + (file.getName())), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n    }\r\n}'),(53,'-init-(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.action.SaveGameAsAction.-init-(de.java_chess.javaChess.notation.GameNotation)','10','SaveGameAsAction','// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\npublic SaveGameAsAction(GameNotation gameNotation) {\r\n    super(\"Save game as...\", gameNotation);\r\n    _gameNotation = gameNotation;\r\n}'),(54,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.action.SaveGameAsAction.actionPerformed(java.awt.event.ActionEvent)','10','SaveGameAsAction','// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Create a new filechooser\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Saving game as pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showSaveDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        trySave(chooser.getSelectedFile());\r\n    }\r\n}'),(55,'getPGNFileFilter()','de.java_chess.javaChess.action.SaveGameAsAction.getPGNFileFilter()','10','SaveGameAsAction','/**\r\n * Get a PGN file filter.\r\n *\r\n * @return A PGN file filter.\r\n */\r\npublic static PGNFileFilter getPGNFileFilter() {\r\n    // To avoid the instanciation of too many object at app startup,\r\n    // less important object are created as needed.\r\n    if (null == (SaveGameAsAction._pgnFileFilter)) {\r\n        SaveGameAsAction._pgnFileFilter = new PGNFileFilter();\r\n    }\r\n    return SaveGameAsAction._pgnFileFilter;\r\n}'),(56,'getAllPiecesForColor(boolean)','de.java_chess.javaChess.bitboard.BitBoard.getAllPiecesForColor(boolean)','11','BitBoard','/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * 		true, if the white pieces are requested,\r\n * 		false for the black pieces.\r\n */\r\nlong getAllPiecesForColor(boolean white);'),(57,'getBytes()','de.java_chess.javaChess.bitboard.BitBoard.getBytes()','11','BitBoard','/**\r\n * Get the board as a byte stream.\r\n *\r\n * @return The board as a array of bytes.\r\n */\r\nbyte[] getBytes();'),(58,'getEmptySquares()','de.java_chess.javaChess.bitboard.BitBoard.getEmptySquares()','11','BitBoard','/**\r\n * Get the position of all empty squares.\r\n *\r\n * @return The position of all empty squares.\r\n */\r\nlong getEmptySquares();'),(59,'getPositionOfPieces(int)','de.java_chess.javaChess.bitboard.BitBoard.getPositionOfPieces(int)','11','BitBoard','// Methods\r\n/**\r\n * Get the position of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * 		The color and type of the pieces.\r\n * @return A bitmask with the positions of these pieces.\r\n */\r\nlong getPositionOfPieces(int pieceTypeColor);'),(60,'-init-()','de.java_chess.javaChess.bitboard.BitBoardImpl.-init-()','12','BitBoardImpl','// Constructors\r\n/**\r\n * Create a new instance of a chess board with pieces on their\r\n * initial positions.\r\n */\r\npublic BitBoardImpl() {\r\n    initialPosition();\r\n}'),(61,'clone()','de.java_chess.javaChess.bitboard.BitBoardImpl.clone()','12','BitBoardImpl','// Methods\r\n/**\r\n * Create a clone of this board.\r\n *\r\n * @return A clone of this board.\r\n */\r\npublic final Object clone() {\r\n    BitBoardImpl clone = new BitBoardImpl();\r\n    for (int i = 0; i < 4; i++) {\r\n        clone._boardLayer[i] = _boardLayer[i];\r\n    }\r\n    return clone;\r\n}'),(62,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.bitboard.BitBoardImpl.doPly(de.java_chess.javaChess.ply.Ply)','12','BitBoardImpl','/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    Piece movedPiece = getPiece(ply.getSource());\r\n    // Check, if it was a castling\r\n    if (ply instanceof CastlingPly) {\r\n        int offset = (movedPiece.isWhite()) ? 0 : 56;\r\n        if (((CastlingPly) (ply)).isLeftCastling()) {\r\n            setPiece(movedPiece, new PositionImpl((2 + offset)));\r\n            // Move the rook to the right\r\n            doPly(new PlyImpl(new PositionImpl((0 + offset)), new PositionImpl((3 + offset)), false));\r\n        } else {\r\n            setPiece(movedPiece, new PositionImpl((6 + offset)));\r\n            // Move the rook to the left\r\n            doPly(new PlyImpl(new PositionImpl((7 + offset)), new PositionImpl((5 + offset)), false));\r\n        }\r\n    } else {\r\n        // If a pawn has just reached the last row\r\n        if (ply instanceof TransformationPly) {\r\n            // Set a piece of the new type on the destination square.\r\n            setPiece(new PieceImpl(((TransformationPly) (ply)).getTypeAfterTransformation(), movedPiece.getColor()), ply.getDestination());\r\n        } else {\r\n            // Copy the piece from source square to destination square.\r\n            setPiece(movedPiece, ply.getDestination());\r\n            // If its a en passant ply, remove the attacked pawn.\r\n            if (ply instanceof EnPassantPly) {\r\n                setPiece(null, ((EnPassantPly) (ply)).getAttackedPosition());\r\n            }\r\n        }\r\n    }\r\n    // Empty the source square.\r\n    setPiece(null, ply.getSource());\r\n}'),(63,'emptyBoard()','de.java_chess.javaChess.bitboard.BitBoardImpl.emptyBoard()','12','BitBoardImpl','/**\r\n * Remove all the pieces from the board.\r\n */\r\npublic final void emptyBoard() {\r\n    for (int i = 0; i < 4; i++) {\r\n        _boardLayer[i] = 0L;\r\n    }\r\n}'),(64,'getAllPiecesForColor(boolean)','de.java_chess.javaChess.bitboard.BitBoardImpl.getAllPiecesForColor(boolean)','12','BitBoardImpl','/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * 		true, if the white pieces are requested,\r\n * 		false for the black pieces.\r\n */\r\npublic final long getAllPiecesForColor(boolean white) {\r\n    return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]));\r\n}'),(65,'getBoardAfterPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)','12','BitBoardImpl','/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}'),(66,'getBytes()','de.java_chess.javaChess.bitboard.BitBoardImpl.getBytes()','12','BitBoardImpl','/**\r\n * Get the board as a byte stream.\r\n *\r\n * @return The board as a array of bytes.\r\n */\r\npublic final byte[] getBytes() {\r\n    // A buffer for the bytes.\r\n    byte[] buffer = new byte[32];\r\n    int bufferIndex = 0;\r\n    for (int layer = 0; layer < 4; layer++) {\r\n        // Get the current layer.\r\n        long currentLayer = _boardLayer[layer];\r\n        // Now shift the layer in the buffer.\r\n        for (int bytePos = 0; bytePos < 8; bytePos++) {\r\n            buffer[(bufferIndex++)] = ((byte) (((int) (currentLayer)) & 255));\r\n            currentLayer >>= 8;\r\n        }\r\n    }\r\n    return buffer;// Return the buffer with the bytes.\r\n\r\n}'),(67,'getEmptySquares()','de.java_chess.javaChess.bitboard.BitBoardImpl.getEmptySquares()','12','BitBoardImpl','/**\r\n * Get a bitmask with all the free squares.\r\n *\r\n * @return A bitmask with all the empty squares marked by a 1 bit.\r\n */\r\npublic final long getEmptySquares() {\r\n    return ~(((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3]));\r\n}'),(68,'getPiece(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)','12','BitBoardImpl','/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}'),(69,'getPositionOfPieces(int)','de.java_chess.javaChess.bitboard.BitBoardImpl.getPositionOfPieces(int)','12','BitBoardImpl','/**\r\n * Get the positions of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * 		The color and type of the pieces.\r\n */\r\npublic final long getPositionOfPieces(int pieceTypeColor) {\r\n    return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]));\r\n}'),(70,'initialPosition()','de.java_chess.javaChess.bitboard.BitBoardImpl.initialPosition()','12','BitBoardImpl','/**\r\n * Set all the pieces to their initial positions.\r\n */\r\npublic final void initialPosition() {\r\n    // Empty the board, before the pieces are added.\r\n    for (int i = 0; i < 64; i++) {\r\n        setPiece(null, new PositionImpl(i));\r\n    }\r\n    for (int i = 0; i < 8; i++) {\r\n        setPiece(new PieceImpl(Piece.PAWN, Piece.WHITE), new PositionImpl((8 + i)));\r\n        setPiece(new PieceImpl(Piece.PAWN, Piece.BLACK), new PositionImpl((48 + i)));\r\n    }\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.WHITE), new PositionImpl(0));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.WHITE), new PositionImpl(1));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.WHITE), new PositionImpl(2));\r\n    setPiece(new PieceImpl(Piece.QUEEN, Piece.WHITE), new PositionImpl(3));\r\n    setPiece(new PieceImpl(Piece.KING, Piece.WHITE), new PositionImpl(4));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.WHITE), new PositionImpl(5));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.WHITE), new PositionImpl(6));\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.WHITE), new PositionImpl(7));\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.BLACK), new PositionImpl(56));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.BLACK), new PositionImpl(57));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.BLACK), new PositionImpl(58));\r\n    setPiece(new PieceImpl(Piece.QUEEN, Piece.BLACK), new PositionImpl(59));\r\n    setPiece(new PieceImpl(Piece.KING, Piece.BLACK), new PositionImpl(60));\r\n    setPiece(new PieceImpl(Piece.BISHOP, Piece.BLACK), new PositionImpl(61));\r\n    setPiece(new PieceImpl(Piece.KNIGHT, Piece.BLACK), new PositionImpl(62));\r\n    setPiece(new PieceImpl(Piece.ROOK, Piece.BLACK), new PositionImpl(63));\r\n}'),(71,'setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)','12','BitBoardImpl','/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * 		The piece to set, or null to empty the square.\r\n * @param position\r\n * 		The position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}'),(72,'clone()','de.java_chess.javaChess.board.Board.clone()','13','Board','/**\r\n * Return a copy of the current board.\r\n *\r\n * @return A copy of the current board.\r\n */\r\npublic Object clone();'),(73,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.board.Board.doPly(de.java_chess.javaChess.ply.Ply)','13','Board','/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * 		The move to perform.\r\n */\r\nvoid doPly(Ply ply);'),(74,'emptyBoard()','de.java_chess.javaChess.board.Board.emptyBoard()','13','Board','/**\r\n * Remove all the pieces from the board.\r\n */\r\nvoid emptyBoard();'),(75,'getBoardAfterPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)','13','Board','/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);'),(76,'getPiece(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)','13','Board','/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);'),(77,'initialPosition()','de.java_chess.javaChess.board.Board.initialPosition()','13','Board','/**\r\n * Set the pieces to their initial positions.\r\n */\r\nvoid initialPosition();'),(78,'setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)','13','Board','/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * 		The piece to set.\r\n * @param position\r\n * 		The position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);'),(79,'-init-()','de.java_chess.javaChess.dialogs.DialogAbout.-init-()','14','DialogAbout','// ////////////////////////////////////////////////////////\r\n// //////////////////// Constructor //////////////////////\r\n// //////////////////////////////////////////////////////\r\nprivate DialogAbout() {\r\n    try {\r\n        jbInit();\r\n        this.setTitle(\"About Java-Chess\");\r\n        this.setSize(400, 380);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(80,'CloseButton_keyReleased(java.awt.event.KeyEvent)','de.java_chess.javaChess.dialogs.DialogAbout.CloseButton_keyReleased(java.awt.event.KeyEvent)','14','DialogAbout','void CloseButton_keyReleased(KeyEvent e) {\r\n    if ((e.getKeyCode()) == (KeyEvent.VK_ENTER))\r\n        this.hide();\r\n\r\n}'),(81,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.DialogAbout.actionPerformed(java.awt.event.ActionEvent)','14','DialogAbout','public void actionPerformed(ActionEvent event) {\r\n    this.setVisible(false);\r\n}'),(82,'getDialogResource(java.lang.String)','de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)','14','DialogAbout','/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * 		The name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}'),(83,'getInstance()','de.java_chess.javaChess.dialogs.DialogAbout.getInstance()','14','DialogAbout','// //////////////////////////////////////////\r\n// ////////////// Methods //////////////////\r\n// /////////////////////////////////////////\r\n/**\r\n * Get the one and only instance of this class\r\n * (singleton pattern).\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static DialogAbout getInstance() {\r\n    // If theres no instance yet, create one.\r\n    if ((DialogAbout._instance) == null) {\r\n        DialogAbout._instance = new DialogAbout();\r\n    }\r\n    return DialogAbout._instance;\r\n}'),(84,'jbInit()','de.java_chess.javaChess.dialogs.DialogAbout.jbInit()','14','DialogAbout','private void jbInit() throws Exception {\r\n    titledBorder1 = new TitledBorder(\"\");\r\n    jLTitle.setBackground(Color.white);\r\n    jLTitle.setForeground(Color.black);\r\n    jLTitle.setText(\"Java-Chess 1.0.1 pre-alpha2\");\r\n    tAAuthors.setBackground(Color.black);\r\n    tAAuthors.setForeground(Color.white);\r\n    tAAuthors.setNextFocusableComponent(tAThanks);\r\n    tAAuthors.setEditable(false);\r\n    tAAuthors.setMargin(new Insets(20, 70, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tAAuthors, \"/home/weigo/Documents/Progs/authors\");\r\n    setRegister(tAAuthors, getDialogResource(\"authors.txt\"));\r\n    tAThanks.setBackground(Color.black);\r\n    tAThanks.setForeground(Color.white);\r\n    tAThanks.setNextFocusableComponent(tALicense);\r\n    tAThanks.setEditable(false);\r\n    tAThanks.setMargin(new Insets(20, 50, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tAThanks, \"/home/weigo/Documents/Progs/thanks\");\r\n    setRegister(tAThanks, getDialogResource(\"thanks.txt\"));\r\n    tALicense.setBackground(Color.black);\r\n    tALicense.setForeground(Color.white);\r\n    tALicense.setNextFocusableComponent(bCloseButton);\r\n    tALicense.setEditable(false);\r\n    tALicense.setMargin(new Insets(20, 50, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tALicense, \"/home/weigo/Documents/Progs/license\");\r\n    setRegister(tALicense, getDialogResource(\"license.txt\"));\r\n    tAAbout.setBackground(Color.black);\r\n    tAAbout.setForeground(Color.white);\r\n    tAAbout.setNextFocusableComponent(tAAuthors);\r\n    tAAbout.setEditable(false);\r\n    tAAbout.setMargin(new Insets(20, 70, 50, 20));\r\n    // I use absolute path, you have to change it\r\n    // setRegister(tAAbout, \"/home/weigo/Documents/Progs/about\");\r\n    setRegister(tAAbout, getDialogResource(\"about.txt\"));\r\n    bCloseButton.setBackground(Color.black);\r\n    bCloseButton.setForeground(Color.red);\r\n    bCloseButton.setNextFocusableComponent(tAAbout);\r\n    bCloseButton.setToolTipText(\"close the about dialog\");\r\n    bCloseButton.setMnemonic(0);\r\n    bCloseButton.setText(\"close\");\r\n    bCloseButton.addKeyListener(new DialogAbout_CloseButton_keyAdapter(this));\r\n    jPanel2.setBackground(Color.lightGray);\r\n    jPanel2.setBorder(BorderFactory.createEtchedBorder());\r\n    this.getContentPane().setBackground(Color.lightGray);\r\n    jPanel1.setBackground(Color.lightGray);\r\n    jPanel1.add(jLTitle, null);\r\n    this.getContentPane().add(jPanel2, BorderLayout.SOUTH);\r\n    jPanel2.add(bCloseButton, null);\r\n    this.getContentPane().add(tPAboutDialog, BorderLayout.CENTER);\r\n    tPAboutDialog.add(tAAbout, \"About\");\r\n    tPAboutDialog.add(tAAuthors, \"Authors\");\r\n    this.getContentPane().add(jPanel1, BorderLayout.NORTH);\r\n    tPAboutDialog.add(tAThanks, \"Thanks to\");\r\n    tPAboutDialog.add(tALicense, \"License agreements\");\r\n    bCloseButton.addActionListener(this);\r\n}'),(85,'setRegister(javax.swing.JTextArea,java.io.Reader)','de.java_chess.javaChess.dialogs.DialogAbout.setRegister(javax.swing.JTextArea,java.io.Reader)','14','DialogAbout','void setRegister(JTextArea textArea, Reader in) {\r\n    try {\r\n        char[] buffer = new char[4096];\r\n        int len;\r\n        textArea.setText(\"\");\r\n        while ((len = in.read(buffer)) != (-1)) {\r\n            String s = new String(buffer, 0, len);\r\n            textArea.append(s);\r\n        } \r\n        textArea.setCaretPosition(0);\r\n    } catch (IOException e) {\r\n        textArea.setText((((e.getClass().getName()) + \": \") + (e.getMessage())));\r\n    }\r\n}'),(86,'-init-(de.java_chess.javaChess.dialogs.DialogAbout)','de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.-init-(de.java_chess.javaChess.dialogs.DialogAbout)','15','DialogAbout_CloseButton_keyAdapter','DialogAbout_CloseButton_keyAdapter(DialogAbout adaptee) {\r\n    this.adaptee = adaptee;\r\n}'),(87,'keyReleased(java.awt.event.KeyEvent)','de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.keyReleased(java.awt.event.KeyEvent)','15','DialogAbout_CloseButton_keyAdapter','public void keyReleased(KeyEvent e) {\r\n    adaptee.CloseButton_keyReleased(e);\r\n}'),(88,'-init-()','de.java_chess.javaChess.dialogs.PieceSelectionPanel.-init-()','16','PieceSelectionPanel','/**\r\n * Constructor\r\n */\r\n// Constructor\r\npublic PieceSelectionPanel() {\r\n    _pieceIcon = new ImageIcon[2][7];\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            _pieceIcon[col][type] = new ImageIcon(new PieceRenderer(col, type, _set, this));\r\n        }\r\n    }\r\n    _pieceButton = new JButton[2][7];\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            _pieceButton[col][type] = new JButton(_pieceIcon[col][type]);\r\n            _pieceButton[col][type].addActionListener(this);\r\n        }\r\n    }\r\n    // this.jlSelectedPieceImage.setIcon( _pieceIcon[this.getColor()][this.getType()] );\r\n    // -----------------------------------------------------------------------\r\n    // Layout:\r\n    // -----------------------------------------------------------------------\r\n    this.setLayout(gblPieces);\r\n    this.add(_pieceButton[Piece.BLACK][Piece.PAWN], new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 20, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.PAWN], new GridBagConstraints(0, 1, 2, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 20, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.KNIGHT], new GridBagConstraints(1, 0, 2, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.BISHOP], new GridBagConstraints(3, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.ROOK], new GridBagConstraints(4, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.QUEEN], new GridBagConstraints(5, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.BLACK][Piece.KING], new GridBagConstraints(6, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.KNIGHT], new GridBagConstraints(2, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.BISHOP], new GridBagConstraints(3, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.ROOK], new GridBagConstraints(4, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.QUEEN], new GridBagConstraints(5, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(_pieceButton[Piece.WHITE][Piece.KING], new GridBagConstraints(6, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jlSelectedPiece, new GridBagConstraints(7, 0, 1, 2, 1.0, 1.0, GridBagConstraints.EAST, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));\r\n    this.add(jlSelectedPieceImage, new GridBagConstraints(8, 0, 1, 2, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));\r\n}'),(89,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.PieceSelectionPanel.actionPerformed(java.awt.event.ActionEvent)','16','PieceSelectionPanel','public void actionPerformed(ActionEvent e) {\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            if ((_pieceButton[col][type]) == (e.getSource())) {\r\n                this.setType(type);\r\n                this.setColor(col);\r\n                this.jlSelectedPieceImage.setIcon(_pieceIcon[col][type]);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}'),(90,'getColor()','de.java_chess.javaChess.dialogs.PieceSelectionPanel.getColor()','16','PieceSelectionPanel','/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic byte getColor() {\r\n    return ((byte) ((pieceColor) & ((byte) (1))));\r\n}'),(91,'getSelectedPieceImage()','de.java_chess.javaChess.dialogs.PieceSelectionPanel.getSelectedPieceImage()','16','PieceSelectionPanel','public Image getSelectedPieceImage() {\r\n    byte type = this.getType();\r\n    if (type == 0) {\r\n        type = Piece.KING;\r\n    }\r\n    // To avoid the instanciation of a image each time, just reuse\r\n    // the images of the icons.\r\n    return _pieceIcon[this.getColor()][type].getImage();\r\n}'),(92,'getType()','de.java_chess.javaChess.dialogs.PieceSelectionPanel.getType()','16','PieceSelectionPanel','// -----------------------------------------------------------------------\r\n// Interface methods:\r\n// -----------------------------------------------------------------------\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic byte getType() {\r\n    return ((byte) ((pieceColor) >> 1));\r\n}'),(93,'getTypeAndColor()','de.java_chess.javaChess.dialogs.PieceSelectionPanel.getTypeAndColor()','16','PieceSelectionPanel','/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic byte getTypeAndColor() {\r\n    return this.pieceColor;\r\n}'),(94,'initializeSelectedIconLabel()','de.java_chess.javaChess.dialogs.PieceSelectionPanel.initializeSelectedIconLabel()','16','PieceSelectionPanel','/**\r\n * Sets an icon for the SelectedIconLabel when no icon has been set before\r\n */\r\npublic void initializeSelectedIconLabel() {\r\n    if ((this.jlSelectedPieceImage.getIcon()) == null) {\r\n        byte type = this.getType();\r\n        if (type == 0)\r\n            type = Piece.KING;\r\n\r\n        this.jlSelectedPieceImage.setIcon(_pieceIcon[this.getColor()][type]);\r\n    }\r\n}'),(95,'isWhite()','de.java_chess.javaChess.dialogs.PieceSelectionPanel.isWhite()','16','PieceSelectionPanel','/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic boolean isWhite() {\r\n    return ((this.pieceColor) & 1) != 0;\r\n}'),(96,'setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)','de.java_chess.javaChess.dialogs.PieceSelectionPanel.setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)','16','PieceSelectionPanel','public void setCallingDialog(SetupBoardDialog dialog) {\r\n    this.setupBoardDialog = dialog;\r\n}'),(97,'setColor(byte)','de.java_chess.javaChess.dialogs.PieceSelectionPanel.setColor(byte)','16','PieceSelectionPanel','/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * 		new color of this piece.\r\n */\r\npublic void setColor(byte color) {\r\n    pieceColor &= ((byte) (14));\r\n    pieceColor |= color;\r\n}'),(98,'setType(byte)','de.java_chess.javaChess.dialogs.PieceSelectionPanel.setType(byte)','16','PieceSelectionPanel','/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * 		The type of this piece as defined as\r\n * 		constants in the Piece interface.\r\n */\r\npublic void setType(byte type) {\r\n    pieceColor &= ((byte) (1));\r\n    pieceColor |= type << 1;\r\n}'),(99,'-init-()','de.java_chess.javaChess.dialogs.PlayerDialog.-init-()','17','PlayerDialog','/**\r\n * Standardconstructor\r\n */\r\npublic PlayerDialog() {\r\n    super();\r\n}'),(100,'-init-(int,java.lang.String)','de.java_chess.javaChess.dialogs.PlayerDialog.-init-(int,java.lang.String)','17','PlayerDialog','/**\r\n *\r\n *\r\n * @param iWhiteBlack\r\n * 		1 = edit white players name\r\n * @param currentString\r\n * 		The string which already is displayed above the notation panel\r\n */\r\npublic PlayerDialog(int iWhiteBlack, String currentString) {\r\n    this.iWhite = iWhiteBlack;\r\n    this.sCurrentString = currentString;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(101,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.PlayerDialog.actionPerformed(java.awt.event.ActionEvent)','17','PlayerDialog','/**\r\n * Interface method; handles the mouse click on the OK-button\r\n *\r\n * @param e\r\n * 		The action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jbOK)) {\r\n        this.hide();\r\n    }\r\n}'),(102,'getNewName()','de.java_chess.javaChess.dialogs.PlayerDialog.getNewName()','17','PlayerDialog','/**\r\n * Returns the name from within the JTextField\r\n *\r\n * @return The new name\r\n */\r\npublic String getNewName() {\r\n    return this.jtNewName.getText();\r\n}'),(103,'jbInit()','de.java_chess.javaChess.dialogs.PlayerDialog.jbInit()','17','PlayerDialog','/**\r\n * Die GUI nach Nomenklatur des JBuilder\r\n *\r\n * @throws Exception\r\n * 		\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setModal(true);\r\n    this.getContentPane().setLayout(new GridBagLayout());\r\n    jtNewName = new JTextField(this.sCurrentString);\r\n    jtNewName.setSelectionStart(0);\r\n    jtNewName.setSelectionEnd(jtNewName.getText().length());\r\n    if ((this.iWhite) == 1) {\r\n        this.setTitle(\"Edit white players name\");\r\n        jLabel.setText(\"New white player name: \");\r\n        this.getContentPane().add(jLabel, new GridBagConstraints(0, 0, 1, 1, 0.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));\r\n        bWhiteOrBlack = true;\r\n    } else\r\n        if ((this.iWhite) == 2) {\r\n            jLabel.setText(\"New black player name: \");\r\n            this.setTitle(\"Edit black players name\");\r\n            this.getContentPane().add(jLabel, new GridBagConstraints(0, 0, 1, 1, 0.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));\r\n            bWhiteOrBlack = false;\r\n        }\r\n\r\n    this.getContentPane().add(jtNewName, new GridBagConstraints(1, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.HORIZONTAL, new Insets(2, 2, 2, 2), 0, 0));\r\n    jbOK.addActionListener(this);\r\n    this.getContentPane().add(jbOK, new GridBagConstraints(0, 1, 2, 1, 1.0, 1.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(2, 2, 2, 2), 0, 0));\r\n    this.setSize(300, 75);\r\n}'),(104,'-init-()','de.java_chess.javaChess.dialogs.SetupBoardDialog.-init-()','18','SetupBoardDialog','/**\r\n * Constructor\r\n */\r\npublic SetupBoardDialog() {\r\n    super();\r\n    String sMessage = \"This dialog is under construction.\n\n\";\r\n    sMessage += \"You can try some buttons and play around a bit,\n\";\r\n    sMessage += \"but it is not yet possible to place\n\";\r\n    sMessage += \"one or more pieces on the board.\n\";\r\n    sMessage += \"This point has very high priority\n\";\r\n    sMessage += \"on our ToDo-list for the next release.\";\r\n    String sTitle = \"Important note!\";\r\n    JOptionPane.showMessageDialog(null, sMessage, sTitle, JOptionPane.INFORMATION_MESSAGE);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(105,'jbCancel_actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.SetupBoardDialog.jbCancel_actionPerformed(java.awt.event.ActionEvent)','18','SetupBoardDialog','/**\r\n * Button Cancel pressed\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nprivate void jbCancel_actionPerformed(ActionEvent e) {\r\n    this.dispose();\r\n}'),(106,'jbClearBoard_actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.SetupBoardDialog.jbClearBoard_actionPerformed(java.awt.event.ActionEvent)','18','SetupBoardDialog','/**\r\n * Button Clear board pressed; self-explaining\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jbClearBoard_actionPerformed(ActionEvent e) {\r\n    this.boardRenderer.clearBoard();\r\n}'),(107,'jbInit()','de.java_chess.javaChess.dialogs.SetupBoardDialog.jbInit()','18','SetupBoardDialog','/**\r\n * Method for constructing the GUI\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setTitle(\"JavaChess - Setup position\");\r\n    this.getContentPane().setLayout(gblContentPane);\r\n    this.setSize(new Dimension(700, 650));\r\n    this.addWindowListener(new WindowAdapter() {\r\n        public void windowClosing(WindowEvent e) {\r\n            this_windowClosing(e);\r\n        }\r\n    });\r\n    bitBoard = new BitBoardImpl();\r\n    // Hm:\r\n    // gameController = new GameController( _game, _gameNotation, _engine, _board, _gameTimer);\r\n    // boardRenderer = new ChessBoardRenderer2D( gameController, bitBoard );\r\n    boardRenderer = new ChessBoardRenderer2D(null, bitBoard);\r\n    // gameController.setRenderer( boardRenderer );\r\n    this.jpBoard.setLayout(gblBoard);\r\n    this.jpBoard.setPreferredSize(new Dimension(430, 430));\r\n    jpBoard.addMouseListener(new MouseAdapter() {\r\n        public void mouseEntered(MouseEvent e) {\r\n            jpBoard_mouseEntered(e);\r\n        }\r\n\r\n        public void mouseExited(MouseEvent e) {\r\n            jpBoard_mouseExited(e);\r\n        }\r\n    });\r\n    this.jpBoard.setMinimumSize(new Dimension(430, 430));\r\n    jpCastling.setLayout(gblCastling);\r\n    jpCastling.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jlCastling.setText(\"Castling rights:\");\r\n    checkBoxWhiteShort.setText(\"White short (O-O)\");\r\n    checkBoxWhiteLong.setText(\"White long (O-O-O)\");\r\n    checkBoxBlackShort.setText(\"Black short (O-O)\");\r\n    checkBoxBlackLong.setText(\"Black long (O-O-O)\");\r\n    jpMoveRight.setLayout(gblMoveRight);\r\n    jpMoveRight.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jpMoveRight.setMinimumSize(new Dimension(135, 73));\r\n    jpMoveRight.setPreferredSize(new Dimension(135, 73));\r\n    jlMoveRight.setText(\"Move right:\");\r\n    jrbWhiteToMove.setText(\"White to move\");\r\n    jrbWhiteToMove.setSelected(true);\r\n    jrbBlackToMove.setText(\"Black to move\");\r\n    jbClearBoard.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbClearBoard_actionPerformed(e);\r\n        }\r\n    });\r\n    jbStartPosition.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbStartPosition_actionPerformed(e);\r\n        }\r\n    });\r\n    bgMoveRight.add(jrbWhiteToMove);\r\n    bgMoveRight.add(jrbBlackToMove);\r\n    jpEnPassant.setLayout(gridBagLayout1);\r\n    jlEnPassant.setText(\"EnPassant-Square:\");\r\n    jtEnPassant.setMinimumSize(new Dimension(108, 21));\r\n    // Restrict the user input to 2 valid characters:\r\n    jtEnPassant.setDocument(new StringTextDocument(1, 2));\r\n    jtEnPassant.setPreferredSize(new Dimension(108, 21));\r\n    jpEnPassant.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jpEnPassant.setMinimumSize(new Dimension(135, 48));\r\n    jpEnPassant.setPreferredSize(new Dimension(135, 48));\r\n    jpMoveNumber.setLayout(gblMoveNumber);\r\n    jlMoveNumber.setText(\"Move number:\");\r\n    jpMoveNumber.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    jpMoveNumber.setMinimumSize(new Dimension(135, 56));\r\n    jpMoveNumber.setPreferredSize(new Dimension(135, 56));\r\n    jtMoveNumber.setMinimumSize(new Dimension(108, 21));\r\n    jtMoveNumber.setPreferredSize(new Dimension(108, 21));\r\n    // Restrict the user input to 3 numbers:\r\n    jtMoveNumber.setDocument(new StringTextDocument(2, 3));\r\n    jpButtons.setLayout(gblButtons);\r\n    jbOk.setToolTipText(\"Close dialog with current position\");\r\n    jbOk.setMnemonic(KeyEvent.VK_O);\r\n    jbOk.setText(\"OK\");\r\n    jbOk.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbOk_actionPerformed(e);\r\n        }\r\n    });\r\n    jbCancel.setToolTipText(\"Abort and back to former position/game\");\r\n    jbCancel.setText(\"Cancel\");\r\n    jbCancel.setMnemonic(KeyEvent.VK_C);\r\n    jbCancel.addActionListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent e) {\r\n            jbCancel_actionPerformed(e);\r\n        }\r\n    });\r\n    jbClearBoard.setToolTipText(\"Clears the complete board\");\r\n    jbClearBoard.setText(\"Clear board\");\r\n    jbClearBoard.setMnemonic(KeyEvent.VK_L);\r\n    jbStartPosition.setToolTipText(\"Startup/Initial position\");\r\n    jbStartPosition.setText(\"Start position\");\r\n    jbStartPosition.setMnemonic(KeyEvent.VK_S);\r\n    jpBoard.add(boardRenderer, new GridBagConstraints(0, 0, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.getContentPane().add(jpPieces, new GridBagConstraints(0, 5, 2, 1, 1.0, 1.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    jpBoard.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.getContentPane().add(jpBoard, new GridBagConstraints(0, 0, 1, 4, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 2, 2), 0, 0));\r\n    this.getContentPane().add(jpButtons, new GridBagConstraints(0, 6, 2, 1, 1.0, 1.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.getContentPane().add(jpMoveRight, new GridBagConstraints(1, 0, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 20), 0, 0));\r\n    jpMoveRight.add(jrbWhiteToMove, new GridBagConstraints(0, 2, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpMoveRight.add(jrbBlackToMove, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpMoveRight.add(jlMoveRight, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 0, 0), 0, 0));\r\n    jpButtons.add(jbOk, new GridBagConstraints(3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 20), 0, 0));\r\n    jpButtons.add(jbCancel, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 20), 0, 0));\r\n    jpButtons.add(jbStartPosition, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 20, 0, 20), 0, 0));\r\n    jpButtons.add(jbClearBoard, new GridBagConstraints(0, 0, 1, 1, 0.0, 1.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 20, 0, 20), 0, 0));\r\n    this.getContentPane().add(jpCastling, new GridBagConstraints(1, 1, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 20), 0, 0));\r\n    jpCastling.add(checkBoxBlackLong, new GridBagConstraints(0, 4, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(checkBoxWhiteShort, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(checkBoxWhiteLong, new GridBagConstraints(0, 2, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(checkBoxBlackShort, new GridBagConstraints(0, 3, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 0, 0), 0, 0));\r\n    jpCastling.add(jlCastling, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 10, 0), 0, 0));\r\n    this.getContentPane().add(jpEnPassant, new GridBagConstraints(1, 2, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 0), 0, 0));\r\n    jpEnPassant.add(jtEnPassant, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 4, 4, 4), 0, 0));\r\n    jpEnPassant.add(jlEnPassant, new GridBagConstraints(0, 0, 2, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 0, 0), 0, 0));\r\n    this.getContentPane().add(jpMoveNumber, new GridBagConstraints(1, 3, 1, 1, 0.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(20, 20, 0, 0), 0, 0));\r\n    jpMoveNumber.add(jtMoveNumber, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));\r\n    jpMoveNumber.add(jlMoveNumber, new GridBagConstraints(0, 0, 2, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(4, 4, 4, 4), 0, 0));// Brett\r\n\r\n}'),(108,'jbOk_actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.SetupBoardDialog.jbOk_actionPerformed(java.awt.event.ActionEvent)','18','SetupBoardDialog','/**\r\n * Button Ok pressed\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nprivate void jbOk_actionPerformed(ActionEvent e) {\r\n    this.hide();\r\n}'),(109,'jbStartPosition_actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.SetupBoardDialog.jbStartPosition_actionPerformed(java.awt.event.ActionEvent)','18','SetupBoardDialog','/**\r\n * Button Start position pressed; self-explaining\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jbStartPosition_actionPerformed(ActionEvent e) {\r\n    bitBoard.initialPosition();\r\n    this.boardRenderer.reset();\r\n    this.validate();\r\n}'),(110,'jpBoard_mouseEntered(java.awt.event.MouseEvent)','de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseEntered(java.awt.event.MouseEvent)','18','SetupBoardDialog','/**\r\n * Mouse cursor entered the board: Use piece as mouse pointer over the board\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jpBoard_mouseEntered(MouseEvent e) {\r\n    Image imageCursor;\r\n    oldCursor = this.getCursor();\r\n    // byte typeAndColor = ((Piece)jpPieces).getTypeAndColor();\r\n    // URL url = getClass().getResource(\"BP.gif\");\r\n    // Image image = Toolkit.getDefaultToolkit().getImage( url );\r\n    // Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(((Piece)jpPieces).getSelectedPieceImage(), new Point(20, 20), \"Piece\");\r\n    imageCursor = ((PieceSelectionPanel) (jpPieces)).getSelectedPieceImage();\r\n    ((PieceSelectionPanel) (jpPieces)).initializeSelectedIconLabel();\r\n    if (imageCursor != null) {\r\n        Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(imageCursor, new Point(20, 20), \"Piece\");\r\n        jpBoard.setCursor(myCursor);\r\n    }\r\n}'),(111,'jpBoard_mouseExited(java.awt.event.MouseEvent)','de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseExited(java.awt.event.MouseEvent)','18','SetupBoardDialog','/**\r\n * Mouse cursor left the board: Use normal mouse pointer again\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jpBoard_mouseExited(MouseEvent e) {\r\n    jpBoard.setCursor(oldCursor);\r\n}'),(112,'this_windowClosing(java.awt.event.WindowEvent)','de.java_chess.javaChess.dialogs.SetupBoardDialog.this_windowClosing(java.awt.event.WindowEvent)','18','SetupBoardDialog','/**\r\n * If this dialog is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * 		The Window event\r\n */\r\nprivate void this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}'),(113,'-init-(javax.swing.JFrame,boolean)','de.java_chess.javaChess.dialogs.TransformationDialog.-init-(javax.swing.JFrame,boolean)','19','TransformationDialog','// Constructors\r\n/**\r\n * Create a new transformation dialog.\r\n *\r\n * @param parent\r\n * 		The parent frame.\r\n * @param modal\r\n * 		Flag, if the dialog is modal.\r\n */\r\nprivate TransformationDialog(JFrame parent, boolean modal) {\r\n    super(parent, modal);\r\n    _pieceType = Piece.QUEEN;// Set the piece type to the default value.\r\n\r\n    setTitle(\"Chose a piece type\");// Set the title of the dialog.\r\n\r\n    // Set a new layout with bigger gaps.\r\n    getContentPane().setLayout(new BorderLayout(16, 16));\r\n    // Add a panel with the options.\r\n    JPanel choserPanel = new JPanel();\r\n    choserPanel.setLayout(new GridLayout(4, 1));\r\n    // Create a group for the piece types to handle the selection\r\n    // of the radio buttons.\r\n    ButtonGroup buttonGroup = new ButtonGroup();\r\n    // Add the buttons for piece types\r\n    _queenButton = new JRadioButton(\"Queen\");\r\n    _queenButton.setSelected(true);\r\n    // Queen is the default choice.\r\n    buttonGroup.add(_queenButton);\r\n    _queenButton.addActionListener(this);\r\n    choserPanel.add(_queenButton);\r\n    _rookButton = new JRadioButton(\"Rook\");\r\n    buttonGroup.add(_rookButton);\r\n    _rookButton.addActionListener(this);\r\n    choserPanel.add(_rookButton);\r\n    _knightButton = new JRadioButton(\"Knight\");\r\n    buttonGroup.add(_knightButton);\r\n    _knightButton.addActionListener(this);\r\n    choserPanel.add(_knightButton);\r\n    _bishopButton = new JRadioButton(\"Bishop\");\r\n    buttonGroup.add(_bishopButton);\r\n    _bishopButton.addActionListener(this);\r\n    choserPanel.add(_bishopButton);\r\n    getContentPane().add(choserPanel, BorderLayout.CENTER);\r\n    // Add a button to hide the dialog.\r\n    _okButton = new JButton(\"Ok\");\r\n    _okButton.addActionListener(this);\r\n    getContentPane().add(_okButton, BorderLayout.SOUTH);\r\n    pack();\r\n    // Get the screen size and place the dialog in the middle of the screen.\r\n    Dimension size = getSize();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    setLocation((((screenSize.width) / 2) - ((size.width) / 2)), (((screenSize.height) / 2) - ((size.height) / 2)));\r\n}'),(114,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.dialogs.TransformationDialog.actionPerformed(java.awt.event.ActionEvent)','19','TransformationDialog','/**\r\n * A method to handle action events coming from the dialog.\r\n *\r\n * @param event\r\n * 		The event that triggered this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Get the source of the event.\r\n    Object eventSource = event.getSource();\r\n    // If the user closed the dialog.\r\n    if (eventSource == (_okButton)) {\r\n        setVisible(false);\r\n        return;\r\n    }\r\n    // Check for the radio buttons.\r\n    if (eventSource == (_queenButton)) {\r\n        _pieceType = Piece.QUEEN;\r\n    } else\r\n        if (eventSource == (_rookButton)) {\r\n            _pieceType = Piece.ROOK;\r\n        } else\r\n            if (eventSource == (_knightButton)) {\r\n                _pieceType = Piece.KNIGHT;\r\n            } else\r\n                if (eventSource == (_bishopButton)) {\r\n                    _pieceType = Piece.BISHOP;\r\n                }\r\n\r\n\r\n\r\n}'),(115,'getInstance()','de.java_chess.javaChess.dialogs.TransformationDialog.getInstance()','19','TransformationDialog','// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final TransformationDialog getInstance() {\r\n    if ((TransformationDialog._instance) == null) {\r\n        TransformationDialog._instance = new TransformationDialog(null, true);\r\n    }\r\n    return TransformationDialog._instance;\r\n}'),(116,'getPieceType()','de.java_chess.javaChess.dialogs.TransformationDialog.getPieceType()','19','TransformationDialog','/**\r\n * Get the currently selected piece type.\r\n *\r\n * @return The currently selected piece type.\r\n */\r\npublic byte getPieceType() {\r\n    return _pieceType;\r\n}'),(117,'analyze()','de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze()','20','BitBoardAnalyzer','/**\r\n * Analyze the current board.\r\n */\r\nshort analyze();'),(118,'analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)','20','BitBoardAnalyzer','/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);'),(119,'getBoard()','de.java_chess.javaChess.engine.BitBoardAnalyzer.getBoard()','20','BitBoardAnalyzer','// Methods\r\n/**\r\n * Get the currently analyzed board.\r\n *\r\n * @return The currently analyzed board.\r\n */\r\nBitBoard getBoard();'),(120,'isInCheck(boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(boolean)','20','BitBoardAnalyzer','/**\r\n * Test if a king is in check.\r\n *\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(boolean white);'),(121,'isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)','20','BitBoardAnalyzer','/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);'),(122,'setBoard(de.java_chess.javaChess.bitboard.BitBoard)','de.java_chess.javaChess.engine.BitBoardAnalyzer.setBoard(de.java_chess.javaChess.bitboard.BitBoard)','20','BitBoardAnalyzer','/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(BitBoard board);'),(123,'setMoveRight(boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzer.setMoveRight(boolean)','20','BitBoardAnalyzer','/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white has the\r\n * 		next move.\r\n */\r\nvoid setMoveRight(boolean white);'),(124,'-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)','21','BitBoardAnalyzerImpl','// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * 		A PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}'),(125,'analyze()','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze()','21','BitBoardAnalyzerImpl','/**\r\n * Analyze the current board.\r\n */\r\npublic final short analyze() {\r\n    // A check thread has a value, too.\r\n    short checkValue = 0;\r\n    // Start with the tests, if one of the players is in check.\r\n    // Its important to start the test with the color that moves next!\r\n    if (whiteHasMoveRight()) {\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n    } else {\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n    }\r\n    // Early checks hinder the position building are punished therefore.\r\n    if ((getGame().getNumberOfPlies()) < 12) {\r\n        checkValue = ((short) (checkValue / 4));\r\n    }\r\n    // Now compute the position and material value of all pieces.\r\n    short materialValue = 0;\r\n    // Count the figures and their material value.\r\n    short positionalValue = 0;// Score the position value.\r\n\r\n    // Check the entire board.\r\n    // Use a bitmask to speedup the test for a piece on the square\r\n    long emptySquareMask = getBoard().getEmptySquares();\r\n    // Get the positions of the white and black pawns.\r\n    long[] pawnPos = new long[2];\r\n    pawnPos[0] = getBoard().getPositionOfPieces(((Piece.PAWN) << 1));\r\n    pawnPos[1] = getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1));\r\n    // I reuse the same PositionImpl object to avoid the overhead of\r\n    // object instancing for each square.\r\n    Position pos = new PositionImpl(0);\r\n    for (int i = 0; i < 64; i++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            pos.setSquareIndex(i);\r\n            Piece p = getBoard().getPiece(pos);\r\n            if (p != null) {\r\n                short mValue = 0;\r\n                short pValue = 0;\r\n                // Add the value of the piece\r\n                switch (p.getType()) {\r\n                    case Piece.PAWN :\r\n                        mValue = 10;\r\n                        pValue = BitBoardAnalyzerImpl._pawnPositionalValue[((getGame().getNumberOfPlies()) <= 12 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        // Check, if this pawn could be promoted\r\n                        if (p.isWhite()) {\r\n                            int j = i + 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j < 64) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        } else {\r\n                            int j = i - 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j >= 0) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        }\r\n                        break;\r\n                    case Piece.KNIGHT :\r\n                        pValue = BitBoardAnalyzerImpl._knightPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) < 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.BISHOP :\r\n                        pValue = BitBoardAnalyzerImpl._bishopPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) <= 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.ROOK :\r\n                        mValue = 45;\r\n                        pValue = BitBoardAnalyzerImpl._rookPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.QUEEN :\r\n                        mValue = 80;\r\n                        pValue = BitBoardAnalyzerImpl._queenPositionalValue[((getGame().getNumberOfPlies()) <= 14 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.KING :\r\n                        pValue = BitBoardAnalyzerImpl._kingPositionalValue[(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                }\r\n                if (p.isWhite()) {\r\n                    materialValue += mValue;\r\n                    positionalValue += pValue;\r\n                } else {\r\n                    materialValue -= mValue;\r\n                    positionalValue -= pValue;\r\n                }\r\n            }\r\n        }\r\n        // Shift the mask to test the next square\r\n        emptySquareMask >>>= 1;\r\n    }\r\n    // Return a weighted score\r\n    return ((short) (((((short) (2)) * positionalValue) + (((short) (7)) * materialValue)) + checkValue));\r\n}'),(126,'analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)','21','BitBoardAnalyzerImpl','/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}'),(127,'getBoard()','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getBoard()','21','BitBoardAnalyzerImpl','// Methods\r\n/**\r\n * Get the currently analyzed board.\r\n *\r\n * @return The currently analyzed board.\r\n */\r\npublic final BitBoard getBoard() {\r\n    return _board;\r\n}'),(128,'getGame()','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getGame()','21','BitBoardAnalyzerImpl','/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(129,'getPlyGenerator()','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getPlyGenerator()','21','BitBoardAnalyzerImpl','/**\r\n * Get the ply generator.\r\n *\r\n * @return The PlyGenerator.\r\n */\r\nprivate final PlyGenerator getPlyGenerator() {\r\n    return _plyGenerator;\r\n}'),(130,'isInCheck(boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)','21','BitBoardAnalyzerImpl','/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(131,'isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)','21','BitBoardAnalyzerImpl','/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}'),(132,'setBoard(de.java_chess.javaChess.bitboard.BitBoard)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setBoard(de.java_chess.javaChess.bitboard.BitBoard)','21','BitBoardAnalyzerImpl','/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(BitBoard board) {\r\n    _board = board;\r\n}'),(133,'setGame(de.java_chess.javaChess.game.Game)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setGame(de.java_chess.javaChess.game.Game)','21','BitBoardAnalyzerImpl','/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(134,'setMoveRight(boolean)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setMoveRight(boolean)','21','BitBoardAnalyzerImpl','/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white has the\r\n * 		next move.\r\n */\r\npublic final void setMoveRight(boolean white) {\r\n    _whiteMoves = white;\r\n}'),(135,'setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)','21','BitBoardAnalyzerImpl','/**\r\n * Set a new PlyGenerator instance.\r\n *\r\n * @param plyGenerator\r\n * 		The new PlyGenerator instance.\r\n */\r\nprivate final void setPlyGenerator(PlyGenerator plyGenerator) {\r\n    _plyGenerator = plyGenerator;\r\n}'),(136,'whiteHasMoveRight()','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.whiteHasMoveRight()','21','BitBoardAnalyzerImpl','/**\r\n * Check, if white moves next.\r\n *\r\n * @return true, if white moves next, false otherwise.\r\n */\r\nprivate final boolean whiteHasMoveRight() {\r\n    return _whiteMoves;\r\n}'),(137,'-init-()','de.java_chess.javaChess.engine.BitUtils.-init-()','22','BitUtils','BitUtils() {\r\n}'),(138,'getHighestBit(long)','de.java_chess.javaChess.engine.BitUtils.getHighestBit(long)','22','BitUtils','/**\r\n * Find the index of highest set bit in a long bitmask.\r\n *\r\n * @param bitmask\r\n * 		The bitmask to operate on.\r\n * @return The index of the highest set bit or 0, if no bits are set.\r\n */\r\npublic static final int getHighestBit(long bitmask) {\r\n    int highestBit = 0;\r\n    // The following 3 statements split the 64 bit word down to\r\n    // a byte.\r\n    int dwordPart = ((int) (bitmask >>> 32));\r\n    if (dwordPart != 0) {\r\n        highestBit += 32;\r\n    } else {\r\n        dwordPart = ((int) (bitmask));\r\n    }\r\n    int wordPart = (dwordPart >>> 16) & 65535;\r\n    if (wordPart != 0) {\r\n        highestBit += 16;\r\n    } else {\r\n        wordPart = dwordPart & 65535;\r\n    }\r\n    int bytePart = (wordPart >>> 8) & 255;\r\n    if (bytePart != 0) {\r\n        highestBit += 8;\r\n    } else {\r\n        bytePart = wordPart & 255;\r\n    }\r\n    // Use the byte as a index for a precomputed array\r\n    // of bit indexes.\r\n    return highestBit + (BitUtils._highestBit[bytePart]);\r\n}'),(139,'computeBestPly()','de.java_chess.javaChess.engine.ChessEngine.computeBestPly()','23','ChessEngine','/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\nPly computeBestPly();'),(140,'getBoard()','de.java_chess.javaChess.engine.ChessEngine.getBoard()','23','ChessEngine','/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nBoard getBoard();'),(141,'getCurrentGameState(boolean)','de.java_chess.javaChess.engine.ChessEngine.getCurrentGameState(boolean)','23','ChessEngine','/**\r\n * Get the current game state for a given color.\r\n *\r\n * @param white\r\n * 		True, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\nbyte getCurrentGameState(boolean white);'),(142,'getGame()','de.java_chess.javaChess.engine.ChessEngine.getGame()','23','ChessEngine','/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\nGame getGame();'),(143,'getMenu()','de.java_chess.javaChess.engine.ChessEngine.getMenu()','23','ChessEngine','/**\r\n * Request a menu from the chess engine, where the user\r\n * can change its settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\nJMenu getMenu();'),(144,'getUserPlies()','de.java_chess.javaChess.engine.ChessEngine.getUserPlies()','23','ChessEngine','/**\r\n * Get all the potential plies for the human player.\r\n *\r\n * @return All the potential plies for the human player.\r\n */\r\nPly[] getUserPlies();'),(145,'isWhite()','de.java_chess.javaChess.engine.ChessEngine.isWhite()','23','ChessEngine','/**\r\n * Get the color of this engine.\r\n *\r\n * @param white\r\n * 		true, if the engine operates with the white pieces.\r\n */\r\nboolean isWhite();'),(146,'reset()','de.java_chess.javaChess.engine.ChessEngine.reset()','23','ChessEngine','/**\r\n * Reset the engine for a new game.\r\n */\r\nvoid reset();'),(147,'setBoard(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.engine.ChessEngine.setBoard(de.java_chess.javaChess.board.Board)','23','ChessEngine','/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(Board board);'),(148,'setGame(de.java_chess.javaChess.game.Game)','de.java_chess.javaChess.engine.ChessEngine.setGame(de.java_chess.javaChess.game.Game)','23','ChessEngine','/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\nvoid setGame(Game game);'),(149,'setWhite(boolean)','de.java_chess.javaChess.engine.ChessEngine.setWhite(boolean)','23','ChessEngine','/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * 		flag to indicate if the engine operates on the white pieces.\r\n */\r\nvoid setWhite(boolean white);'),(150,'startPermanentBrain()','de.java_chess.javaChess.engine.ChessEngine.startPermanentBrain()','23','ChessEngine','/**\r\n * Start the computations of the permanent brain.\r\n */\r\nvoid startPermanentBrain();'),(151,'stopPermanentBrain()','de.java_chess.javaChess.engine.ChessEngine.stopPermanentBrain()','23','ChessEngine','/**\r\n * Stop the computations of the permanent brain.\r\n */\r\nvoid stopPermanentBrain();'),(152,'validateUserPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.ChessEngine.validateUserPly(de.java_chess.javaChess.ply.Ply)','23','ChessEngine','/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\nboolean validateUserPly(Ply ply);'),(153,'-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)','de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)','24','ChessEngineImpl','// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(154,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.engine.ChessEngineImpl.actionPerformed(java.awt.event.ActionEvent)','24','ChessEngineImpl','/**\r\n * Perform a action (could be a menu related action).\r\n *\r\n * @param actionEvent\r\n * 		The event.\r\n */\r\npublic final void actionPerformed(ActionEvent actionEvent) {\r\n    // Check, if the user (de-)activated the permanent brain.\r\n    if (actionEvent.getSource().equals(_permanentBrainMenuItem)) {\r\n        activatePermanentBrain(_permanentBrainMenuItem.isSelected());\r\n        this.notifyListeners();\r\n        return;\r\n    }\r\n    // Check if the user has requested a new search time\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        if (actionEvent.getSource().equals(_avSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = false;\r\n        }\r\n        if (actionEvent.getSource().equals(_fixSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = true;\r\n        }\r\n    }\r\n    // Check, if the user has requested a different hashtable size.\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        if (actionEvent.getSource().equals(_hashtableSizeMenuItem[hts])) {\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n    }\r\n    this.notifyListeners();\r\n}'),(155,'activatePermanentBrain(boolean)','de.java_chess.javaChess.engine.ChessEngineImpl.activatePermanentBrain(boolean)','24','ChessEngineImpl','/**\r\n * (De-)activate the permanent brain function.\r\n *\r\n * @param active\r\n * 		Flag to indicate, if the permanent brain function should be used.\r\n */\r\nprivate final void activatePermanentBrain(boolean active) {\r\n    _usePermanentBrain = active;\r\n    // Since the permanent brain is eventually active already, stop it now.\r\n    if (!(usePermanentBrain())) {\r\n        stopPermanentBrain();\r\n    }\r\n    // If the permanent brain is activated, it will be use for the next(!) move.\r\n}'),(156,'addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)','de.java_chess.javaChess.engine.ChessEngineImpl.addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)','24','ChessEngineImpl','/**\r\n * Registers an object for notification.\r\n *\r\n * @param listener\r\n * 		The object to be registered.\r\n */\r\npublic void addEngineStatusListener(EngineStatusListener listener) {\r\n    listeners.add(listener);\r\n}'),(157,'addLogEntry(java.lang.String)','de.java_chess.javaChess.engine.ChessEngineImpl.addLogEntry(java.lang.String)','24','ChessEngineImpl','/**\r\n * Ads a log entry into the JavaChess logfile\r\n *\r\n * @param text\r\n * 		The text to append\r\n */\r\nprivate void addLogEntry(String text) {\r\n    if ((f) != null) {\r\n        try {\r\n            // First read the existing lines into vBuffer\r\n            BufferedReader bfrIniFile = new BufferedReader(new FileReader(f));\r\n            String strOrgLine = bfrIniFile.readLine();\r\n            vBuffer = new Vector();\r\n            String strLine;\r\n            while (strOrgLine != null) {\r\n                strLine = strOrgLine.trim();\r\n                this.vBuffer.addElement(strLine);\r\n                strOrgLine = bfrIniFile.readLine();\r\n            } \r\n            // now create file new but with same filename\r\n            FileWriter fileWriter = new FileWriter(f);\r\n            PrintWriter printWriter = new PrintWriter(fileWriter);\r\n            // insert former existing text:\r\n            String[] strWrite = new String[vBuffer.size()];\r\n            vBuffer.copyInto(strWrite);\r\n            for (int i = 0; i < (vBuffer.size()); i++) {\r\n                printWriter.println(strWrite[i]);\r\n            }\r\n            // add the new text now:\r\n            printWriter.println(text);\r\n            printWriter.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}'),(158,'analyzeBoard(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)','24','ChessEngineImpl','/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}'),(159,'computeBestPly()','de.java_chess.javaChess.engine.ChessEngineImpl.computeBestPly()','24','ChessEngineImpl','/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\npublic Ply computeBestPly() {\r\n    _bestPly = null;// Remove ply from last computation.\r\n\r\n    long startTime = System.currentTimeMillis();\r\n    if (inOpeningBook()) {\r\n        _bestPly = getOpeningBook().getOpeningBookPly();\r\n        if ((_bestPly) == null) {\r\n            // If theres no ply in the opening book.\r\n            setInOpeningBook(false);\r\n        }\r\n    }\r\n    if ((_bestPly) == null) {\r\n        // If we dont have a ply yet\r\n        start();\r\n        try {\r\n            Thread.sleep(getMaximumSearchTime());\r\n            setSearchStop(true);\r\n            // if( this.bFixedTime == false) {\r\n            _searchThread.join();// Wait for the search thread to end the search at this search depth.\r\n\r\n            // }\r\n            _searchThread = null;// Remove the thread, so it can be recreated for the next move.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n    long usedTime = (System.currentTimeMillis()) - startTime;\r\n    if ((_bestPly) != null) {\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOut = new StringBuffer();\r\n            sOut.append(\"Best ply: \");\r\n            sOut.append(_bestPly.getPly().toString());\r\n            sOut.append(\" with score \");\r\n            sOut.append(_bestPly.getScore());\r\n            sOut.append(\" and search depth \");\r\n            sOut.append(getSearchDepth());\r\n            this._enginePanel.modifyText(sOut.toString());\r\n            sOut = new StringBuffer();\r\n            sOut.append(\"Analyzed boards: \");\r\n            sOut.append(getAnalyzedBoards());\r\n            sOut.append(\" in \");\r\n            sOut.append(usedTime);\r\n            sOut.append(\" ms\");\r\n            this._enginePanel.modifyText(sOut.toString());\r\n        }\r\n        if ((this._statusPanel) != null)\r\n            this._statusPanel.setStatusText(\"Your turn...\");\r\n\r\n        return _bestPly.getPly();\r\n    }\r\n    return null;\r\n}'),(160,'createLogFile()','de.java_chess.javaChess.engine.ChessEngineImpl.createLogFile()','24','ChessEngineImpl','/**\r\n * Initially create a logfile\r\n */\r\nprivate void createLogFile() {\r\n    File homedir = new File(System.getProperty(\"user.home\"));\r\n    f = new File(homedir, ChessEngineImpl.LOG_FILENAME);\r\n    try {\r\n        FileWriter fileWriter = new FileWriter(f);\r\n        PrintWriter printWriter = new PrintWriter(fileWriter);\r\n        printWriter.println(\"## Java-Chess Engine Logfile, do not edit! ##\");\r\n        printWriter.println(\"## For internal use only! ##\");\r\n        printWriter.close();\r\n    } catch (IOException e) {\r\n    }\r\n}'),(161,'decreaseSearchDepth()','de.java_chess.javaChess.engine.ChessEngineImpl.decreaseSearchDepth()','24','ChessEngineImpl','/**\r\n * Decrease the search depth by 1.\r\n */\r\npublic final void decreaseSearchDepth() {\r\n    (_searchDepth)--;\r\n}'),(162,'getAnalyzedBoards()','de.java_chess.javaChess.engine.ChessEngineImpl.getAnalyzedBoards()','24','ChessEngineImpl','/**\r\n * Get the number of analyzed boards.\r\n *\r\n * @return The number of analyzed boards.\r\n */\r\npublic final long getAnalyzedBoards() {\r\n    return _analyzedBoards;\r\n}'),(163,'getBoard()','de.java_chess.javaChess.engine.ChessEngineImpl.getBoard()','24','ChessEngineImpl','/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic Board getBoard() {\r\n    return _board;\r\n}'),(164,'getCurrentGameState(boolean)','de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)','24','ChessEngineImpl','/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * 		True, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}'),(165,'getGame()','de.java_chess.javaChess.engine.ChessEngineImpl.getGame()','24','ChessEngineImpl','/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(166,'getHashSize()','de.java_chess.javaChess.engine.ChessEngineImpl.getHashSize()','24','ChessEngineImpl','/**\r\n * Returns the hash size\r\n *\r\n * @return The hashsize\r\n */\r\npublic int getHashSize() {\r\n    return this.getHashtable().getMaximumSize();\r\n}'),(167,'getHashtable()','de.java_chess.javaChess.engine.ChessEngineImpl.getHashtable()','24','ChessEngineImpl','/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}'),(168,'getMaximumSearchTime()','de.java_chess.javaChess.engine.ChessEngineImpl.getMaximumSearchTime()','24','ChessEngineImpl','/**\r\n * Get the maximum search time.\r\n *\r\n * @return The maximum search time.\r\n */\r\npublic final int getMaximumSearchTime() {\r\n    return _maxSearchTime;\r\n}'),(169,'getMenu()','de.java_chess.javaChess.engine.ChessEngineImpl.getMenu()','24','ChessEngineImpl','/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu engineMenu = new JMenu(\"Engine\");\r\n    // Add a toggle item for to the permanent brain.\r\n    engineMenu.add((_permanentBrainMenuItem = new JCheckBoxMenuItem(\"Use permanent brain\", usePermanentBrain())));\r\n    _permanentBrainMenuItem.addActionListener(this);\r\n    // Add a menu for the maximum search time\r\n    JMenu searchTimeMenu = new JMenu(\"Search time\");\r\n    // Add a sub-menu for fixed time.\r\n    JMenu searchTimeSubMenuFix = new JMenu(\"Fixed time\");\r\n    // Add a sub-menu for average time.\r\n    JMenu searchTimeSubMenuAv = new JMenu(\"Average time\");\r\n    // Add various options for the fixed search time\r\n    // (maybe a user defined search time should be added, too).\r\n    buttonGroupSearchTime = new ButtonGroup();\r\n    _fixSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _fixSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _fixSearchTimeMenuItem[st].addActionListener(this);\r\n        if ((_searchTime[st]) == 5) {\r\n            // set initially 5 sec max search time:\r\n            _fixSearchTimeMenuItem[st].setSelected(true);\r\n            this.setMaximumSearchTime(5000);\r\n        }\r\n        buttonGroupSearchTime.add(_fixSearchTimeMenuItem[st]);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuFix.add(_fixSearchTimeMenuItem[st]);\r\n    }\r\n    // Add various options for the average search time\r\n    _avSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _avSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _avSearchTimeMenuItem[st].addActionListener(this);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuAv.add(_avSearchTimeMenuItem[st]);\r\n        buttonGroupSearchTime.add(_avSearchTimeMenuItem[st]);\r\n    }\r\n    searchTimeMenu.add(searchTimeSubMenuFix);\r\n    searchTimeMenu.add(searchTimeSubMenuAv);\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(searchTimeMenu);\r\n    // Add a menu for the hashtable size.\r\n    JMenu hashtableSizeMenu = new JMenu(\"Hashtable size\");\r\n    // Add various options for the hashtable size.\r\n    this.buttonGroupHashSize = new ButtonGroup();\r\n    _hashtableSizeMenuItem = new JRadioButtonMenuItem[_hashtableSizes.length];\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        _hashtableSizeMenuItem[hts] = new JRadioButtonMenuItem(((\"\" + (_hashtableSizes[hts])) + \" entries\"));\r\n        _hashtableSizeMenuItem[hts].addActionListener(this);\r\n        if ((_hashtableSizes[hts]) == 10000) {\r\n            _hashtableSizeMenuItem[hts].setSelected(true);\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n        // Add the current search time menu item to its menu.\r\n        hashtableSizeMenu.add(_hashtableSizeMenuItem[hts]);\r\n        this.buttonGroupHashSize.add(_hashtableSizeMenuItem[hts]);\r\n    }\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(hashtableSizeMenu);\r\n    // Add a menu item to read openings from PGN files.\r\n    engineMenu.addSeparator();\r\n    engineMenu.add(new LoadOpeningsAction(getOpeningBook()));\r\n    // Return the engine menu.\r\n    return engineMenu;\r\n}'),(170,'getOpeningBook()','de.java_chess.javaChess.engine.ChessEngineImpl.getOpeningBook()','24','ChessEngineImpl','/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}'),(171,'getPermanentBrain()','de.java_chess.javaChess.engine.ChessEngineImpl.getPermanentBrain()','24','ChessEngineImpl','/**\r\n * Get the permanent brain.\r\n *\r\n * @return The permanent brain.\r\n */\r\npublic final PermanentBrain getPermanentBrain() {\r\n    return _permanentBrain;\r\n}'),(172,'getSearchDepth()','de.java_chess.javaChess.engine.ChessEngineImpl.getSearchDepth()','24','ChessEngineImpl','/**\r\n * Get the current search depth.\r\n *\r\n * @return The current search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}'),(173,'getStatusDisplayString()','de.java_chess.javaChess.engine.ChessEngineImpl.getStatusDisplayString()','24','ChessEngineImpl','/**\r\n * Returns the status string to display in status bar\r\n */\r\npublic String getStatusDisplayString() {\r\n    String retString = ((((\"HashSize: \" + (this.getHashSize())) + \" entries; \") + \"Search time: \") + ((this.getMaximumSearchTime()) / 1000)) + \"sec\";\r\n    if (this.isFixedTime()) {\r\n        retString += \" fix\";\r\n    } else {\r\n        retString += \" average\";\r\n    }\r\n    return retString;\r\n}'),(174,'getUserPlies()','de.java_chess.javaChess.engine.ChessEngineImpl.getUserPlies()','24','ChessEngineImpl','/**\r\n * Get all the potential plies for the human player.\r\n *\r\n * @return All the potential plies for the human player.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    return _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), (!(isWhite())));\r\n}'),(175,'inOpeningBook()','de.java_chess.javaChess.engine.ChessEngineImpl.inOpeningBook()','24','ChessEngineImpl','/**\r\n * Get the flag to indicate, if we are still in the opening book.\r\n *\r\n * @return true, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final boolean inOpeningBook() {\r\n    return _inOpeningBook;\r\n}'),(176,'increaseAnalyzedBoards()','de.java_chess.javaChess.engine.ChessEngineImpl.increaseAnalyzedBoards()','24','ChessEngineImpl','/**\r\n * Increase the number of analyzed boards by 1.\r\n */\r\npublic final void increaseAnalyzedBoards() {\r\n    (_analyzedBoards)++;\r\n}'),(177,'increaseSearchDepth()','de.java_chess.javaChess.engine.ChessEngineImpl.increaseSearchDepth()','24','ChessEngineImpl','/**\r\n * Increase the search depth by 1.\r\n */\r\npublic final void increaseSearchDepth() {\r\n    (_searchDepth)++;\r\n}'),(178,'isFixedTime()','de.java_chess.javaChess.engine.ChessEngineImpl.isFixedTime()','24','ChessEngineImpl','/**\r\n * Returns whether the search time is fixed or not.\r\n *\r\n * @return Is the search time fixed?\r\n */\r\npublic boolean isFixedTime() {\r\n    return this.bFixedTime;\r\n}'),(179,'isSearchStop()','de.java_chess.javaChess.engine.ChessEngineImpl.isSearchStop()','24','ChessEngineImpl','/**\r\n * Check, if a search should be stopped.\r\n *\r\n * @return true, if the search should be stopped.\r\n */\r\npublic final boolean isSearchStop() {\r\n    return _stopSearch;\r\n}'),(180,'isWhite()','de.java_chess.javaChess.engine.ChessEngineImpl.isWhite()','24','ChessEngineImpl','/**\r\n * Get the color of this engine.\r\n *\r\n * @param white\r\n * 		true, if the engine operates with the white pieces.\r\n */\r\npublic boolean isWhite() {\r\n    return _white;\r\n}'),(181,'minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)','de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)','24','ChessEngineImpl','/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(182,'notifyListeners()','de.java_chess.javaChess.engine.ChessEngineImpl.notifyListeners()','24','ChessEngineImpl','/**\r\n * Notifies all registered listeners that the engine has taken a change.\r\n */\r\npublic void notifyListeners() {\r\n    Iterator iterator = listeners.iterator();\r\n    while (iterator.hasNext()) {\r\n        EngineStatusListener listener = ((EngineStatusListener) (iterator.next()));\r\n        listener.engineStatusChanged(this);\r\n    } \r\n}'),(183,'reset()','de.java_chess.javaChess.engine.ChessEngineImpl.reset()','24','ChessEngineImpl','// Methods\r\n/**\r\n * Reset the engine for a new game.\r\n */\r\npublic void reset() {\r\n    setInOpeningBook(true);// Default is, that we are in the opening book.\r\n\r\n    getHashtable().reset();// Reset the hash tables.\r\n\r\n    // Remove the engine status messages.\r\n    if ((_enginePanel) != null) {\r\n        _enginePanel.setText(\"\");\r\n    }\r\n    // After a reset, the user is about to move.\r\n    if ((this._statusPanel) != null) {\r\n        this._statusPanel.setStatusText(\"Your turn...\");\r\n    }\r\n    // Start the permanent brain, if the user wants it to be used.\r\n    startPermanentBrain();\r\n    // Reset the last user ply.\r\n    _lastUserPly = null;\r\n}'),(184,'run()','de.java_chess.javaChess.engine.ChessEngineImpl.run()','24','ChessEngineImpl','/**\r\n * The main method of the search thread.\r\n */\r\npublic void run() {\r\n    // setAnalyzedBoards( 0L);  // Is done in the permanent brain now.\r\n    setSearchDepth(0);\r\n    // Try to get a move from the permanent brain.\r\n    PreComputedPly permanentBrainPly = (usePermanentBrain()) ? getPermanentBrain().getPlyForUserPly(_lastUserPly) : null;\r\n    // If we actually have a precomputed ply, adjust the search parameters.\r\n    if (permanentBrainPly != null) {\r\n        _bestPly = permanentBrainPly.getPly();\r\n        setSearchDepth(permanentBrainPly.getSearchDepth());// depth is increased before next search!\r\n\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOutput = new StringBuffer();\r\n            sOutput.append(\"Best ply for search depth \");\r\n            sOutput.append(getSearchDepth());\r\n            sOutput.append(\" is \");\r\n            sOutput.append(_bestPly.getPly().toString());\r\n            sOutput.append(\" with score \");\r\n            sOutput.append(_bestPly.getScore());\r\n            this._enginePanel.modifyText(sOutput.toString());\r\n        }\r\n    }\r\n    // The following search is rather inefficent at the moment, since we should try to get a principal variant\r\n    // from a search, so we can presort the plies for the next search.\r\n    do {\r\n        increaseSearchDepth();\r\n        AnalyzedPly searchDepthResult = null;\r\n        try {\r\n            searchDepthResult = startMinimaxAlphaBeta(isWhite());\r\n        } catch (InterruptedException ignored) {\r\n            // The search was just interrupted here, so we dont have to throw this exception...\r\n            decreaseSearchDepth();// But the search depth is 1 too high.\r\n\r\n        }\r\n        if (searchDepthResult != null) {\r\n            // The exception might not be the only case, where a null is returned, so keep\r\n            // this additional test.\r\n            if ((this._statusPanel) != null)\r\n                this._statusPanel.setStatusText(\"Thinking...\");\r\n\r\n            _bestPly = searchDepthResult;\r\n            if ((this._enginePanel) != null) {\r\n                StringBuffer sOutput = new StringBuffer();\r\n                sOutput.append(\"Best ply for search depth \");\r\n                sOutput.append(getSearchDepth());\r\n                sOutput.append(\" is \");\r\n                sOutput.append(_bestPly.getPly().toString());\r\n                sOutput.append(\" with score \");\r\n                sOutput.append(_bestPly.getScore());\r\n                this._enginePanel.modifyText(sOutput.toString());\r\n            }\r\n        }\r\n        // If search depth 1 was completed and no valid ply was found,\r\n        // it seems that the computer is checkmate and the search can be aborted.\r\n    } while ((!(isSearchStop())) && ((_bestPly) != null) );\r\n}'),(185,'setAnalyzedBoards(long)','de.java_chess.javaChess.engine.ChessEngineImpl.setAnalyzedBoards(long)','24','ChessEngineImpl','/**\r\n * Set the number of analyzed boards.\r\n *\r\n * @param analyzedBoards\r\n * 		The new number of analyzed boards.\r\n */\r\npublic final void setAnalyzedBoards(long analyzedBoards) {\r\n    _analyzedBoards = analyzedBoards;\r\n}'),(186,'setBoard(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.engine.ChessEngineImpl.setBoard(de.java_chess.javaChess.board.Board)','24','ChessEngineImpl','/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic void setBoard(Board board) {\r\n    _board = board;\r\n}'),(187,'setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)','de.java_chess.javaChess.engine.ChessEngineImpl.setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)','24','ChessEngineImpl','/**\r\n * Sets the EnginePanel to be able to output in the panel and not only with\r\n * System.out.println(...)\r\n *\r\n * @param panel\r\n * 		The EnginePanel to set\r\n */\r\npublic void setEnginePanel(EnginePanel panel) {\r\n    this._enginePanel = panel;\r\n}'),(188,'setGame(de.java_chess.javaChess.game.Game)','de.java_chess.javaChess.engine.ChessEngineImpl.setGame(de.java_chess.javaChess.game.Game)','24','ChessEngineImpl','/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(189,'setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)','de.java_chess.javaChess.engine.ChessEngineImpl.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)','24','ChessEngineImpl','/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * 		The new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}'),(190,'setInOpeningBook(boolean)','de.java_chess.javaChess.engine.ChessEngineImpl.setInOpeningBook(boolean)','24','ChessEngineImpl','/**\r\n * Set the flag to indicate, if we are still in the opening book.\r\n *\r\n * @param inBook\r\n * 		true, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final void setInOpeningBook(boolean inBook) {\r\n    _inOpeningBook = inBook;\r\n}'),(191,'setMaximumSearchTime(int)','de.java_chess.javaChess.engine.ChessEngineImpl.setMaximumSearchTime(int)','24','ChessEngineImpl','/**\r\n * Set the maximum search time.\r\n *\r\n * @param depth\r\n * 		The new search time.\r\n */\r\npublic final void setMaximumSearchTime(int time) {\r\n    _maxSearchTime = time;\r\n}'),(192,'setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)','de.java_chess.javaChess.engine.ChessEngineImpl.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)','24','ChessEngineImpl','/**\r\n * Set a new opening book.\r\n *\r\n * @param book\r\n * 		The new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}'),(193,'setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)','de.java_chess.javaChess.engine.ChessEngineImpl.setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)','24','ChessEngineImpl','/**\r\n * Set a new permanent brain.\r\n *\r\n * @param permanentBrain\r\n * 		The new permanent brain.\r\n */\r\nprivate final void setPermanentBrain(PermanentBrain permanentBrain) {\r\n    _permanentBrain = permanentBrain;\r\n}'),(194,'setSearchDepth(int)','de.java_chess.javaChess.engine.ChessEngineImpl.setSearchDepth(int)','24','ChessEngineImpl','/**\r\n * Set a new search depth.\r\n *\r\n * @param searchDepth\r\n * 		The new search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}'),(195,'setSearchStop(boolean)','de.java_chess.javaChess.engine.ChessEngineImpl.setSearchStop(boolean)','24','ChessEngineImpl','/**\r\n * Set the the stop flag for the search.\r\n *\r\n * @param stopFlag\r\n * 		The flag to stop the search engine.\r\n */\r\npublic final void setSearchStop(boolean stopFlag) {\r\n    _stopSearch = stopFlag;\r\n}'),(196,'setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)','de.java_chess.javaChess.engine.ChessEngineImpl.setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)','24','ChessEngineImpl','public void setStatusPanel(StatusPanel myPanel) {\r\n    if ((this._statusPanel) != myPanel)\r\n        this._statusPanel = myPanel;\r\n\r\n}'),(197,'setWhite(boolean)','de.java_chess.javaChess.engine.ChessEngineImpl.setWhite(boolean)','24','ChessEngineImpl','/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * 		flag to indicate if the engine operates on the white pieces.\r\n */\r\npublic void setWhite(boolean white) {\r\n    _white = white;\r\n}'),(198,'start()','de.java_chess.javaChess.engine.ChessEngineImpl.start()','24','ChessEngineImpl','/**\r\n * Start a new thread to search for a ply.\r\n */\r\npublic void start() {\r\n    if ((_searchThread) == null) {\r\n        setSearchStop(false);\r\n        _searchThread = new Thread(this);\r\n        _searchThread.start();\r\n    }\r\n}'),(199,'startMinimaxAlphaBeta(boolean)','de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)','24','ChessEngineImpl','/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}'),(200,'startPermanentBrain()','de.java_chess.javaChess.engine.ChessEngineImpl.startPermanentBrain()','24','ChessEngineImpl','/**\r\n * Start the computations of the permanent brain.\r\n */\r\npublic final void startPermanentBrain() {\r\n    // If the permanent brain is active.\r\n    if (usePermanentBrain()) {\r\n        getPermanentBrain().startComputation();\r\n    } else {\r\n        // Since the permanent brain cannot reset the counter,\r\n        // I do it here.\r\n        setAnalyzedBoards(0L);\r\n    }\r\n}'),(201,'stopPermanentBrain()','de.java_chess.javaChess.engine.ChessEngineImpl.stopPermanentBrain()','24','ChessEngineImpl','/**\r\n * Stop the computations of the permanent brain.\r\n */\r\npublic final void stopPermanentBrain() {\r\n    getPermanentBrain().stopComputation();\r\n}'),(202,'usePermanentBrain()','de.java_chess.javaChess.engine.ChessEngineImpl.usePermanentBrain()','24','ChessEngineImpl','/**\r\n * Check, if the permanent brain should be used.\r\n *\r\n * @return A flag, that indicates, if the permanent brain should be used.\r\n */\r\nprivate final boolean usePermanentBrain() {\r\n    return _usePermanentBrain;\r\n}'),(203,'validateUserPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)','24','ChessEngineImpl','/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}'),(204,'-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)','de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)','25','PlyGenerator','// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}'),(205,'-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)','de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)','25','PlyGenerator','/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param board\r\n * 		The board to operate on.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}'),(206,'addAbsolutePlies(long,int,int,int)','de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)','25','PlyGenerator','/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(207,'addCastlingPly(int,boolean)','de.java_chess.javaChess.engine.PlyGenerator.addCastlingPly(int,boolean)','25','PlyGenerator','/**\r\n * Add a castling ply.\r\n *\r\n * @param source\r\n * 		The position square of the king.\r\n * @param goesLeft\r\n * 		The flag that indicates if the castling goes to the left.\r\n */\r\nprivate final void addCastlingPly(int source, boolean goesLeft) {\r\n    addPly(new CastlingPlyImpl(new PositionImpl(source), goesLeft), REGULAR_PLY);\r\n}'),(208,'addPliesForBishopPos(int)','de.java_chess.javaChess.engine.PlyGenerator.addPliesForBishopPos(int)','25','PlyGenerator','/**\r\n * Add the plies for a bishop position.\r\n *\r\n * @param square\r\n * 		The square index of the bishop pos.\r\n */\r\nprivate final void addPliesForBishopPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    int squareRow = square >> 3;\r\n    int squareLine = square & 7;\r\n    long bitmask;\r\n    if (squareRow > 0) {\r\n        // If we are not on row 1\r\n        if (squareLine < 7) {\r\n            // Compute plies to the lower right.\r\n            square -= 7;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 7;\r\n                bitmask >>>= 7;\r\n            } \r\n        }\r\n        if (squareLine > 0) {\r\n            // Compute plies to the lower left.\r\n            square = orgPos - 9;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 9;\r\n                bitmask >>>= 9;\r\n            } \r\n        }\r\n    }\r\n    if (squareRow < 7) {\r\n        if (squareLine > 0) {\r\n            // Compute plies to the upper left.\r\n            square = orgPos + 7;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 7;\r\n                bitmask <<= 7;\r\n            } \r\n        }\r\n        if (squareLine < 7) {\r\n            // Compute plies to the upper right.\r\n            square = orgPos + 9;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 9;\r\n                bitmask <<= 9;\r\n            } \r\n        }\r\n    }\r\n}'),(209,'addPliesForBishops()','de.java_chess.javaChess.engine.PlyGenerator.addPliesForBishops()','25','PlyGenerator','/**\r\n * Add the plies for bishops.\r\n */\r\npublic final void addPliesForBishops() {\r\n    long bishopPositions = getBoard().getPositionOfPieces((_white ? ((Piece.BISHOP) << 1) | 1 : (Piece.BISHOP) << 1));\r\n    while (bishopPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(bishopPositions);\r\n        addPliesForBishopPos(highestBit);\r\n        bishopPositions &= ~(1L << highestBit);\r\n    } \r\n}'),(210,'addPliesForKing()','de.java_chess.javaChess.engine.PlyGenerator.addPliesForKing()','25','PlyGenerator','/**\r\n * Add all the plies for the king of the current color.\r\n */\r\nprivate final void addPliesForKing() {\r\n    long opponentKingPosition = getBoard().getPositionOfPieces((_white ? (Piece.KING) << 1 : ((Piece.KING) << 1) | 1));\r\n    int highestBit = BitUtils.getHighestBit(getBoard().getPositionOfPieces((_white ? ((Piece.KING) << 1) + 1 : (Piece.KING) << 1)));\r\n    long restrictedSquares = _kingMask[BitUtils.getHighestBit(opponentKingPosition)];\r\n    long curMoves = ((_kingMask[highestBit]) & ((_emptySquares) | (_attackablePieces))) & (~restrictedSquares);\r\n    int startBitRange = highestBit - 9;\r\n    if (startBitRange < 0) {\r\n        startBitRange = 0;\r\n    }\r\n    int endBitRange = highestBit + 9;\r\n    if (endBitRange > 63) {\r\n        endBitRange = 63;\r\n    }\r\n    addAbsolutePlies(curMoves, startBitRange, endBitRange, highestBit);\r\n    // Check for castling\r\n    if (_white) {\r\n        // If the king has not been moved and is not in check\r\n        if ((!(getGame().hasBeenMoved(new PositionImpl(4)))) && (!(getAnalyzer().isInCheck(getBoard(), true)))) {\r\n            long rookPositions = getBoard().getPositionOfPieces((((Piece.ROOK) << 1) + 1));\r\n            if (((!(getGame().hasBeenMoved(new PositionImpl(0)))) && (((_emptySquares) & 14L) == 14L)) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(4), new PositionImpl(2)))), true) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(4), new PositionImpl(3), false)))), true)))) {\r\n                // The addPly method checks for this check anyway, so it can be outcommented here...\r\n                addCastlingPly(4, true);\r\n            }\r\n            if (((!(getGame().hasBeenMoved(new PositionImpl(7)))) && (((_emptySquares) & 96L) == 96L)) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(4), new PositionImpl(6)))), true) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(4), new PositionImpl(5), false)))), true)))) {\r\n                addCastlingPly(4, false);\r\n            }\r\n        }\r\n    } else {\r\n        if ((!(getGame().hasBeenMoved(new PositionImpl(60)))) && (!(getAnalyzer().isInCheck(getBoard(), false)))) {\r\n            long rookPositions = getBoard().getPositionOfPieces(((Piece.ROOK) << 1));\r\n            if (((!(getGame().hasBeenMoved(new PositionImpl(56)))) && (((_emptySquares) & (14L << 56)) == (14L << 56))) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(60), new PositionImpl(58)))), false) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(60), new PositionImpl(59), false)))), false)))) {\r\n                addCastlingPly((4 + 56), true);\r\n            }\r\n            if (((getGame().hasBeenMoved(new PositionImpl(63))) && (((_emptySquares) & 96L) == 96L)) && /* && !getAnalyzer().isInCheck( (BitBoard)(getBoard().getBoardAfterPly( new PlyImpl( new PositionImpl(60), new PositionImpl(62)))), false) */\r\n            (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(new PlyImpl(new PositionImpl(60), new PositionImpl(61), false)))), false)))) {\r\n                addCastlingPly((4 + 56), false);\r\n            }\r\n        }\r\n    }\r\n}'),(211,'addPliesForKnights()','de.java_chess.javaChess.engine.PlyGenerator.addPliesForKnights()','25','PlyGenerator','/**\r\n * Add all the plies for knights of the current color.\r\n */\r\nprivate final void addPliesForKnights() {\r\n    long knightPositions = getBoard().getPositionOfPieces((_white ? ((Piece.KNIGHT) << 1) | 1 : (Piece.KNIGHT) << 1));\r\n    while (knightPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(knightPositions);\r\n        long curMoves = (_knightMask[highestBit]) & ((_emptySquares) | (_attackablePieces));\r\n        int startBitRange = highestBit - 17;\r\n        if (startBitRange < 0) {\r\n            startBitRange = 0;\r\n        }\r\n        int endBitRange = highestBit + 17;\r\n        if (endBitRange > 63) {\r\n            endBitRange = 63;\r\n        }\r\n        addAbsolutePlies(curMoves, startBitRange, endBitRange, highestBit);\r\n        knightPositions &= ~(1L << highestBit);\r\n    } \r\n}'),(212,'addPliesForPawns()','de.java_chess.javaChess.engine.PlyGenerator.addPliesForPawns()','25','PlyGenerator','/**\r\n * Add all the plies for pawns of the current color.\r\n */\r\nprivate final void addPliesForPawns() {\r\n    if (_white) {\r\n        // Get the positions of all pawns\r\n        long pawnPos = getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1));\r\n        // Add all the diagonal attacks\r\n        addRelativePliesUpward((((pawnPos & (BitBoard._NOT_LINE_H)) << 9) & (_attackablePieces)), 17, 63, (-9));\r\n        addRelativePliesUpward((((pawnPos & (BitBoard._NOT_LINE_A)) << 7) & (_attackablePieces)), 16, 62, (-7));\r\n        // Check for a en-passent attack\r\n        if ((getLastPly()) != null) {\r\n            Position destination = getLastPly().getDestination();\r\n            Piece piece = getBoard().getPiece(destination);\r\n            // The check for the color is sorta redundant, but during analysis the\r\n            // order of moves might be incorrect.\r\n            if (((piece != null) && ((piece.getType()) == (Piece.PAWN))) && ((piece.getColor()) == (Piece.BLACK))) {\r\n                int sourceIndex = getLastPly().getSource().getSquareIndex();\r\n                int destinationIndex = getLastPly().getDestination().getSquareIndex();\r\n                // If the pawn moved 2 squares\r\n                if ((sourceIndex - destinationIndex) == 16) {\r\n                    int attackableIndex = sourceIndex - 8;\r\n                    // Compute the bitmask for the pawn.\r\n                    long attackablePawnBitmask = 1L << attackableIndex;\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) << 9) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex - 9)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) << 7) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex - 7)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Add all the 2 square plies. Since the square in front of the pawn has to be free, I have to\r\n        // add the bit and with the shifted empty squares.\r\n        addRelativePliesUpward(((((pawnPos & (BitBoard._ROW_2)) & ((_emptySquares) >>> 8)) << 16) & (_emptySquares)), 24, 31, (-16));\r\n        // Add all the 1 square plies.\r\n        long movedPawns = (pawnPos << 8) & (_emptySquares);\r\n        addRelativePliesUpward((movedPawns & (BitBoard._NOT_ROW_8)), 16, 55, (-8));\r\n        // Now take care of the last row.\r\n        movedPawns &= BitBoard._ROW_8;\r\n        while (movedPawns != 0L) {\r\n            int destinationSquare = BitUtils.getHighestBit(movedPawns);\r\n            int sourceSquare = destinationSquare - 8;\r\n            // Add all transformation types as plies.\r\n            boolean capture = ((1L << destinationSquare) & (_attackablePieces)) != 0L;\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.QUEEN, capture, QUEEN_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.KNIGHT, capture, KNIGHT_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.ROOK, capture, ROOK_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.BISHOP, capture, BISHOP_TRANSFORMATION);\r\n            movedPawns &= ~(1L << destinationSquare);\r\n        } \r\n    } else {\r\n        // Get the positions of all pawns\r\n        long pawnPos = getBoard().getPositionOfPieces(((Piece.PAWN) << 1));\r\n        // Add all the diagonal attacks\r\n        addRelativePliesDownward((((pawnPos & (BitBoard._NOT_LINE_A)) >>> 9) & (_attackablePieces)), 46, 0, 9);\r\n        addRelativePliesDownward((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 7) & (_attackablePieces)), 47, 0, 7);\r\n        // Check for a en-passent attack\r\n        if ((getLastPly()) != null) {\r\n            Position destination = getLastPly().getDestination();\r\n            Piece piece = getBoard().getPiece(destination);\r\n            // The check for the color is sorta redundant, but during analysis the\r\n            // order of moves might be incorrect.\r\n            if (((piece != null) && ((piece.getType()) == (Piece.PAWN))) && ((piece.getColor()) == (Piece.BLACK))) {\r\n                int sourceIndex = getLastPly().getSource().getSquareIndex();\r\n                int destinationIndex = getLastPly().getDestination().getSquareIndex();\r\n                // If the pawn moved 2 squares\r\n                if ((destinationIndex - sourceIndex) == 16) {\r\n                    int attackableIndex = sourceIndex + 8;\r\n                    // Compute the bitmask for the pawn.\r\n                    long attackablePawnBitmask = 1L << attackableIndex;\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 9) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex + 9)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                    // Add the en passant attacks.\r\n                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 7) & attackablePawnBitmask) != 0L) {\r\n                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex + 7)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // Add all the 2 square plies. Since the square in front of the pawn has to be free, I have to\r\n        // add the bit and with the shifted empty squares.\r\n        addRelativePliesDownward(((((pawnPos & (BitBoard._ROW_7)) & ((_emptySquares) << 8)) >>> 16) & (_emptySquares)), 39, 32, 16);\r\n        // Add all the 1 square plies.\r\n        long movedPawns = (pawnPos >>> 8) & (_emptySquares);\r\n        addRelativePliesDownward((movedPawns & (BitBoard._NOT_ROW_1)), 56, 8, 8);\r\n        // Now take care of the last row.\r\n        movedPawns &= BitBoard._ROW_1;\r\n        while (movedPawns != 0L) {\r\n            int destinationSquare = BitUtils.getHighestBit(movedPawns);\r\n            int sourceSquare = destinationSquare + 8;\r\n            // Add all transformation types as plies.\r\n            boolean capture = ((1L << destinationSquare) & (_attackablePieces)) != 0L;\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.QUEEN, capture, QUEEN_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.KNIGHT, capture, KNIGHT_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.ROOK, capture, ROOK_TRANSFORMATION);\r\n            addTransformationPly(sourceSquare, destinationSquare, Piece.BISHOP, capture, BISHOP_TRANSFORMATION);\r\n            movedPawns &= ~(1L << destinationSquare);\r\n        } \r\n    }\r\n}'),(213,'addPliesForQueenPos(int)','de.java_chess.javaChess.engine.PlyGenerator.addPliesForQueenPos(int)','25','PlyGenerator','/**\r\n * Add the plies for one queen position.\r\n *\r\n * @param square\r\n * 		The square index of the queen position.\r\n */\r\nprivate final void addPliesForQueenPos(int square) {\r\n    // Since a queen can move like a bishop or rook,\r\n    // I simply add the plies of both for this position.\r\n    addPliesForBishopPos(square);\r\n    addPliesForRookPos(square);\r\n}'),(214,'addPliesForQueens()','de.java_chess.javaChess.engine.PlyGenerator.addPliesForQueens()','25','PlyGenerator','/**\r\n * Add the plies for queens.\r\n */\r\npublic final void addPliesForQueens() {\r\n    long queenPositions = getBoard().getPositionOfPieces((_white ? ((Piece.QUEEN) << 1) | 1 : (Piece.QUEEN) << 1));\r\n    while (queenPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(queenPositions);\r\n        addPliesForQueenPos(highestBit);\r\n        queenPositions &= ~(1L << highestBit);\r\n    } \r\n}'),(215,'addPliesForRookPos(int)','de.java_chess.javaChess.engine.PlyGenerator.addPliesForRookPos(int)','25','PlyGenerator','/**\r\n * Add the plies for one rook position.\r\n *\r\n * @param square\r\n * 		The square index of the rook pos.\r\n */\r\nprivate final void addPliesForRookPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    long bitmask;\r\n    // Compute plies to the left.\r\n    bitmask = 1L << square;\r\n    while ((square & 7) > 0) {\r\n        square -= 1;\r\n        bitmask >>>= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies downwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square > 8) {\r\n        square -= 8;\r\n        bitmask >>>= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies to the right.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while ((square & 7) < 7) {\r\n        square += 1;\r\n        bitmask <<= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies upwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square < 56) {\r\n        square += 8;\r\n        bitmask <<= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n}'),(216,'addPliesForRooks()','de.java_chess.javaChess.engine.PlyGenerator.addPliesForRooks()','25','PlyGenerator','/**\r\n * Add the plies for rooks.\r\n */\r\npublic final void addPliesForRooks() {\r\n    long rookPositions = getBoard().getPositionOfPieces((_white ? ((Piece.ROOK) << 1) | 1 : (Piece.ROOK) << 1));\r\n    while (rookPositions != 0) {\r\n        int highestBit = BitUtils.getHighestBit(rookPositions);\r\n        addPliesForRookPos(highestBit);\r\n        rookPositions &= ~(1L << highestBit);\r\n    } \r\n}'),(217,'addPly(de.java_chess.javaChess.ply.Ply,short)','de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)','25','PlyGenerator','/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * 		The ply to add.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}'),(218,'addRegularPly(int,int,boolean,short)','de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)','25','PlyGenerator','/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}'),(219,'addRelativePliesDownward(long,int,int,int)','de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)','25','PlyGenerator','/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}'),(220,'addRelativePliesUpward(long,int,int,int)','de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)','25','PlyGenerator','/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(221,'addTransformationPly(int,int,byte,boolean,short)','de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)','25','PlyGenerator','/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * 		The source square of the old piece.\r\n * @param destination\r\n * 		The destination square of the piece.\r\n * @param pieceType\r\n * 		The new piece type after the ply.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}'),(222,'getAnalyzer()','de.java_chess.javaChess.engine.PlyGenerator.getAnalyzer()','25','PlyGenerator','/**\r\n * Get a analyzer for check test.\r\n *\r\n * @return A analyzer for chess boards.\r\n */\r\nfinal BitBoardAnalyzer getAnalyzer() {\r\n    return _analyzer;\r\n}'),(223,'getBoard()','de.java_chess.javaChess.engine.PlyGenerator.getBoard()','25','PlyGenerator','/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal BitBoard getBoard() {\r\n    return _board;\r\n}'),(224,'getGame()','de.java_chess.javaChess.engine.PlyGenerator.getGame()','25','PlyGenerator','// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(225,'getHashtable()','de.java_chess.javaChess.engine.PlyGenerator.getHashtable()','25','PlyGenerator','/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}'),(226,'getKnightPlies(int)','de.java_chess.javaChess.engine.PlyGenerator.getKnightPlies(int)','25','PlyGenerator','/**\r\n * Get the knight plies for a given knight square.\r\n *\r\n * @param square\r\n * 		The square, where the knight is located.\r\n * @return All the knight plies as a 64 bit bitmask.\r\n */\r\npublic final long getKnightPlies(int square) {\r\n    return _knightMask[square];\r\n}'),(227,'getLastPly()','de.java_chess.javaChess.engine.PlyGenerator.getLastPly()','25','PlyGenerator','/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\nfinal Ply getLastPly() {\r\n    return getGame().getLastPly();\r\n    // return _lastPly;\r\n}'),(228,'getPliesForColor(boolean)','de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(boolean)','25','PlyGenerator','/**\r\n * Get the plies for a given game position and color.\r\n *\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(boolean white) {\r\n    resetPlies();\r\n    _white = white;// Store the color of the current player.\r\n\r\n    // Compute some bitmasks, so we dont have to compute them again for each piece type.\r\n    _emptySquares = getBoard().getEmptySquares();// Get the positions of the empty squares.\r\n\r\n    _attackablePieces = (getBoard().getAllPiecesForColor((!(_white)))) & (~(getBoard().getPositionOfPieces((((Piece.KING) << 1) | (_white ? 0 : 1)))));\r\n    // Add the possible plies for all piece types.\r\n    // I tried to sort this list according to the probality for a check, so\r\n    // the analyzer has a better chance to find it early.\r\n    addPliesForKnights();\r\n    addPliesForBishops();\r\n    addPliesForRooks();\r\n    addPliesForQueens();\r\n    addPliesForPawns();\r\n    addPliesForKing();\r\n    // Check, if theres a good ply for this board in the hash table.\r\n    Ply hashtablePly = getHashtable().getPly(getBoard(), _white);\r\n    if (hashtablePly != null) {\r\n        // If so, increase the score of this ply.\r\n        for (int index = 0; index < (_plyCounter); index++) {\r\n            if (_currentPlies[index].getPly().equals(hashtablePly)) {\r\n                _currentPlies[index].setScore(HASHTABLE_PLY);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // Presort the plies\r\n    presortPlies();\r\n    // Convert the plies to a array of the correct size\r\n    Ply[] plies = new Ply[_plyCounter];\r\n    int destIndex = 0;\r\n    for (int sourceIndex = (_plyCounter) - 1; sourceIndex >= 0;) {\r\n        plies[(destIndex++)] = _currentPlies[(sourceIndex--)].getPly();\r\n    }\r\n    return plies;\r\n}'),(229,'getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)','de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)','25','PlyGenerator','/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * 		The ply, that lead to the given board.\r\n * @param board\r\n * 		The board with the game position.\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}'),(230,'precomputeKingPlies()','de.java_chess.javaChess.engine.PlyGenerator.precomputeKingPlies()','25','PlyGenerator','/**\r\n * Compute the king moves for each square in advance.\r\n */\r\nprivate final void precomputeKingPlies() {\r\n    for (int i = 0; i < 64; i++) {\r\n        long currentMask = 0L;\r\n        int line = i & 7;\r\n        int row = i >> 3;\r\n        for (int currentPlyIndex = 0; currentPlyIndex < (PlyGenerator._kingPlyOffset.length); currentPlyIndex++) {\r\n            int[] curOffsets = PlyGenerator._kingPlyOffset[currentPlyIndex];\r\n            int targetRow = row + (curOffsets[1]);\r\n            int targetLine = line + (curOffsets[0]);\r\n            if ((((targetRow >= 0) && (targetRow < 8)) && (targetLine >= 0)) && (targetLine < 8)) {\r\n                currentMask |= 1L << ((targetRow << 3) + targetLine);\r\n            }\r\n        }\r\n        _kingMask[i] = currentMask;\r\n    }\r\n}'),(231,'precomputeKnightPlies()','de.java_chess.javaChess.engine.PlyGenerator.precomputeKnightPlies()','25','PlyGenerator','/**\r\n * Compute the knight plies for each square. This is done at startup,\r\n * so we can get the plies by a simple array access.\r\n */\r\nprivate final void precomputeKnightPlies() {\r\n    for (int i = 0; i < 64; i++) {\r\n        long currentMask = 0L;\r\n        int line = i & 7;\r\n        int row = i >> 3;\r\n        for (int currentPlyIndex = 0; currentPlyIndex < (PlyGenerator._knightPlyOffset.length); currentPlyIndex++) {\r\n            int[] curOffsets = PlyGenerator._knightPlyOffset[currentPlyIndex];\r\n            int targetRow = row + (curOffsets[1]);\r\n            int targetLine = line + (curOffsets[0]);\r\n            if ((((targetRow >= 0) && (targetRow < 8)) && (targetLine >= 0)) && (targetLine < 8)) {\r\n                currentMask |= 1L << ((targetRow << 3) + targetLine);\r\n            }\r\n        }\r\n        _knightMask[i] = currentMask;\r\n    }\r\n}'),(232,'presortPlies()','de.java_chess.javaChess.engine.PlyGenerator.presortPlies()','25','PlyGenerator','/**\r\n * Presort the scored plies.\r\n */\r\nprivate final void presortPlies() {\r\n    if ((_plyCounter) > 1) {\r\n        // Check the array size, so the sort methods dont have to do it.\r\n        quickersort(0, ((_plyCounter) - 1));\r\n    }\r\n}'),(233,'quickersort(int,int)','de.java_chess.javaChess.engine.PlyGenerator.quickersort(int,int)','25','PlyGenerator','/**\r\n * Perform a combined quick-/shakersort on a ply partition.\r\n *\r\n * @param l\r\n * 		The left bound of the array partition.\r\n * @param r\r\n * 		The right bound of the array partition.\r\n */\r\nprivate final void quickersort(int l, int r) {\r\n    int i = l;\r\n    int j = r;\r\n    AnalyzedPly x = _currentPlies[((l + r) / 2)];\r\n    do {\r\n        while ((_currentPlies[i].getScore()) > (x.getScore())) {\r\n            i++;\r\n        } \r\n        while ((x.getScore()) > (_currentPlies[j].getScore())) {\r\n            j--;\r\n        } \r\n        if (i <= j) {\r\n            AnalyzedPly w = _currentPlies[i];\r\n            _currentPlies[(i++)] = _currentPlies[j];\r\n            _currentPlies[(j--)] = w;\r\n        }\r\n    } while (i <= j );\r\n    if (l < j) {\r\n        if ((l - j) > 7) {\r\n            quickersort(l, j);\r\n        } else {\r\n            shakersort(l, j);\r\n        }\r\n    }\r\n    if (i < r) {\r\n        if ((r - i) > 7) {\r\n            quickersort(i, r);\r\n        } else {\r\n            shakersort(i, r);\r\n        }\r\n    }\r\n}'),(234,'resetPlies()','de.java_chess.javaChess.engine.PlyGenerator.resetPlies()','25','PlyGenerator','/**\r\n * Reset the ply buffer.\r\n */\r\nprivate final void resetPlies() {\r\n    _plyCounter = 0;\r\n}'),(235,'setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)','de.java_chess.javaChess.engine.PlyGenerator.setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)','25','PlyGenerator','/**\r\n * Set the last ply.\r\n *\r\n * @param lastPly\r\n * 		The last ply.\r\n */\r\n/* final void setLastPly( Ply lastPly) {\n// _lastPly = lastPly;\n}\n */\r\n/**\r\n * Set a analyzer for check tests.\r\n *\r\n * @param analyzer\r\n * 		The new analyzer to set.\r\n */\r\npublic final void setAnalyzer(BitBoardAnalyzer analyzer) {\r\n    _analyzer = analyzer;\r\n}'),(236,'setBoard(de.java_chess.javaChess.bitboard.BitBoard)','de.java_chess.javaChess.engine.PlyGenerator.setBoard(de.java_chess.javaChess.bitboard.BitBoard)','25','PlyGenerator','/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nfinal void setBoard(BitBoard board) {\r\n    _board = board;\r\n}'),(237,'setGame(de.java_chess.javaChess.game.Game)','de.java_chess.javaChess.engine.PlyGenerator.setGame(de.java_chess.javaChess.game.Game)','25','PlyGenerator','/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(238,'setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)','de.java_chess.javaChess.engine.PlyGenerator.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)','25','PlyGenerator','/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * 		The new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}'),(239,'shakersort(int,int)','de.java_chess.javaChess.engine.PlyGenerator.shakersort(int,int)','25','PlyGenerator','/**\r\n * Perform a shakersort on a ply partition.\r\n *\r\n * @param l\r\n * 		The left bound of the ply partition.\r\n * @param r\r\n * 		The right bound of the ply partition.\r\n */\r\nprivate final void shakersort(int l, int r) {\r\n    int i = l + 1;\r\n    int j = r;\r\n    int k = r;\r\n    do {\r\n        for (int h = j; h >= i; h--) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        i = k + 1;\r\n        for (int h = i; h <= j; h++) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        j = k - 1;\r\n    } while (i <= j );\r\n}'),(240,'getMaximumSize()','de.java_chess.javaChess.engine.hashtable.PlyHashtable.getMaximumSize()','26','PlyHashtable','/**\r\n * Get the maximum number of entries in the hashtable.\r\n *\r\n * @return The maximum number of entries in the hashtable.\r\n */\r\nint getMaximumSize();'),(241,'getPly(de.java_chess.javaChess.board.Board,boolean)','de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)','26','PlyHashtable','/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The board before the move.\r\n * @param white\r\n * 		Flag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);'),(242,'getSize()','de.java_chess.javaChess.engine.hashtable.PlyHashtable.getSize()','26','PlyHashtable','/**\r\n * Get the current number of entries.\r\n *\r\n * @return The current number of entries.\r\n */\r\nint getSize();'),(243,'pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)','de.java_chess.javaChess.engine.hashtable.PlyHashtable.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)','26','PlyHashtable','/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * 		The new entry, that the hashtable might store.\r\n */\r\nvoid pushEntry(PlyHashtableEntry ply);'),(244,'removeOldestEntry()','de.java_chess.javaChess.engine.hashtable.PlyHashtable.removeOldestEntry()','26','PlyHashtable','/**\r\n * Try to remove the oldest entry.\r\n */\r\nvoid removeOldestEntry();'),(245,'reset()','de.java_chess.javaChess.engine.hashtable.PlyHashtable.reset()','26','PlyHashtable','// Methods\r\n/**\r\n * Reset the hashtables for a new game.\r\n */\r\nvoid reset();'),(246,'setMaximumSize(int)','de.java_chess.javaChess.engine.hashtable.PlyHashtable.setMaximumSize(int)','26','PlyHashtable','/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * 		The new maximum number of entries.\r\n */\r\nvoid setMaximumSize(int maximumEntries);'),(247,'getBoard()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.getBoard()','27','PlyHashtableEntry','/**\r\n * Get the game position before the ply is applied.\r\n *\r\n * @return The board before the ply is applied.\r\n */\r\nBoard getBoard();'),(248,'getPly()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.getPly()','27','PlyHashtableEntry','/**\r\n * Get the ply.\r\n *\r\n * @return The ply.\r\n */\r\nPly getPly();'),(249,'getSearchDepth()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.getSearchDepth()','27','PlyHashtableEntry','/**\r\n * Get the search depth for the computed ply.\r\n *\r\n * @return The search depth for the computed ply.\r\n */\r\nint getSearchDepth();'),(250,'hashKey()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.hashKey()','27','PlyHashtableEntry','/**\r\n * Request a key for this entry.\r\n *\r\n * @return The key for this entry.\r\n */\r\nlong hashKey();'),(251,'isWhiteMove()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry.isWhiteMove()','27','PlyHashtableEntry','// Methods\r\n/**\r\n * Get the color, that is supposed to apply this ply.\r\n *\r\n * @return true, if white applies this ply.\r\n */\r\nboolean isWhiteMove();'),(252,'-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)','28','PlyHashtableEntryImpl','// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * 		The board before the ply.\r\n * @param ply\r\n * 		The ply to store.\r\n * @param searchDepth\r\n * 		The search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(253,'getBoard()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getBoard()','28','PlyHashtableEntryImpl','// Methods\r\n/**\r\n * Get the board of this entry.\r\n *\r\n * @return The board of this entry.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}'),(254,'getPly()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getPly()','28','PlyHashtableEntryImpl','/**\r\n * Get the ply.\r\n *\r\n * @return The ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}'),(255,'getSearchDepth()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getSearchDepth()','28','PlyHashtableEntryImpl','/**\r\n * Get the search depth for the computed ply.\r\n *\r\n * @return The search depth for the computed ply.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}'),(256,'hashKey()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey()','28','PlyHashtableEntryImpl','/**\r\n * Get the hashcode for this ply.\r\n *\r\n * @return A hashcode for this ply.\r\n */\r\npublic final long hashKey() {\r\n    return PlyHashtableEntryImpl.hashKey(getBoard(), isWhiteMove());\r\n}'),(257,'hashKey(de.java_chess.javaChess.board.Board,boolean)','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)','28','PlyHashtableEntryImpl','/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}'),(258,'isWhiteMove()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.isWhiteMove()','28','PlyHashtableEntryImpl','/**\r\n * Check, if its a move with white pieces.\r\n *\r\n * @return true, if its a move with white pieces.\r\n */\r\npublic final boolean isWhiteMove() {\r\n    return (getBoard().getPiece(getPly().getSource()).getColor()) == (Piece.WHITE);\r\n}'),(259,'setBoard(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setBoard(de.java_chess.javaChess.board.Board)','28','PlyHashtableEntryImpl','/**\r\n * Set a new board for this entry.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}'),(260,'setPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setPly(de.java_chess.javaChess.ply.Ply)','28','PlyHashtableEntryImpl','/**\r\n * Set the ply.\r\n *\r\n * @param ply\r\n * 		The ply to set.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(261,'setSearchDepth(int)','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setSearchDepth(int)','28','PlyHashtableEntryImpl','/**\r\n * Set the search depth for the computed ply.\r\n *\r\n * @param searchDepth\r\n * 		The search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}'),(262,'-init-(int)','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.-init-(int)','29','PlyHashtableImpl','// Constructors\r\n/**\r\n * Create a new hashtable instance with a given maximum size.\r\n *\r\n * @param maxSize\r\n * 		The maximum number of entries.\r\n */\r\npublic PlyHashtableImpl(int maxSize) {\r\n    _hashtable = new Hashtable();\r\n    _orderedList = new LinkedList();\r\n    setMaximumSize(maxSize);\r\n}'),(263,'getMaximumSize()','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getMaximumSize()','29','PlyHashtableImpl','/**\r\n * Get the maximum number of entries in the hashtable.\r\n *\r\n * @return The maximum number of entries in the hashtable.\r\n */\r\npublic final int getMaximumSize() {\r\n    return _maxSize;\r\n}'),(264,'getPly(de.java_chess.javaChess.board.Board,boolean)','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)','29','PlyHashtableImpl','/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(265,'getSize()','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getSize()','29','PlyHashtableImpl','/**\r\n * Get the current number of entries.\r\n *\r\n * @return The current number of entries.\r\n */\r\npublic final int getSize() {\r\n    return _hashtable.size();\r\n}'),(266,'pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)','29','PlyHashtableImpl','/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * 		The new entry, that the hashtable might store.\r\n */\r\npublic final void pushEntry(PlyHashtableEntry ply) {\r\n    // Compute and store the key for this ply.\r\n    Long hashKey = new Long(ply.hashKey());\r\n    // Check if this ply is not already in the hashtable\r\n    PlyHashtableEntry oldEntry = ((PlyHashtableEntry) (_hashtable.get(hashKey)));\r\n    if (oldEntry != null) {\r\n        // There is a entry with the same key\r\n        if ((oldEntry.getSearchDepth()) >= (ply.getSearchDepth())) {\r\n            return;// This entry shouldnt be replaced.\r\n\r\n        }\r\n    } else {\r\n        // Now we actually add a new entry to the table.\r\n        // Check, if the hashtable has not exceeded its maximum capacity\r\n        // and remove older entries, if necessary.\r\n        while ((getSize()) >= (getMaximumSize())) {\r\n            removeOldestEntry();\r\n        } \r\n    }\r\n    // Put the new ply into the hashtable\r\n    _hashtable.put(hashKey, ply);\r\n    // Append the new ply at the end of the list of plies.\r\n    // ATTENTION: this will only work, if theres only _one_\r\n    // ply for each key!\r\n    _orderedList.add(hashKey);\r\n}'),(267,'removeOldestEntry()','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.removeOldestEntry()','29','PlyHashtableImpl','/**\r\n * Try to remove the oldest entry.\r\n * ATTENTION: this version will only work, if theres only _one_ entry for each hashkey!\r\n */\r\npublic final void removeOldestEntry() {\r\n    // Get and remove the oldest ply from the ordered list.\r\n    _hashtable.remove(_orderedList.removeFirst());\r\n}'),(268,'reset()','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.reset()','29','PlyHashtableImpl','// Methods\r\n/**\r\n * Reset the hashtables for a new game.\r\n */\r\npublic void reset() {\r\n    _hashtable.clear();\r\n    // Remove all the entries from the hashtable.\r\n    _orderedList.clear();// And the ordered list.\r\n\r\n}'),(269,'setMaximumSize(int)','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.setMaximumSize(int)','29','PlyHashtableImpl','/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * 		The new maximum number of entries.\r\n */\r\npublic final void setMaximumSize(int maximumEntries) {\r\n    _maxSize = maximumEntries;\r\n    // Remove the oldest entries, if the current size\r\n    // is bigger than the new maximum size.\r\n    while ((getSize()) > (getMaximumSize())) {\r\n        removeOldestEntry();\r\n    } \r\n}'),(270,'-init-()','de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.-init-()','30','ZobristKeyImpl','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new key instance.\r\n */\r\nprivate ZobristKeyImpl() {\r\n    // Create a new multidimensional array.\r\n    _factors = new long[2][6][64];\r\n    Random rand = new Random();\r\n    for (int i = 0; i < 64; i++) {\r\n        for (int j = 0; j < 6; j++) {\r\n            _factors[0][j][i] = rand.nextLong();\r\n            _factors[1][j][i] = rand.nextLong();\r\n        }\r\n    }\r\n    _blackMoves = rand.nextLong();\r\n}'),(271,'computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)','de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)','30','ZobristKeyImpl','/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		Flag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}'),(272,'getInstance()','de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.getInstance()','30','ZobristKeyImpl','// Methods\r\n/**\r\n * Get the only instance of this class.\r\n */\r\npublic static final ZobristKeyImpl getInstance() {\r\n    if ((ZobristKeyImpl._instance) == null) {\r\n        ZobristKeyImpl._instance = new ZobristKeyImpl();\r\n    }\r\n    return ZobristKeyImpl._instance;\r\n}'),(273,'addPGNopening(java.io.File)','de.java_chess.javaChess.engine.opening_book.OpeningBook.addPGNopening(java.io.File)','31','OpeningBook','/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * 		The File to add to the opening book.\r\n */\r\nvoid addPGNopening(File file);'),(274,'doUserPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.opening_book.OpeningBook.doUserPly(de.java_chess.javaChess.ply.Ply)','31','OpeningBook','// Methods\r\n/**\r\n * Advance the game by one user ply.\r\n *\r\n * @param ply\r\n * 		The ply from the user.\r\n */\r\nvoid doUserPly(Ply ply);'),(275,'getOpeningBookPly()','de.java_chess.javaChess.engine.opening_book.OpeningBook.getOpeningBookPly()','31','OpeningBook','/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\nAnalyzedPly getOpeningBookPly();'),(276,'reset()','de.java_chess.javaChess.engine.opening_book.OpeningBook.reset()','31','OpeningBook','/**\r\n * Reset the opening book to the initial piece position.\r\n */\r\nvoid reset();'),(277,'-init-(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.-init-(de.java_chess.javaChess.notation.GameNotation)','32','OpeningBookImpl','// Constructors\r\n/**\r\n * Create a new instance of this class.\r\n *\r\n * @param notation\r\n * 		The notation of the current game.\r\n */\r\npublic OpeningBookImpl(GameNotation notation) {\r\n    setNotation(notation);\r\n    // Create a new dynamic array for the openings.\r\n    _openings = new ArrayList();\r\n    // Reset the opening book.\r\n    reset();\r\n}'),(278,'addPGNopening(java.io.File)','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.addPGNopening(java.io.File)','32','OpeningBookImpl','/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * 		The File to add to the opening book.\r\n */\r\npublic final void addPGNopening(File file) {\r\n    try {\r\n        PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n        GameNotation notation = pgnFile.readGame();\r\n        _openings.add(notation);\r\n        // System.out.println( \"DEBUG: added opening \n\" + notation.toString());\r\n    } catch (FileNotFoundException fe) {\r\n        JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (IOException ioe) {\r\n        JOptionPane.showMessageDialog(null, ((\"IO error while parsing file \" + (file.getName())) + \"!\"), \"IO error\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (RecognitionException re) {\r\n        JOptionPane.showMessageDialog(null, ((\"Error while parsing file \" + (file.getName())) + \"!\"), \"Error in PGN file\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (TokenStreamException te) {\r\n        System.err.print(\"Tokenstream exception\");\r\n    }\r\n}'),(279,'doUserPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.doUserPly(de.java_chess.javaChess.ply.Ply)','32','OpeningBookImpl','// Methods\r\n/**\r\n * The user just did a ply.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n */\r\npublic final void doUserPly(Ply ply) {\r\n    // If we are already in a opening, check if the current user\r\n    // move doesnt lead us out of the opening line.\r\n    if ((_currentOpening) != (-1)) {\r\n        if (!(isInOpening(_currentOpening))) {\r\n            _currentOpening = -1;\r\n        }\r\n    }\r\n}'),(280,'findOpening()','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.findOpening()','32','OpeningBookImpl','/**\r\n * Try to find a opening for the current game notation.\r\n *\r\n * @return The index of the found opening.\r\n */\r\nprivate final int findOpening() {\r\n    for (int i = 0; i < (_openings.size()); i++) {\r\n        if (isInOpening(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;// No opening found.\r\n\r\n}'),(281,'getNotation()','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getNotation()','32','OpeningBookImpl','/**\r\n * Get the notation of the current game.\r\n *\r\n * @return The notation of the current game.\r\n */\r\nprivate final GameNotation getNotation() {\r\n    return _notation;\r\n}'),(282,'getOpeningBookPly()','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getOpeningBookPly()','32','OpeningBookImpl','/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\npublic final AnalyzedPly getOpeningBookPly() {\r\n    // If we have no opening yet, try to find one.\r\n    if ((_currentOpening) == (-1)) {\r\n        _currentOpening = findOpening();\r\n    }\r\n    // Check, if we have found a opening.\r\n    if ((_currentOpening) != (-1)) {\r\n        // Check, if we have another ply in the opening.\r\n        int pliesMade = _notation.size();\r\n        GameNotation currentOpening = ((GameNotation) (_openings.get(_currentOpening)));\r\n        if ((currentOpening.size()) > pliesMade) {\r\n            return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)));\r\n        }\r\n    }\r\n    return null;// No ply found in the available opening books.\r\n\r\n}'),(283,'isInOpening(int)','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)','32','OpeningBookImpl','/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * 		The index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}'),(284,'reset()','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.reset()','32','OpeningBookImpl','/**\r\n * Reset the opening book to the initial piece position.\r\n */\r\npublic final void reset() {\r\n    _currentOpening = -1;\r\n}'),(285,'setNotation(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.setNotation(de.java_chess.javaChess.notation.GameNotation)','32','OpeningBookImpl','/**\r\n * Set the notation of the current game.\r\n *\r\n * @param notation\r\n * 		The notation of the current game.\r\n */\r\nprivate final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}'),(286,'-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)','de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)','33','LoadOpeningsAction','// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param book\r\n * 		The opening book, we are operating on.\r\n */\r\npublic LoadOpeningsAction(OpeningBook book) {\r\n    super(\"Load openings from PGN...\");\r\n    setOpeningBook(book);\r\n}'),(287,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.actionPerformed(java.awt.event.ActionEvent)','33','LoadOpeningsAction','// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load opening from pgn files\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    // Allow the user to select directories.\r\n    chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        processFileOrDirectory(file);\r\n    }\r\n}'),(288,'getOpeningBook()','de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.getOpeningBook()','33','LoadOpeningsAction','/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}'),(289,'processFileOrDirectory(java.io.File)','de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processFileOrDirectory(java.io.File)','33','LoadOpeningsAction','/**\r\n * Process a file or directory.\r\n *\r\n * @param file\r\n * 		The file to process.\r\n */\r\nprivate final void processFileOrDirectory(File file) {\r\n    // If this file is a directory, read all the files in it.\r\n    if (file.isDirectory()) {\r\n        String[] files = file.list();// Get the content of the directory\r\n\r\n        // Now create an absolute file from each name and process it.\r\n        for (int i = 0; i < (files.length); i++) {\r\n            processFileOrDirectory(new File(file, files[i]));\r\n        }\r\n    } else {\r\n        // This is a single file, so\r\n        // check, if it might be a PGN file.\r\n        if (SaveGameAsAction.getPGNFileFilter().accept(file)) {\r\n            processPGNfile(file);\r\n        }\r\n    }\r\n}'),(290,'processPGNfile(java.io.File)','de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processPGNfile(java.io.File)','33','LoadOpeningsAction','/**\r\n * Process a single PGN file.\r\n *\r\n * @param file\r\n * 		The PGN file to process.\r\n */\r\nprivate final void processPGNfile(File file) {\r\n    getOpeningBook().addPGNopening(file);\r\n}'),(291,'setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)','de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)','33','LoadOpeningsAction','/**\r\n * Set the opening book, we are operating on.\r\n *\r\n * @param book\r\n * 		The new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}'),(292,'-init-(de.java_chess.javaChess.engine.ChessEngine)','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.-init-(de.java_chess.javaChess.engine.ChessEngine)','34','PermanentBrain','// Constructors\r\n/**\r\n * Create a new PermanentBrain instance.\r\n *\r\n * @param engine\r\n * 		The used chess engine.\r\n */\r\npublic PermanentBrain(ChessEngine engine) {\r\n    setEngine(engine);\r\n}'),(293,'getEngine()','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getEngine()','34','PermanentBrain','// Methods\r\n/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nprivate final ChessEngine getEngine() {\r\n    return _engine;\r\n}'),(294,'getPlyForUserPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)','34','PermanentBrain','/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * 		The ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}'),(295,'getUserPlies()','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getUserPlies()','34','PermanentBrain','/**\r\n * Get the potential plies for a user.\r\n * (Required to validate a user ply.)\r\n *\r\n * @return The potential plies for a user.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    // Lazy computation for better performance.\r\n    if ((_userPlies) == null) {\r\n        _userPlies = getEngine().getUserPlies();\r\n    }\r\n    return _userPlies;// Return the user plies.\r\n\r\n}'),(296,'resetUserPlies()','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.resetUserPlies()','34','PermanentBrain','/**\r\n * Reset (remove) the user plies.\r\n */\r\npublic final void resetUserPlies() {\r\n    _userPlies = null;\r\n}'),(297,'run()','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.run()','34','PermanentBrain','/**\r\n * The actual search method.\r\n */\r\npublic void run() {\r\n    // Start with search depth 1\r\n    ((ChessEngineImpl) (getEngine())).setSearchDepth(1);\r\n    // Save the current board of the actual game.\r\n    Board currentBoard = getEngine().getBoard();// No clone() required at the moment.\r\n\r\n    // Get the user plies as a local variable.\r\n    Ply[] userPlies = getUserPlies();\r\n    // Let the minimax search run through.\r\n    ((ChessEngineImpl) (getEngine())).setSearchStop(false);\r\n    // Reset the number of analyzed boards.\r\n    ((ChessEngineImpl) (getEngine())).setAnalyzedBoards(0L);\r\n    while ((_searchThread) == (Thread.currentThread())) {\r\n        // Go through all the user plies and compute a response.\r\n        for (int i = 0; (i < (userPlies.length)) && ((_searchThread) == (Thread.currentThread())); i++) {\r\n            getEngine().setBoard(currentBoard.getBoardAfterPly(userPlies[i]));\r\n            try {\r\n                _computedPlies[i] = new PreComputedPlyImpl(((ChessEngineImpl) (getEngine())).startMinimaxAlphaBeta(getEngine().isWhite()), ((ChessEngineImpl) (getEngine())).getSearchDepth());\r\n            } catch (InterruptedException ignored) {\r\n                _computedPlies[i] = null;\r\n            }\r\n        }\r\n        // Increase the search depth and continue with another run.\r\n        ((ChessEngineImpl) (getEngine())).increaseSearchDepth();\r\n    } \r\n    // Restore the current board.\r\n    getEngine().setBoard(currentBoard);\r\n}'),(298,'setEngine(de.java_chess.javaChess.engine.ChessEngine)','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.setEngine(de.java_chess.javaChess.engine.ChessEngine)','34','PermanentBrain','/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * 		The new chess engine.\r\n */\r\nprivate final void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}'),(299,'startComputation()','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.startComputation()','34','PermanentBrain','/**\r\n * Start the computation of a response to the next user ply.\r\n */\r\npublic final void startComputation() {\r\n    // Stop the computation, if it was a reset.\r\n    stopComputation();\r\n    // Reset the permanent brain for the next user move.\r\n    resetUserPlies();\r\n    _computedPlies = new PreComputedPly[getUserPlies().length];\r\n    if ((_searchThread) == null) {\r\n        // Should always be null\r\n        _searchThread = new Thread(this);\r\n        _searchThread.start();\r\n    }\r\n}'),(300,'stopComputation()','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.stopComputation()','34','PermanentBrain','/**\r\n * Stop the computation of a response to the next user ply.\r\n */\r\npublic final void stopComputation() {\r\n    if ((_searchThread) != null) {\r\n        Thread savedThread = _searchThread;// Save the thread.\r\n\r\n        ((ChessEngineImpl) (getEngine())).setSearchStop(true);\r\n        _searchThread = null;\r\n        // Signal to finish.\r\n        try {\r\n            savedThread.join();// Use the copy to wait\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }// for the thread to finish.\r\n\r\n    }\r\n}'),(301,'getPly()','de.java_chess.javaChess.engine.permanent_brain.PreComputedPly.getPly()','35','PreComputedPly','// Methods\r\n/**\r\n * Get the computed ply.\r\n *\r\n * @return The computed ply.\r\n */\r\nAnalyzedPly getPly();'),(302,'getSearchDepth()','de.java_chess.javaChess.engine.permanent_brain.PreComputedPly.getSearchDepth()','35','PreComputedPly','/**\r\n * Get the search depth, that was used to compute this ply.\r\n *\r\n * @return The search depth for this ply.\r\n */\r\nint getSearchDepth();'),(303,'-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)','de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)','36','PreComputedPlyImpl','// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * 		The computed ply.\r\n * @param searchDepth\r\n * 		The used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(304,'getPly()','de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getPly()','36','PreComputedPlyImpl','// Methods\r\n/**\r\n * Get the computed ply.\r\n *\r\n * @return The computed ply.\r\n */\r\npublic final AnalyzedPly getPly() {\r\n    return _ply;\r\n}'),(305,'getSearchDepth()','de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getSearchDepth()','36','PreComputedPlyImpl','/**\r\n * Get the used search depth.\r\n *\r\n * @return The used search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}'),(306,'setPly(de.java_chess.javaChess.ply.AnalyzedPly)','de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setPly(de.java_chess.javaChess.ply.AnalyzedPly)','36','PreComputedPlyImpl','/**\r\n * Set the computed ply.\r\n *\r\n * @param ply\r\n * 		The computed ply.\r\n */\r\nprivate final void setPly(AnalyzedPly ply) {\r\n    _ply = ply;\r\n}'),(307,'setSearchDepth(int)','de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setSearchDepth(int)','36','PreComputedPlyImpl','/**\r\n * Set the used search depth.\r\n *\r\n * @param searchDepth\r\n * 		The used search depth.\r\n */\r\nprivate final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}'),(308,'-init-()','de.java_chess.javaChess.engine.test.AnalyzerTest1.-init-()','37','AnalyzerTest1','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic AnalyzerTest1() {\r\n    super(\"A simple analyzer test with a attack on the black queen\");\r\n}'),(309,'analyzerTest1()','de.java_chess.javaChess.engine.test.AnalyzerTest1.analyzerTest1()','37','AnalyzerTest1','/**\r\n * Run the actual test.\r\n */\r\nprivate void analyzerTest1() {\r\n    // Do the 1st analysis\r\n    short score1 = _analyzer.analyze(((BitBoard) (_board)), true);\r\n    // Move the pawn and attack a black pawn\r\n    _board.doPly(new PlyImpl(new PositionImpl(43), new PositionImpl(52), true));\r\n    // Analyze the board after the ply\r\n    short score2 = _analyzer.analyze(((BitBoard) (_board)), false);\r\n    // Check if the 2nd board is better for white.\r\n    TestCase.assertTrue(\"Analyzer did not recognize attack on black piece\", (score2 > score1));\r\n    // Now attack the black queen.\r\n    _board.doPly(new PlyImpl(new PositionImpl(52), new PositionImpl(59), true));\r\n    // Analyze the board again\r\n    short score3 = _analyzer.analyze(((BitBoard) (_board)), false);\r\n    TestCase.assertTrue(\"Analyzer does not recognize attack on black queen\", (score3 > score2));\r\n}'),(310,'runTest()','de.java_chess.javaChess.engine.test.AnalyzerTest1.runTest()','37','AnalyzerTest1','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    analyzerTest1();\r\n}'),(311,'setUp()','de.java_chess.javaChess.engine.test.AnalyzerTest1.setUp()','37','AnalyzerTest1','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, new PlyHashtableImpl(1000));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the black knight to f6\r\n    _board.doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move a white pawn to the 6th row\r\n    _board.doPly(new PlyImpl(new PositionImpl(11), new PositionImpl((11 + 32)), false));\r\n}'),(312,'-init-()','de.java_chess.javaChess.engine.test.AnalyzerTest2.-init-()','38','AnalyzerTest2','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic AnalyzerTest2() {\r\n    super(\"A simple analyzer test for a opening strategy\");\r\n}'),(313,'analyzerTest2()','de.java_chess.javaChess.engine.test.AnalyzerTest2.analyzerTest2()','38','AnalyzerTest2','/**\r\n * Run the actual test.\r\n */\r\nprivate void analyzerTest2() {\r\n    prepareTest();\r\n    // Move the black pawn to e5 and analyze the board\r\n    doPly(new PlyImpl(new PositionImpl(\"e7\"), new PositionImpl(\"e5\"), false));\r\n    // Do the 1st analysis\r\n    short score1 = _analyzer.analyze(((BitBoard) (_board)), true);\r\n    prepareTest();\r\n    doPly(new PlyImpl(new PositionImpl(\"g8\"), new PositionImpl(\"h6\"), false));\r\n    // Analyze the board after the ply\r\n    short score2 = _analyzer.analyze(((BitBoard) (_board)), false);\r\n    // Check if the 2nd board is better for white.\r\n    TestCase.assertTrue(\"Analyzer prefers pawn move\", (score2 > score1));\r\n}'),(314,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.AnalyzerTest2.doPly(de.java_chess.javaChess.ply.Ply)','38','AnalyzerTest2','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(315,'prepareTest()','de.java_chess.javaChess.engine.test.AnalyzerTest2.prepareTest()','38','AnalyzerTest2','/**\r\n * Prepare the opening test.\r\n */\r\nprivate final void prepareTest() {\r\n    reset();\r\n    // Move a white pawn to the 4th row\r\n    doPly(new PlyImpl(new PositionImpl(\"e2\"), new PositionImpl(\"e4\"), false));\r\n}'),(316,'reset()','de.java_chess.javaChess.engine.test.AnalyzerTest2.reset()','38','AnalyzerTest2','/**\r\n * Reset the game for a new score.\r\n */\r\nprivate final void reset() {\r\n    _game.reset();\r\n    _board.initialPosition();\r\n}'),(317,'runTest()','de.java_chess.javaChess.engine.test.AnalyzerTest2.runTest()','38','AnalyzerTest2','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    analyzerTest2();\r\n}'),(318,'setUp()','de.java_chess.javaChess.engine.test.AnalyzerTest2.setUp()','38','AnalyzerTest2','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, new PlyHashtableImpl(1000));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n}'),(319,'-init-()','de.java_chess.javaChess.engine.test.BoardConsistencyTest1.-init-()','39','BoardConsistencyTest1','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic BoardConsistencyTest1() {\r\n    super(\"A test if the engine does not alter the board unintentionally during the search for the best ply\");\r\n}'),(320,'boardConsistencyTest1()','de.java_chess.javaChess.engine.test.BoardConsistencyTest1.boardConsistencyTest1()','39','BoardConsistencyTest1','/**\r\n * Run the actual test.\r\n */\r\nprivate void boardConsistencyTest1() {\r\n    TestCase.assertTrue(\"Row1 complete after initial position\", (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    TestCase.assertTrue(\"Row1 complete after e2 - e4\", (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Compute the best ply for this game position.\r\n    Ply bestPly = _engine.computeBestPly();\r\n    doPly(bestPly);\r\n    TestCase.assertTrue((\"Row1 complete after \" + (bestPly.toString())), (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Move the white pawn from d2 - d4\r\n    doPly(new PlyImpl(new PositionImpl(11), new PositionImpl((11 + 16)), false));\r\n    TestCase.assertTrue(\"Row1 complete after d2 - d4\", (((_board.getEmptySquares()) & 255L) == 0L));\r\n    // Compute the best ply for this game position.\r\n    bestPly = _engine.computeBestPly();\r\n    doPly(bestPly);\r\n    TestCase.assertTrue((\"Row1 complete after \" + (bestPly.toString())), (((_board.getEmptySquares()) & 255L) == 0L));\r\n}'),(321,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.BoardConsistencyTest1.doPly(de.java_chess.javaChess.ply.Ply)','39','BoardConsistencyTest1','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(322,'runTest()','de.java_chess.javaChess.engine.test.BoardConsistencyTest1.runTest()','39','BoardConsistencyTest1','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    boardConsistencyTest1();\r\n}'),(323,'setUp()','de.java_chess.javaChess.engine.test.BoardConsistencyTest1.setUp()','39','BoardConsistencyTest1','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create a engine instance.\r\n    _engine = new ChessEngineImpl(_game, null, _board, false);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n}'),(324,'-init-()','de.java_chess.javaChess.engine.test.ChessEngineTest.-init-()','40','ChessEngineTest','ChessEngineTest() {\r\n}'),(325,'suite()','de.java_chess.javaChess.engine.test.ChessEngineTest.suite()','40','ChessEngineTest','/**\r\n * Create the engine test suite.\r\n *\r\n * @return The engine test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite\r\n    TestSuite suite = new TestSuite();\r\n    // Test the ply generator\r\n    suite.addTest(new PlyGeneratorTest1());\r\n    suite.addTest(new PlyGeneratorTest2());\r\n    suite.addTest(new PlyGeneratorTest3());\r\n    suite.addTest(new PlyGeneratorTest4());\r\n    suite.addTest(new PlyGeneratorTest5());\r\n    suite.addTest(new PlyGeneratorTest6());\r\n    // Add the actual engine tests.\r\n    suite.addTest(new KingInKnightCheckTest());\r\n    // Test the analyzer\r\n    suite.addTest(new AnalyzerTest1());\r\n    suite.addTest(new AnalyzerTest2());\r\n    // Test the complete engine\r\n    suite.addTest(new MinimaxTest1());\r\n    suite.addTest(new MinimaxTest2());\r\n    suite.addTest(new BoardConsistencyTest1());\r\n    return suite;\r\n}'),(326,'-init-()','de.java_chess.javaChess.engine.test.KingInKnightCheckTest.-init-()','41','KingInKnightCheckTest','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic KingInKnightCheckTest() {\r\n    super(\"King is in knight check test\");\r\n}'),(327,'knightTests()','de.java_chess.javaChess.engine.test.KingInKnightCheckTest.knightTests()','41','KingInKnightCheckTest','/**\r\n * Run the actual knight tests.\r\n */\r\npublic void knightTests() {\r\n    // Now set the black knight on every other square to see if the analyzer\r\n    // reports a check.\r\n    for (int i = 63; i >= 0; i--) {\r\n        Position currentPosition = new PositionImpl(i);\r\n        if (null == (_board.getPiece(currentPosition))) {\r\n            // If this square is empty\r\n            _board.setPiece(new PieceImpl(Piece.KNIGHT, Piece.BLACK), currentPosition);// Set a black knight there.\r\n\r\n            int squareIndexDifference = Math.abs((i - (_whiteKingPos)));\r\n            // The white king is in check, if the square difference is\r\n            // 6, 10, 15 or 17 (count the squares on a board to verify this).\r\n            boolean whiteKingIsInCheck = (((squareIndexDifference == 6) || (squareIndexDifference == 10)) || (squareIndexDifference == 15)) || (squareIndexDifference == 17);\r\n            // Only if the white king is in check, the analyzer should return BLACK_WIN.\r\n            TestCase.assertTrue((\"Wrong check status with knight on square \" + i), (whiteKingIsInCheck == (_analyzer.isInCheck(((BitBoard) (_board)), true))));\r\n            _board.setPiece(null, currentPosition);// Remove the black knight from the current square.\r\n\r\n        }\r\n    }\r\n}'),(328,'runTest()','de.java_chess.javaChess.engine.test.KingInKnightCheckTest.runTest()','41','KingInKnightCheckTest','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    knightTests();\r\n}'),(329,'setUp()','de.java_chess.javaChess.engine.test.KingInKnightCheckTest.setUp()','41','KingInKnightCheckTest','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Set the positions of the 2 kings.\r\n    _whiteKingPos = 4;\r\n    _blackKingPos = 60;\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator (the hashtable is not used here).\r\n    _plyGenerator = new PlyGenerator(_game, new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    // Set the 2 kings on the board\r\n    _board.setPiece(new PieceImpl(Piece.KING, Piece.BLACK), new PositionImpl(_blackKingPos));\r\n    _board.setPiece(new PieceImpl(Piece.KING, Piece.WHITE), new PositionImpl(_whiteKingPos));\r\n}'),(330,'-init-()','de.java_chess.javaChess.engine.test.MinimaxTest1.-init-()','42','MinimaxTest1','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic MinimaxTest1() {\r\n    super(\"A test of the minimax implementation, if boards are passed correctly over search depths\");\r\n}'),(331,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.MinimaxTest1.doPly(de.java_chess.javaChess.ply.Ply)','42','MinimaxTest1','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(332,'minimaxTest1()','de.java_chess.javaChess.engine.test.MinimaxTest1.minimaxTest1()','42','MinimaxTest1','/**\r\n * Run the actual test.\r\n */\r\nprivate void minimaxTest1() {\r\n    // Compute the best ply for this game position.\r\n    Ply bestPly = _engine.computeBestPly();\r\n    // Check if e7 - e5 was delivered as the best ply.\r\n    TestCase.assertTrue(\"Engine computed invalid ply e7-e5\", (((bestPly.getSource().getSquareIndex()) != 52) || ((bestPly.getDestination().getSquareIndex()) != (52 - 15))));\r\n}'),(333,'runTest()','de.java_chess.javaChess.engine.test.MinimaxTest1.runTest()','42','MinimaxTest1','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    minimaxTest1();\r\n}'),(334,'setUp()','de.java_chess.javaChess.engine.test.MinimaxTest1.setUp()','42','MinimaxTest1','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create a engine instance.\r\n    _engine = new ChessEngineImpl(_game, null, _board, false);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black knight to f6\r\n    doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move the white pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl(((12 + 16) + 8)), false));\r\n}'),(335,'-init-()','de.java_chess.javaChess.engine.test.MinimaxTest2.-init-()','43','MinimaxTest2','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic MinimaxTest2() {\r\n    super(\"A test of the minimax implementation, if piece captures are not recognized\");\r\n}'),(336,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.MinimaxTest2.doPly(de.java_chess.javaChess.ply.Ply)','43','MinimaxTest2','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(337,'minimaxTest1()','de.java_chess.javaChess.engine.test.MinimaxTest2.minimaxTest1()','43','MinimaxTest2','/**\r\n * Run the actual test.\r\n */\r\nprivate void minimaxTest1() {\r\n    // Compute the best ply for this game position.\r\n    Ply bestPly = _engine.computeBestPly();\r\n    // Check if Qxg2 was delivered as the best ply.\r\n    TestCase.assertTrue(\"Engine computed ply Qxg2\", (((bestPly.getSource().getSquareIndex()) != 38) || ((bestPly.getDestination().getSquareIndex()) != 14)));\r\n}'),(338,'runTest()','de.java_chess.javaChess.engine.test.MinimaxTest2.runTest()','43','MinimaxTest2','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    minimaxTest1();\r\n}'),(339,'setUp()','de.java_chess.javaChess.engine.test.MinimaxTest2.setUp()','43','MinimaxTest2','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create a engine instance.\r\n    _engine = new ChessEngineImpl(_game, null, _board, false);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl(52), new PositionImpl((52 - 16)), false));\r\n    // Move the white pawn to f3\r\n    doPly(new PlyImpl(new PositionImpl(13), new PositionImpl((13 + 8)), false));\r\n    // Move the black queen to g5\r\n    doPly(new PlyImpl(new PositionImpl(59), new PositionImpl(38), false));\r\n    // Move the white pawn to d3\r\n    doPly(new PlyImpl(new PositionImpl(11), new PositionImpl(19), false));\r\n    // Black is about to move\r\n    _engine.setWhite(false);\r\n}'),(340,'-init-()','de.java_chess.javaChess.engine.test.PlyGeneratorTest1.-init-()','44','PlyGeneratorTest1','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest1() {\r\n    super(\"A simple ply generator test with a attack on the pawn e5\");\r\n}'),(341,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.PlyGeneratorTest1.doPly(de.java_chess.javaChess.ply.Ply)','44','PlyGeneratorTest1','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(342,'plygeneratorTest1()','de.java_chess.javaChess.engine.test.PlyGeneratorTest1.plygeneratorTest1()','44','PlyGeneratorTest1','/**\r\n * Run the actual test.\r\n */\r\nprivate void plygeneratorTest1() {\r\n    // Get the plies for black\r\n    Ply[] plies = _plyGenerator.getPliesForColor(false);\r\n    // Check if e7 - e5 was delivered as a potential ply.\r\n    boolean containsInvalidMoves = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 52) && ((plies[i].getDestination().getSquareIndex()) == (52 - 16))) {\r\n            containsInvalidMoves = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes invalid move e7 - e5\", (!containsInvalidMoves));\r\n}'),(343,'runTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest1.runTest()','44','PlyGeneratorTest1','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    plygeneratorTest1();\r\n}'),(344,'setUp()','de.java_chess.javaChess.engine.test.PlyGeneratorTest1.setUp()','44','PlyGeneratorTest1','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black knight to f6\r\n    doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move the white pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl(((12 + 16) + 8)), false));\r\n}'),(345,'-init-()','de.java_chess.javaChess.engine.test.PlyGeneratorTest2.-init-()','45','PlyGeneratorTest2','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest2() {\r\n    super(\"A simple ply generator test with a attack on the knight g3\");\r\n}'),(346,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.PlyGeneratorTest2.doPly(de.java_chess.javaChess.ply.Ply)','45','PlyGeneratorTest2','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(347,'generatorTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest2.generatorTest()','45','PlyGeneratorTest2','/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for black\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if h2 - g3 was delivered as a potential ply.\r\n    boolean containsCaptureMove = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 15) && ((plies[i].getDestination().getSquareIndex()) == 22)) {\r\n            containsCaptureMove = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes capture move h2 - g3\", containsCaptureMove);\r\n}'),(348,'runTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest2.runTest()','45','PlyGeneratorTest2','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}'),(349,'setUp()','de.java_chess.javaChess.engine.test.PlyGeneratorTest2.setUp()','45','PlyGeneratorTest2','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black knight to f6\r\n    doPly(new PlyImpl(new PositionImpl(62), new PositionImpl((62 - 17)), false));\r\n    // Move the white pawn to e5\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl(((12 + 16) + 8)), false));\r\n    // Move the black knight to e4\r\n    doPly(new PlyImpl(new PositionImpl((62 - 17)), new PositionImpl((12 + 16)), false));\r\n    // Move f2 - f3\r\n    doPly(new PlyImpl(new PositionImpl(13), new PositionImpl((13 + 8)), false));\r\n    // Move the black knight to g3 (??)\r\n    doPly(new PlyImpl(new PositionImpl((12 + 16)), new PositionImpl((14 + 8)), false));\r\n}'),(350,'-init-()','de.java_chess.javaChess.engine.test.PlyGeneratorTest3.-init-()','46','PlyGeneratorTest3','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest3() {\r\n    super(\"A simple ply generator test for a illegal queen move h4-a5\");\r\n}'),(351,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.PlyGeneratorTest3.doPly(de.java_chess.javaChess.ply.Ply)','46','PlyGeneratorTest3','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(352,'generatorTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest3.generatorTest()','46','PlyGeneratorTest3','/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for black\r\n    Ply[] plies = _plyGenerator.getPliesForColor(false);\r\n    // Check if h4-a5 was delivered as a potential ply.\r\n    boolean containsIllegalMove = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 31) && ((plies[i].getDestination().getSquareIndex()) == 32)) {\r\n            containsIllegalMove = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator does not computes move h4-a5\", (!containsIllegalMove));\r\n}'),(353,'runTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest3.runTest()','46','PlyGeneratorTest3','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}'),(354,'setUp()','de.java_chess.javaChess.engine.test.PlyGeneratorTest3.setUp()','46','PlyGeneratorTest3','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from e2 - e4\r\n    doPly(new PlyImpl(new PositionImpl(12), new PositionImpl((12 + 16)), false));\r\n    // Move the black pawn from e7 - e5\r\n    doPly(new PlyImpl(new PositionImpl(52), new PositionImpl(36), false));\r\n    // Move f2 - f3\r\n    doPly(new PlyImpl(new PositionImpl(13), new PositionImpl((13 + 8)), false));\r\n    // Move the black queen to h4\r\n    doPly(new PlyImpl(new PositionImpl(59), new PositionImpl(31), false));\r\n    // Move g2-g3\r\n    doPly(new PlyImpl(new PositionImpl(14), new PositionImpl((14 + 8)), false));\r\n}'),(355,'-init-()','de.java_chess.javaChess.engine.test.PlyGeneratorTest4.-init-()','47','PlyGeneratorTest4','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest4() {\r\n    super(\"A simple ply generator test for a rook capture on h8 by a bishop\");\r\n}'),(356,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.PlyGeneratorTest4.doPly(de.java_chess.javaChess.ply.Ply)','47','PlyGeneratorTest4','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(357,'generatorTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest4.generatorTest()','47','PlyGeneratorTest4','/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for white\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if b2 x h8 was delivered as a potential ply.\r\n    boolean containsCapture = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if (((plies[i].getSource().getSquareIndex()) == 9) && ((plies[i].getDestination().getSquareIndex()) == 63)) {\r\n            containsCapture = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes capture b2 x h8\", containsCapture);\r\n}'),(358,'runTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest4.runTest()','47','PlyGeneratorTest4','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}'),(359,'setUp()','de.java_chess.javaChess.engine.test.PlyGeneratorTest4.setUp()','47','PlyGeneratorTest4','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Move the white pawn from b2 - b3\r\n    doPly(new PlyImpl(new PositionImpl(9), new PositionImpl(17), false));\r\n    // Move the black pawn from g7 - g6\r\n    doPly(new PlyImpl(new PositionImpl(54), new PositionImpl(46), false));\r\n    // Move the bishop from c1 - b2\r\n    doPly(new PlyImpl(new PositionImpl(2), new PositionImpl(9), false));\r\n    // Move the black pawn from g6 - g5 (doesnt matter anyway. Just keep\r\n    // the attack on h8 open.\r\n    doPly(new PlyImpl(new PositionImpl(66), new PositionImpl((66 - 8)), false));\r\n}'),(360,'-init-()','de.java_chess.javaChess.engine.test.PlyGeneratorTest5.-init-()','48','PlyGeneratorTest5','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest5() {\r\n    super(\"A simple ply generator test for a queen capture on h7 by a bishop\");\r\n}'),(361,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.PlyGeneratorTest5.doPly(de.java_chess.javaChess.ply.Ply)','48','PlyGeneratorTest5','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(362,'generatorTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest5.generatorTest()','48','PlyGeneratorTest5','/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for white\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if d3 x h7 was delivered as a potential ply.\r\n    boolean containsCapture = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if ((19 == (plies[i].getSource().getSquareIndex())) && (55 == (plies[i].getDestination().getSquareIndex()))) {\r\n            containsCapture = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes capture d3 x h7\", containsCapture);\r\n}'),(363,'runTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest5.runTest()','48','PlyGeneratorTest5','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}'),(364,'setUp()','de.java_chess.javaChess.engine.test.PlyGeneratorTest5.setUp()','48','PlyGeneratorTest5','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Perform the moves to get to the tested board position.\r\n    for (int i = 0; i < (_prevMoves.length); i++) {\r\n        doPly(new PlyImpl(new PositionImpl(_prevMoves[i][0]), new PositionImpl(_prevMoves[i][1]), false));\r\n    }\r\n}'),(365,'-init-()','de.java_chess.javaChess.engine.test.PlyGeneratorTest6.-init-()','49','PlyGeneratorTest6','// Constructors\r\n/**\r\n * Create a new instance of this test.\r\n */\r\npublic PlyGeneratorTest6() {\r\n    super(\"A simple ply generator test for a bishop move f1-c4\");\r\n}'),(366,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.engine.test.PlyGeneratorTest6.doPly(de.java_chess.javaChess.ply.Ply)','49','PlyGeneratorTest6','/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(367,'generatorTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest6.generatorTest()','49','PlyGeneratorTest6','/**\r\n * Run the actual test.\r\n */\r\nprivate void generatorTest() {\r\n    // Get the plies for white\r\n    Ply[] plies = _plyGenerator.getPliesForColor(true);\r\n    // Check if d3 x h7 was delivered as a potential ply.\r\n    boolean containsMove = false;\r\n    for (int i = 0; i < (plies.length); i++) {\r\n        if ((5 == (plies[i].getSource().getSquareIndex())) && (26 == (plies[i].getDestination().getSquareIndex()))) {\r\n            containsMove = true;\r\n            break;\r\n        }\r\n    }\r\n    TestCase.assertTrue(\"PlyGenerator computes bishop move f1 - c4\", containsMove);\r\n}'),(368,'runTest()','de.java_chess.javaChess.engine.test.PlyGeneratorTest6.runTest()','49','PlyGeneratorTest6','// Methods\r\n/**\r\n * Run the actual test(s).\r\n */\r\npublic void runTest() {\r\n    generatorTest();\r\n}'),(369,'setUp()','de.java_chess.javaChess.engine.test.PlyGeneratorTest6.setUp()','49','PlyGeneratorTest6','/**\r\n * Prepare the test(s).\r\n */\r\nprotected void setUp() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(100));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n    // Perform the moves to get to the tested board position.\r\n    for (int i = 0; i < (_prevMoves.length); i++) {\r\n        doPly(new PlyImpl(new PositionImpl(_prevMoves[i][0]), new PositionImpl(_prevMoves[i][1]), false));\r\n    }\r\n}'),(370,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.game.Game.doPly(de.java_chess.javaChess.ply.Ply)','50','Game','/**\r\n * Add a new ply to the game.\r\n *\r\n * @unknown The new ply.\r\n */\r\nvoid doPly(Ply ply);'),(371,'getLastPly()','de.java_chess.javaChess.game.Game.getLastPly()','50','Game','/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\nPly getLastPly();'),(372,'getNumberOfPlies()','de.java_chess.javaChess.game.Game.getNumberOfPlies()','50','Game','/**\r\n * Get the number of plies in this game.\r\n *\r\n * @return The number of plies in this game.\r\n */\r\nint getNumberOfPlies();'),(373,'hasBeenMoved(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.game.Game.hasBeenMoved(de.java_chess.javaChess.position.Position)','50','Game','/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * 		The position to check.\r\n */\r\nboolean hasBeenMoved(Position position);'),(374,'reset()','de.java_chess.javaChess.game.Game.reset()','50','Game','// Methods\r\n/**\r\n * Reset the game.\r\n */\r\nvoid reset();'),(375,'undoLastPly()','de.java_chess.javaChess.game.Game.undoLastPly()','50','Game','/**\r\n * Take the last ply back.\r\n */\r\nvoid undoLastPly();'),(376,'-init-(de.java_chess.javaChess.ply.Ply,long)','de.java_chess.javaChess.game.GameImpl.-init-(de.java_chess.javaChess.ply.Ply,long)','52','GameImpl','// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * 		The ply for this game status.\r\n * @param bitmask\r\n * 		The moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}'),(377,'-init-(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.game.GameImpl.-init-(de.java_chess.javaChess.ply.Ply)','52','GameImpl','/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * 		The first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}'),(378,'-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)','de.java_chess.javaChess.game$GameImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)','52','GameImpl','/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * 		The previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}'),(379,'-init-()','de.java_chess.javaChess.game.GameImpl.-init-()','52','GameImpl','// Constructors\r\n/**\r\n * Create a new game instance.\r\n */\r\npublic GameImpl() {\r\n    _gameStatus = new UnsynchronizedArrayStack();\r\n}'),(380,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.game.GameImpl.doPly(de.java_chess.javaChess.ply.Ply)','52','GameImpl','/**\r\n * Do a new ply in this game.\r\n *\r\n * @param ply\r\n * 		The next ply.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    // Add a new game status, that derives from the previous status.\r\n    _gameStatus.push(((getLastGameStatus()) == null ? new GameImpl.GameStatus(ply) : new GameImpl.GameStatus(ply, getLastGameStatus())));\r\n}'),(381,'getLastGameStatus()','de.java_chess.javaChess.game.GameImpl.getLastGameStatus()','52','GameImpl','// Methods\r\n/**\r\n * Get the last game status.\r\n *\r\n * @return The last game status.\r\n */\r\nprivate final GameImpl.GameStatus getLastGameStatus() {\r\n    return _gameStatus.empty() ? null : ((GameImpl.GameStatus) (_gameStatus.peek()));\r\n}'),(382,'getLastPly()','de.java_chess.javaChess.game.GameImpl.getLastPly()','52','GameImpl','/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\npublic final Ply getLastPly() {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? null : lastStatus.getPly();\r\n}'),(383,'getNumberOfPlies()','de.java_chess.javaChess.game.GameImpl.getNumberOfPlies()','52','GameImpl','/**\r\n * Get the total number of plies.\r\n *\r\n * @return The total number of plies.\r\n */\r\npublic final int getNumberOfPlies() {\r\n    return _gameStatus.size();\r\n}'),(384,'hasBeenMoved(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)','52','GameImpl','/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * 		The position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}'),(385,'reset()','de.java_chess.javaChess.game.GameImpl.reset()','52','GameImpl','/**\r\n * Reset the game.\r\n */\r\npublic final void reset() {\r\n    // Simply remove all the status instances from the game.\r\n    _gameStatus.clear();\r\n}'),(386,'toString()','de.java_chess.javaChess.game.GameImpl.toString()','52','GameImpl','/**\r\n * Convert the game to a string.\r\n *\r\n * @return A string representation of the game.\r\n */\r\npublic final String toString() {\r\n    // A buffer for the string representation\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Iterate over the stack content\r\n    for (Iterator iter = _gameStatus.iterator(); iter.hasNext();) {\r\n        resultBuffer.append(((GameImpl.GameStatus) (iter.next())).getPly().toString());\r\n        resultBuffer.append(\"\n\");\r\n    }\r\n    return resultBuffer.toString();\r\n}'),(387,'undoLastPly()','de.java_chess.javaChess.game.GameImpl.undoLastPly()','52','GameImpl','/**\r\n * Undo the last ply.\r\n */\r\npublic final void undoLastPly() {\r\n    // Remove the last ply\r\n    _gameStatus.pop();\r\n}'),(388,'-init-(de.java_chess.javaChess.ply.Ply,long)','de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,long)','51','GameStatus','// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * 		The ply for this game status.\r\n * @param bitmask\r\n * 		The moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}'),(389,'-init-(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply)','51','GameStatus','/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * 		The first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}'),(390,'-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)','de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)','51','GameStatus','/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * 		The previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}'),(391,'getMovedPieces()','de.java_chess.javaChess.game.GameImpl$GameStatus.getMovedPieces()','51','GameStatus','/**\r\n * Get the bitmask for the moved pieces.\r\n *\r\n * @return The bitmask for the moved pieces.\r\n */\r\nprivate final long getMovedPieces() {\r\n    return _movedPieces;\r\n}'),(392,'getPly()','de.java_chess.javaChess.game.GameImpl$GameStatus.getPly()','51','GameStatus','// Methods\r\n/**\r\n * Get the ply, that lead to this game status.\r\n *\r\n * @return The ply, that lead to this game status.\r\n */\r\nfinal Ply getPly() {\r\n    return _ply;\r\n}'),(393,'hasBeenMoved(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)','51','GameStatus','/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}'),(394,'setMoved(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.game.GameImpl$GameStatus.setMoved(de.java_chess.javaChess.position.Position)','51','GameStatus','/**\r\n * Mark a piece moved from its initial position.\r\n *\r\n * @param position\r\n * 		The position of the moved piece.\r\n */\r\nprivate final void setMoved(Position position) {\r\n    _movedPieces |= 1L << (position.getSquareIndex());\r\n}'),(395,'setMovedPieces(long)','de.java_chess.javaChess.game.GameImpl$GameStatus.setMovedPieces(long)','51','GameStatus','/**\r\n * Set the bitmask for the moved pieces.\r\n *\r\n * @param bitmask\r\n * 		The new bitmask for the moved pieces.\r\n */\r\nprivate final void setMovedPieces(long bitmask) {\r\n    _movedPieces = bitmask;\r\n}'),(396,'setPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.game.GameImpl$GameStatus.setPly(de.java_chess.javaChess.ply.Ply)','51','GameStatus','/**\r\n * Set the ply, that lead to this game status.\r\n *\r\n * @param ply\r\n * 		The ply, that lead to this game status.\r\n */\r\nfinal void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(397,'engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)','de.java_chess.javaChess.listener.EngineStatusListener.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)','53','EngineStatusListener','public void engineStatusChanged(ChessEngineImpl engine);'),(398,'-init-()','de.java_chess.javaChess.menu.EditMenu.-init-()','54','EditMenu','/**\r\n * Standardconstructor\r\n */\r\npublic EditMenu() {\r\n    this.notationPanel = null;\r\n}'),(399,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.menu.EditMenu.actionPerformed(java.awt.event.ActionEvent)','54','EditMenu','/**\r\n * Interface method. Currently displays input dialogs to edit white and black player\r\n * names\r\n *\r\n * @param e\r\n * 		The action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jmiEditPosition)) {\r\n        SetupBoardDialog setupBoardDialog = new SetupBoardDialog();\r\n        Tools.setDialogToCenter(setupBoardDialog);\r\n        setupBoardDialog.setModal(true);\r\n        setupBoardDialog.show();\r\n    } else {\r\n        if ((notationPanel) != null) {\r\n            PlayerDialog playerDialog = null;\r\n            boolean bWhiteOrBlack = true;\r\n            if (e.getSource().equals(jmiWhitePlayerName)) {\r\n                playerDialog = new PlayerDialog(1, notationPanel.getWhitePlayerName());\r\n                bWhiteOrBlack = true;\r\n            } else\r\n                if (e.getSource().equals(jmiBlackPlayerName)) {\r\n                    playerDialog = new PlayerDialog(2, notationPanel.getBlackPlayerName());\r\n                    bWhiteOrBlack = false;\r\n                }\r\n\r\n            if (playerDialog != null) {\r\n                Tools.setDialogToCenter(playerDialog);\r\n                playerDialog.show();\r\n                String sNewName = playerDialog.getNewName();\r\n                if (bWhiteOrBlack == true) {\r\n                    notationPanel.setWhitePlayerName(sNewName);\r\n                } else {\r\n                    notationPanel.setBlackPlayerName(sNewName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}'),(400,'getMenu()','de.java_chess.javaChess.menu.EditMenu.getMenu()','54','EditMenu','/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu jmEditMenu = new JMenu(\"Edit\");\r\n    // Add menu items\r\n    jmiBlackPlayerName.setText(\"Black player name\");\r\n    jmiWhitePlayerName.setText(\"White player name\");\r\n    jmiEditPosition.setText(\"Edit/Setup position\");\r\n    jmiEditPosition.setMnemonic(S);\r\n    jmiBlackPlayerName.addActionListener(this);\r\n    jmiWhitePlayerName.addActionListener(this);\r\n    jmiEditPosition.addActionListener(this);\r\n    jmEditMenu.add(jmiWhitePlayerName);\r\n    jmEditMenu.add(jmiBlackPlayerName);\r\n    jmEditMenu.addSeparator();\r\n    jmEditMenu.add(jmiEditPosition);\r\n    jmEditMenu.setMnemonic(KeyEvent.VK_E);\r\n    return jmEditMenu;\r\n}'),(401,'setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)','de.java_chess.javaChess.menu.EditMenu.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)','54','EditMenu','/**\r\n * Sets the NotationPanel to be able to perform some actions there\r\n *\r\n * @param panel\r\n * 		The NotationPanel object\r\n */\r\npublic final void setNotationPanel(NotationPanel panel) {\r\n    this.notationPanel = panel;\r\n}'),(402,'addPly(de.java_chess.javaChess.notation.PlyNotation)','de.java_chess.javaChess.notation.GameNotation.addPly(de.java_chess.javaChess.notation.PlyNotation)','55','GameNotation','/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * 		The notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation);'),(403,'getMove(int,boolean)','de.java_chess.javaChess.notation.GameNotation.getMove(int,boolean)','55','GameNotation','/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * 		The index of the move.\r\n * @param boolean\r\n * 		white Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\nString getMove(int moveIndex, boolean white);'),(404,'getOpeningInfo()','de.java_chess.javaChess.notation.GameNotation.getOpeningInfo()','55','GameNotation','/**\r\n * Get the info on the used opening.\r\n *\r\n * @return The name of the used opening.\r\n */\r\nString getOpeningInfo();'),(405,'getPGNheader()','de.java_chess.javaChess.notation.GameNotation.getPGNheader()','55','GameNotation','/**\r\n * Get some extended PGN compatible info on the game.\r\n *\r\n * @return Extended PGN compatible info on the game.\r\n */\r\nString getPGNheader();'),(406,'getPlayerInfo(boolean)','de.java_chess.javaChess.notation.GameNotation.getPlayerInfo(boolean)','55','GameNotation','/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\nString getPlayerInfo(boolean white);'),(407,'getPlyNotation(int)','de.java_chess.javaChess.notation.GameNotation.getPlyNotation(int)','55','GameNotation','/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * 		The index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index);'),(408,'reset()','de.java_chess.javaChess.notation.GameNotation.reset()','55','GameNotation','// Methods\r\n/**\r\n * Reset the game notation for a new game.\r\n */\r\npublic void reset();'),(409,'setOpeningInfo(java.lang.String)','de.java_chess.javaChess.notation.GameNotation.setOpeningInfo(java.lang.String)','55','GameNotation','/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * 		The name of the opening.\r\n */\r\nvoid setOpeningInfo(String name);'),(410,'setPlayerInfo(java.lang.String,boolean)','de.java_chess.javaChess.notation.GameNotation.setPlayerInfo(java.lang.String,boolean)','55','GameNotation','/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * 		The player info.\r\n * @param white\r\n * 		Flag to indicate, if its the player\r\n * 		with the white pieces.\r\n */\r\nvoid setPlayerInfo(String playerInfo, boolean white);'),(411,'size()','de.java_chess.javaChess.notation.GameNotation.size()','55','GameNotation','/**\r\n * Get the number of plies in this notation.\r\n *\r\n * @return The number of plies.\r\n */\r\npublic int size();'),(412,'toString()','de.java_chess.javaChess.notation.GameNotation.toString()','55','GameNotation','/**\r\n * Get the entire game as a string.\r\n *\r\n * @return The entire game as a string.\r\n */\r\nString toString();'),(413,'-init-()','de.java_chess.javaChess.notation.GameNotationImpl.-init-()','56','GameNotationImpl','// Constructors\r\n/**\r\n * Create a new game notation instance.\r\n */\r\npublic GameNotationImpl() {\r\n    _plies = new ArrayList();\r\n    _notation = new StringBuffer();\r\n}'),(414,'addPly(de.java_chess.javaChess.notation.PlyNotation)','de.java_chess.javaChess.notation.GameNotationImpl.addPly(de.java_chess.javaChess.notation.PlyNotation)','56','GameNotationImpl','/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * 		The notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation) {\r\n    _plies.add(plyNotation);\r\n    int nPlies = _plies.size();// Get the number of plies.\r\n\r\n    if ((nPlies & 1) != 0) {\r\n        if (nPlies > 1) {\r\n            // Start a new line\r\n            _notation.append(\"\n\");\r\n        }\r\n        _notation.append(((\"\" + ((nPlies >> 1) + 1)) + \". \"));\r\n    } else {\r\n        _notation.append(\" \");\r\n    }\r\n    _notation.append(plyNotation.toString());\r\n    // If theres a panel, display the current notation.\r\n    if (null != (getNotationPanel())) {\r\n        getNotationPanel().setText(toString());\r\n    }\r\n}'),(415,'getMove(int,boolean)','de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)','56','GameNotationImpl','/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * 		The index of the move.\r\n * @param boolean\r\n * 		white Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}'),(416,'getNotationPanel()','de.java_chess.javaChess.notation.GameNotationImpl.getNotationPanel()','56','GameNotationImpl','/**\r\n * Get the panel for the output.\r\n *\r\n * @return The panel for the output.\r\n */\r\npublic final NotationPanel getNotationPanel() {\r\n    return _notationPanel;\r\n}'),(417,'getOpeningInfo()','de.java_chess.javaChess.notation.GameNotationImpl.getOpeningInfo()','56','GameNotationImpl','/**\r\n * Get the info on the used opening.\r\n *\r\n * @return The name of the used opening.\r\n */\r\npublic final String getOpeningInfo() {\r\n    return _openingName;\r\n}'),(418,'getPGNheader()','de.java_chess.javaChess.notation.GameNotationImpl.getPGNheader()','56','GameNotationImpl','/**\r\n * Get some extended PGN compatible info on the game.\r\n *\r\n * @return Extended PGN compatible info on the game.\r\n */\r\npublic final String getPGNheader() {\r\n    // Create a buffer for the result.\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Add a empty event to the header\r\n    resultBuffer.append(\"[Event \"?\"]\n\");\r\n    // Info on the site\r\n    resultBuffer.append(\"[Site \"?\"]\n\");\r\n    // Add the current date to the header\r\n    resultBuffer.append(\"[Date \"\").append(new SimpleDateFormat(\"yyyy.MM.dd\").format(new Date())).append(\"\"]\n\");\r\n    // Add the round to the header\r\n    resultBuffer.append(\"[Round \"?\"]\n\");\r\n    // Add the name of the white player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(true)))) {\r\n        resultBuffer.append(\"[White \"\").append(getPlayerInfo(true)).append(\"\"]\n\");\r\n    }\r\n    // Add the name of the black player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(false)))) {\r\n        resultBuffer.append(\"[Black \"\").append(getPlayerInfo(false)).append(\"\"]\n\");\r\n    }\r\n    // Info on the result\r\n    resultBuffer.append(\"[Result \"?\"]\n\");\r\n    // Convert the header to a String and return it.\r\n    return resultBuffer.toString();\r\n}'),(419,'getPlayerInfo(boolean)','de.java_chess.javaChess.notation.GameNotationImpl.getPlayerInfo(boolean)','56','GameNotationImpl','/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\npublic final String getPlayerInfo(boolean white) {\r\n    return _playerInfo[(white ? 1 : 0)];\r\n}'),(420,'getPly(int)','de.java_chess.javaChess.notation.GameNotationImpl.getPly(int)','56','GameNotationImpl','/**\r\n * Get the ply with the given index.\r\n *\r\n * @param plyIndex\r\n * 		The index of the ply.\r\n * @return The notation for the ply as a string.\r\n */\r\nprivate final String getPly(int plyIndex) {\r\n    return _plies.get(plyIndex).toString();\r\n}'),(421,'getPlyNotation(int)','de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)','56','GameNotationImpl','/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * 		The index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}'),(422,'reset()','de.java_chess.javaChess.notation.GameNotationImpl.reset()','56','GameNotationImpl','// Methods\r\n/**\r\n * Reset the game notation for a new game.\r\n */\r\npublic void reset() {\r\n    _plies.clear();\r\n    // Remove all the plies.\r\n    _notation = new StringBuffer();// Remove the text.\r\n\r\n    // Remove the text from the panel.\r\n    getNotationPanel().setText(\"\");\r\n    // Remove the player info.\r\n    setPlayerInfo(null, true);\r\n    setPlayerInfo(null, false);\r\n    // Remove the opening name.\r\n    setOpeningInfo(null);\r\n}'),(423,'setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)','de.java_chess.javaChess.notation.GameNotationImpl.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)','56','GameNotationImpl','/**\r\n * Set the panel for the notation output.\r\n *\r\n * @param notationPanel\r\n * 		The panel for the output.\r\n */\r\npublic final void setNotationPanel(NotationPanel notationPanel) {\r\n    _notationPanel = notationPanel;\r\n}'),(424,'setOpeningInfo(java.lang.String)','de.java_chess.javaChess.notation.GameNotationImpl.setOpeningInfo(java.lang.String)','56','GameNotationImpl','/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * 		The name of the opening.\r\n */\r\npublic final void setOpeningInfo(String name) {\r\n    _openingName = name;\r\n}'),(425,'setPlayerInfo(java.lang.String,boolean)','de.java_chess.javaChess.notation.GameNotationImpl.setPlayerInfo(java.lang.String,boolean)','56','GameNotationImpl','/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * 		The player info.\r\n * @param white\r\n * 		Flag to indicate, if its the player\r\n * 		with the white pieces.\r\n */\r\npublic final void setPlayerInfo(String playerInfo, boolean white) {\r\n    _playerInfo[(white ? 1 : 0)] = playerInfo;\r\n}'),(426,'size()','de.java_chess.javaChess.notation.GameNotationImpl.size()','56','GameNotationImpl','/**\r\n * Get the number of plies in this notation.\r\n *\r\n * @return The number of plies.\r\n */\r\npublic int size() {\r\n    return _plies.size();\r\n}'),(427,'toString()','de.java_chess.javaChess.notation.GameNotationImpl.toString()','56','GameNotationImpl','/**\r\n * Get the entire game as a string.\r\n *\r\n * @return The entire game as a string.\r\n */\r\npublic final String toString() {\r\n    return _notation.toString();\r\n}'),(428,'getPiece()','de.java_chess.javaChess.notation.PlyNotation.getPiece()','57','PlyNotation','/**\r\n * Get the piece of this ply.\r\n *\r\n * @return The piece, that is moved with this ply.\r\n */\r\nPiece getPiece();'),(429,'getPieceTypeNotation(byte)','de.java_chess.javaChess.notation.PlyNotation.getPieceTypeNotation(byte)','57','PlyNotation','/**\r\n * Get the notation for a piece type.\r\n *\r\n * @param pieceType\r\n * 		The piece type.\r\n * @return The notation for a piece type.\r\n */\r\nString getPieceTypeNotation(byte pieceType);'),(430,'getPly()','de.java_chess.javaChess.notation.PlyNotation.getPly()','57','PlyNotation','/**\r\n * Get the ply of this notation.\r\n *\r\n * @return The ply for this notation.\r\n */\r\nPly getPly();'),(431,'isCapture()','de.java_chess.javaChess.notation.PlyNotation.isCapture()','57','PlyNotation','/**\r\n * Check if the piece captures another piece with this ply.\r\n *\r\n * @return true, if another piece is captureed with this ply.\r\n */\r\nboolean isCapture();'),(432,'isCheck()','de.java_chess.javaChess.notation.PlyNotation.isCheck()','57','PlyNotation','/**\r\n * Get the flag for a check.\r\n *\r\n * @return true, if the opponent is in check.\r\n */\r\nboolean isCheck();'),(433,'isCheckMate()','de.java_chess.javaChess.notation.PlyNotation.isCheckMate()','57','PlyNotation','/**\r\n * Get the flag for a checkmate.\r\n *\r\n * @return true, if the opponent is checkmate.\r\n */\r\nboolean isCheckMate();'),(434,'setCheck(boolean)','de.java_chess.javaChess.notation.PlyNotation.setCheck(boolean)','57','PlyNotation','/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is in check.\r\n */\r\nvoid setCheck(boolean check);'),(435,'setCheckMate(boolean)','de.java_chess.javaChess.notation.PlyNotation.setCheckMate(boolean)','57','PlyNotation','/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is checkmate.\r\n */\r\nvoid setCheckMate(boolean checkMate);'),(436,'setPiece(de.java_chess.javaChess.piece.Piece)','de.java_chess.javaChess.notation.PlyNotation.setPiece(de.java_chess.javaChess.piece.Piece)','57','PlyNotation','/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * 		The moved ply.\r\n */\r\nvoid setPiece(Piece piece);'),(437,'setPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.notation.PlyNotation.setPly(de.java_chess.javaChess.ply.Ply)','57','PlyNotation','/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * 		The ply for this notation.\r\n */\r\nvoid setPly(Ply ply);'),(438,'toString()','de.java_chess.javaChess.notation.PlyNotation.toString()','57','PlyNotation','// Methods\r\n/**\r\n * Render this ply as a string.\r\n *\r\n * @return The notated ply as a string.\r\n */\r\nString toString();'),(439,'-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)','de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)','58','PlyNotationImpl','// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n * @param piece\r\n * 		The moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}'),(440,'computeStringRepresentation()','de.java_chess.javaChess.notation.PlyNotationImpl.computeStringRepresentation()','58','PlyNotationImpl','/**\r\n * Render this ply as a string.\r\n */\r\nprivate final void computeStringRepresentation() {\r\n    StringBuffer notation = new StringBuffer();\r\n    if (!((getPly()) instanceof CastlingPly)) {\r\n        // Start with the type of the piece, if it is not a pawn.\r\n        if ((getPiece().getType()) != (Piece.PAWN)) {\r\n            notation.append(getPieceTypeNotation(getPiece().getType()));\r\n        }\r\n        // Get this ply as a string.\r\n        String plyString = getPly().toString();\r\n        // If its a capture, indicate it with an x\r\n        notation.append((isCapture() ? plyString.replace(-, x) : plyString));\r\n        // If its a pawn transforming to a new piece type, append the new type.\r\n        if ((getPly()) instanceof TransformationPly) {\r\n            notation.append(\"=\");\r\n            notation.append(getPieceTypeNotation(((TransformationPly) (getPly())).getTypeAfterTransformation()));\r\n        }\r\n    } else {\r\n        notation.append(getPly().toString());\r\n    }\r\n    // Add the check(-mate) signs.\r\n    if (isCheckMate()) {\r\n        notation.append(#);\r\n    } else {\r\n        if (isCheck()) {\r\n            notation.append(+);\r\n        }\r\n    }\r\n    // Convert the buffer to a string and store it.\r\n    _stringRepresentation = notation.toString();\r\n}'),(441,'getPiece()','de.java_chess.javaChess.notation.PlyNotationImpl.getPiece()','58','PlyNotationImpl','/**\r\n * Get the piece of this ply.\r\n *\r\n * @return The piece, that is moved with this ply.\r\n */\r\npublic final Piece getPiece() {\r\n    return _piece;\r\n}'),(442,'getPieceTypeNotation(byte)','de.java_chess.javaChess.notation.PlyNotationImpl.getPieceTypeNotation(byte)','58','PlyNotationImpl','/**\r\n * Get the notation for a piece type.\r\n *\r\n * @return The notation for a piece type.\r\n */\r\npublic final String getPieceTypeNotation(byte pieceType) {\r\n    String notation = \"\";// The result;\r\n\r\n    // Convert the piece type to a string.\r\n    switch (pieceType) {\r\n        case Piece.PAWN :\r\n            notation = \"P\";\r\n            break;\r\n        case Piece.KNIGHT :\r\n            notation = \"N\";\r\n            break;\r\n        case Piece.BISHOP :\r\n            notation = \"B\";\r\n            break;\r\n        case Piece.ROOK :\r\n            notation = \"R\";\r\n            break;\r\n        case Piece.QUEEN :\r\n            notation = \"Q\";\r\n            break;\r\n        case Piece.KING :\r\n            notation = \"K\";\r\n            break;\r\n    }\r\n    return notation;\r\n}'),(443,'getPly()','de.java_chess.javaChess.notation.PlyNotationImpl.getPly()','58','PlyNotationImpl','/**\r\n * Get the ply of this notation.\r\n *\r\n * @return The ply for this notation.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}'),(444,'isCapture()','de.java_chess.javaChess.notation.PlyNotationImpl.isCapture()','58','PlyNotationImpl','/**\r\n * Check if the piece captures another piece with this ply.\r\n *\r\n * @return true, if another piece is captureed with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return getPly().isCapture();\r\n}'),(445,'isCheck()','de.java_chess.javaChess.notation.PlyNotationImpl.isCheck()','58','PlyNotationImpl','/**\r\n * Get the flag for a check.\r\n *\r\n * @return true, if the opponent is in check.\r\n */\r\npublic final boolean isCheck() {\r\n    return _check;\r\n}'),(446,'isCheckMate()','de.java_chess.javaChess.notation.PlyNotationImpl.isCheckMate()','58','PlyNotationImpl','/**\r\n * Get the flag for a checkmate.\r\n *\r\n * @return true, if the opponent is checkmate.\r\n */\r\npublic final boolean isCheckMate() {\r\n    return _checkMate;\r\n}'),(447,'setCheck(boolean)','de.java_chess.javaChess.notation.PlyNotationImpl.setCheck(boolean)','58','PlyNotationImpl','/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is in check.\r\n */\r\npublic final void setCheck(boolean check) {\r\n    _check = check;\r\n    // If we are not in check, we are also no checkmate.\r\n    if (check == false) {\r\n        setCheckMate(false);\r\n    }\r\n    // Recompute the string representation to make sure, that\r\n    // it is still correct.\r\n    computeStringRepresentation();\r\n}'),(448,'setCheckMate(boolean)','de.java_chess.javaChess.notation.PlyNotationImpl.setCheckMate(boolean)','58','PlyNotationImpl','/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is checkmate.\r\n */\r\npublic final void setCheckMate(boolean checkMate) {\r\n    _checkMate = checkMate;\r\n    // If the opponent is checkmate, he is also in check.\r\n    if (checkMate == true) {\r\n        setCheck(true);\r\n    }\r\n}'),(449,'setPiece(de.java_chess.javaChess.piece.Piece)','de.java_chess.javaChess.notation.PlyNotationImpl.setPiece(de.java_chess.javaChess.piece.Piece)','58','PlyNotationImpl','/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * 		The moved ply.\r\n */\r\npublic final void setPiece(Piece piece) {\r\n    _piece = piece;\r\n}'),(450,'setPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.notation.PlyNotationImpl.setPly(de.java_chess.javaChess.ply.Ply)','58','PlyNotationImpl','/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * 		The ply for this notation.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(451,'toString()','de.java_chess.javaChess.notation.PlyNotationImpl.toString()','58','PlyNotationImpl','// Methods\r\n/**\r\n * Render this notation as a string.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic String toString() {\r\n    return _stringRepresentation;\r\n}'),(452,'-init-()','de.java_chess.javaChess.pgn.GameLoader.-init-()','59','GameLoader','// Constructors\r\n/**\r\n * Create a new game loader instance.\r\n */\r\npublic GameLoader() {\r\n    // Create a new game.\r\n    _game = new GameImpl();\r\n    // Create a new board.\r\n    _board = new BitBoardImpl();\r\n    // Create the ply generator.\r\n    _plyGenerator = new PlyGenerator(_game, ((BitBoard) (_board)), new PlyHashtableImpl(10));\r\n    // And the analyzer.\r\n    _analyzer = new BitBoardAnalyzerImpl(_game, _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    // Set the pieces on their initial positions.\r\n    _board.initialPosition();\r\n}'),(453,'completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)','de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)','59','GameLoader','// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * 		The info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}'),(454,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.pgn.GameLoader.doPly(de.java_chess.javaChess.ply.Ply)','59','GameLoader','/**\r\n * Perform a ply, when it is completely loaded.\r\n *\r\n * param ply The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n    // The other color is about to move now.\r\n    _whiteMoves = !(_whiteMoves);\r\n}'),(455,'-init-(java.io.Reader)','de.java_chess.javaChess.pgn.PGNFile.-init-(java.io.Reader)','60','PGNFile','// Constructors\r\n/**\r\n * Create a new instance.\r\n *\r\n * @param reader\r\n * 		The reader for the file.\r\n */\r\npublic PGNFile(Reader reader) {\r\n    setReader(reader);\r\n}'),(456,'getPGNParser()','de.java_chess.javaChess.pgn.PGNFile.getPGNParser()','60','PGNFile','/**\r\n * Get the current parser, if theres already one, or\r\n * create a new parser and return it.\r\n *\r\n * @return The current PGN parser.\r\n */\r\nprivate final PGNParser getPGNParser() {\r\n    if ((_parser) == null) {\r\n        // If there is no parser yet, create one.\r\n        _parser = new PGNParser(new PGNLexer(getReader()));\r\n    }\r\n    return _parser;// And return it.\r\n\r\n}'),(457,'getReader()','de.java_chess.javaChess.pgn.PGNFile.getReader()','60','PGNFile','/**\r\n * Get the reader for the current file.\r\n *\r\n * @return The current reader.\r\n */\r\nprivate final Reader getReader() {\r\n    return _reader;\r\n}'),(458,'readGame()','de.java_chess.javaChess.pgn.PGNFile.readGame()','60','PGNFile','// Methods\r\n/**\r\n * Read one game from the current file.\r\n *\r\n * @return The notation of the game.\r\n * @throws RecognitionException\r\n * 		If a parser problem occured.\r\n * @throws TokenStreamException\r\n * 		If a scanner problem occured.\r\n */\r\npublic final GameNotation readGame() throws RecognitionException, TokenStreamException {\r\n    // A buffer for the result.\r\n    GameNotation notationBuffer = new GameNotationImpl();\r\n    // Start the parsing of the file.\r\n    getPGNParser().pgnGame(notationBuffer);\r\n    return notationBuffer;\r\n}'),(459,'setPGNParser(de.java_chess.javaChess.pgn.PGNParser)','de.java_chess.javaChess.pgn.PGNFile.setPGNParser(de.java_chess.javaChess.pgn.PGNParser)','60','PGNFile','/**\r\n * Set the current parser.\r\n *\r\n * @param parser\r\n * 		The new PGN parser.\r\n */\r\nprivate final void setPGNParser(PGNParser parser) {\r\n    _parser = parser;\r\n}'),(460,'setReader(java.io.Reader)','de.java_chess.javaChess.pgn.PGNFile.setReader(java.io.Reader)','60','PGNFile','/**\r\n * Set a new reader for a file.\r\n *\r\n * @param reader\r\n * 		The new reader.\r\n */\r\nprivate final void setReader(Reader reader) {\r\n    _reader = reader;\r\n}'),(461,'-init-()','de.java_chess.javaChess.pgn.PGNFileFilter.-init-()','61','PGNFileFilter','PGNFileFilter() {\r\n}'),(462,'accept(java.io.File)','de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)','61','PGNFileFilter','// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * 		The file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}'),(463,'getDescription()','de.java_chess.javaChess.pgn.PGNFileFilter.getDescription()','61','PGNFileFilter','/**\r\n * Get a description of this file filter.\r\n *\r\n * @return A description of this file filter.\r\n */\r\npublic String getDescription() {\r\n    return \"PGN - Portable Game Notation format\";\r\n}'),(464,'-init-(java.io.InputStream)','de.java_chess.javaChess.pgn.PGNLexer.-init-(java.io.InputStream)','62','PGNLexer','public PGNLexer(InputStream in) {\r\n    this(new ByteBuffer(in));\r\n}'),(465,'-init-(java.io.Reader)','de.java_chess.javaChess.pgn.PGNLexer.-init-(java.io.Reader)','62','PGNLexer','public PGNLexer(Reader in) {\r\n    this(new CharBuffer(in));\r\n}'),(466,'-init-(antlr.InputBuffer)','de.java_chess.javaChess.pgn.PGNLexer.-init-(antlr.InputBuffer)','62','PGNLexer','public PGNLexer(InputBuffer ib) {\r\n    this(new antlr.LexerSharedInputState(ib));\r\n}'),(467,'-init-(antlr.LexerSharedInputState)','de.java_chess.javaChess.pgn.PGNLexer.-init-(antlr.LexerSharedInputState)','62','PGNLexer','public PGNLexer(LexerSharedInputState state) {\r\n    super(state);\r\n    literals = new Hashtable();\r\n    caseSensitiveLiterals = true;\r\n    setCaseSensitive(true);\r\n}'),(468,'mDOT(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mDOT(boolean)','62','PGNLexer','public final void mDOT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.DOT;\r\n    int _saveIndex;\r\n    match(.);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(469,'mFIGURINE_LETTER_CODE(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mFIGURINE_LETTER_CODE(boolean)','62','PGNLexer','public final void mFIGURINE_LETTER_CODE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.FIGURINE_LETTER_CODE;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case P :\r\n                {\r\n                    match(P);\r\n                    break;\r\n                }\r\n            case N :\r\n                {\r\n                    match(N);\r\n                    break;\r\n                }\r\n            case B :\r\n                {\r\n                    match(B);\r\n                    break;\r\n                }\r\n            case R :\r\n                {\r\n                    match(R);\r\n                    break;\r\n                }\r\n            case Q :\r\n                {\r\n                    match(Q);\r\n                    break;\r\n                }\r\n            case K :\r\n                {\r\n                    match(K);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(470,'mGAME_TERMINATOR(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mGAME_TERMINATOR(boolean)','62','PGNLexer','public final void mGAME_TERMINATOR(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.GAME_TERMINATOR;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case * :\r\n                {\r\n                    match(\"*\");\r\n                    break;\r\n                }\r\n            case 0 :\r\n                {\r\n                    match(\"0-1\");\r\n                    break;\r\n                }\r\n            default :\r\n                if (((LA(1)) == 1) && ((LA(2)) == -)) {\r\n                    match(\"1-0\");\r\n                } else\r\n                    if (((LA(1)) == 1) && ((LA(2)) == /)) {\r\n                        match(\"1/2-1/2\");\r\n                    } else {\r\n                        throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                    }\r\n\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(471,'mLBRACK(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mLBRACK(boolean)','62','PGNLexer','public final void mLBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.LBRACK;\r\n    int _saveIndex;\r\n    match([);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(472,'mMOVE_INDEX(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mMOVE_INDEX(boolean)','62','PGNLexer','public final void mMOVE_INDEX(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.MOVE_INDEX;\r\n    int _saveIndex;\r\n    {\r\n        matchRange(1, 9);\r\n        {\r\n            _loop57 : do {\r\n                if (((LA(1)) >= 0) && ((LA(1)) <= 9)) {\r\n                    matchRange(0, 9);\r\n                } else {\r\n                    break _loop57;\r\n                }\r\n            } while (true );\r\n        }\r\n        mDOT(false);\r\n    }\r\n    // Remove the trailing dot.\r\n    String index = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    index = index.substring(0, ((index.length()) - 1));\r\n    text.setLength(_begin);\r\n    text.append(index);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(473,'mPAWN_PROMOTION(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mPAWN_PROMOTION(boolean)','62','PGNLexer','public final void mPAWN_PROMOTION(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PAWN_PROMOTION;\r\n    int _saveIndex;\r\n    match(=);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(474,'mPIECE_CAPTURE(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mPIECE_CAPTURE(boolean)','62','PGNLexer','public final void mPIECE_CAPTURE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_CAPTURE;\r\n    int _saveIndex;\r\n    match(x);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(475,'mPIECE_MOVE(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mPIECE_MOVE(boolean)','62','PGNLexer','public final void mPIECE_MOVE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_MOVE;\r\n    int _saveIndex;\r\n    match(-);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(476,'mRBRACK(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mRBRACK(boolean)','62','PGNLexer','public final void mRBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RBRACK;\r\n    int _saveIndex;\r\n    match(]);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(477,'mRIGHT_CASTLING(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mRIGHT_CASTLING(boolean)','62','PGNLexer','public final void mRIGHT_CASTLING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RIGHT_CASTLING;\r\n    int _saveIndex;\r\n    match(\"O-O\");\r\n    {\r\n        if ((LA(1)) == -) {\r\n            match(\"-O\");\r\n            _ttype = PGNTokenTypes.LEFT_CASTLING;\r\n        } else {\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(478,'mSL_COMMENT(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mSL_COMMENT(boolean)','62','PGNLexer','public final void mSL_COMMENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SL_COMMENT;\r\n    int _saveIndex;\r\n    match(\";\");\r\n    {\r\n        _loop39 : do {\r\n            if (PGNLexer._tokenSet_2.member(LA(1))) {\r\n                {\r\n                    match(PGNLexer._tokenSet_2);\r\n                }\r\n            } else {\r\n                break _loop39;\r\n            }\r\n        } while (true );\r\n    }\r\n    {\r\n        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n            match(\"\r\n\");\r\n        } else\r\n            if ((LA(1)) == \n) {\r\n                match(\"\n\");\r\n            } else\r\n                if (((LA(1)) == \r) && true) {\r\n                    match(\"\r\");\r\n                } else {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n\r\n\r\n    }\r\n    _ttype = Token.SKIP;\r\n    newline();\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(479,'mSQUARE_NAME(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mSQUARE_NAME(boolean)','62','PGNLexer','public final void mSQUARE_NAME(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SQUARE_NAME;\r\n    int _saveIndex;\r\n    matchRange(a, h);\r\n    matchRange(1, 8);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(480,'mSTRING_LITERAL(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mSTRING_LITERAL(boolean)','62','PGNLexer','public final void mSTRING_LITERAL(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.STRING_LITERAL;\r\n    int _saveIndex;\r\n    {\r\n        match(\");\r\n        {\r\n            _loop45 : do {\r\n                if (PGNLexer._tokenSet_3.member(LA(1))) {\r\n                    {\r\n                        match(PGNLexer._tokenSet_3);\r\n                    }\r\n                } else {\r\n                    break _loop45;\r\n                }\r\n            } while (true );\r\n        }\r\n        match(\");\r\n    }\r\n    // Remove the leadind and trailing quote.\r\n    String literal = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    literal = ((literal.length()) == 2) ? \"\" : literal.substring(1, ((literal.length()) - 2));\r\n    text.setLength(_begin);\r\n    text.append(literal);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(481,'mTAG_BLACK(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_BLACK(boolean)','62','PGNLexer','public final void mTAG_BLACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_BLACK;\r\n    int _saveIndex;\r\n    match(\"Black\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(482,'mTAG_DATE(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_DATE(boolean)','62','PGNLexer','public final void mTAG_DATE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_DATE;\r\n    int _saveIndex;\r\n    match(\"Date\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(483,'mTAG_EVENT(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_EVENT(boolean)','62','PGNLexer','public final void mTAG_EVENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_EVENT;\r\n    int _saveIndex;\r\n    match(\"Event\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(484,'mTAG_OPENING(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_OPENING(boolean)','62','PGNLexer','public final void mTAG_OPENING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_OPENING;\r\n    int _saveIndex;\r\n    match(\"Opening\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(485,'mTAG_RESULT(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_RESULT(boolean)','62','PGNLexer','public final void mTAG_RESULT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_RESULT;\r\n    int _saveIndex;\r\n    match(\"Result\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(486,'mTAG_ROUND(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_ROUND(boolean)','62','PGNLexer','public final void mTAG_ROUND(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_ROUND;\r\n    int _saveIndex;\r\n    match(\"Round\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(487,'mTAG_SITE(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_SITE(boolean)','62','PGNLexer','public final void mTAG_SITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_SITE;\r\n    int _saveIndex;\r\n    match(\"Site\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(488,'mTAG_WHITE(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mTAG_WHITE(boolean)','62','PGNLexer','public final void mTAG_WHITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_WHITE;\r\n    int _saveIndex;\r\n    match(\"White\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(489,'mWS(boolean)','de.java_chess.javaChess.pgn.PGNLexer.mWS(boolean)','62','PGNLexer','public final void mWS(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.WS;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case   :\r\n                {\r\n                    match( );\r\n                    break;\r\n                }\r\n            case 	 :\r\n                {\r\n                    match(	);\r\n                    break;\r\n                }\r\n            case f :\r\n                {\r\n                    match(f);\r\n                    break;\r\n                }\r\n            case \n :\r\n            case \r :\r\n                {\r\n                    {\r\n                        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n                            match(\"\r\n\");\r\n                        } else\r\n                            if (((LA(1)) == \r) && true) {\r\n                                match(\r);\r\n                            } else\r\n                                if ((LA(1)) == \n) {\r\n                                    match(\n);\r\n                                } else {\r\n                                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                                }\r\n\r\n\r\n                    }\r\n                    newline();\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    /* $setType(Token.SKIP); */\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(490,'nextToken()','de.java_chess.javaChess.pgn.PGNLexer.nextToken()','62','PGNLexer','public Token nextToken() throws TokenStreamException {\r\n    Token theRetToken = null;\r\n    tryAgain : for (; ;) {\r\n        Token _token = null;\r\n        int _ttype = Token.INVALID_TYPE;\r\n        resetText();\r\n        try {\r\n            // for char stream error handling\r\n            try {\r\n                // for lexical error handling\r\n                switch (LA(1)) {\r\n                    case 	 :\r\n                    case \n :\r\n                    case f :\r\n                    case \r :\r\n                    case   :\r\n                        {\r\n                            mWS(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case . :\r\n                        {\r\n                            mDOT(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case [ :\r\n                        {\r\n                            mLBRACK(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case ] :\r\n                        {\r\n                            mRBRACK(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case ; :\r\n                        {\r\n                            mSL_COMMENT(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case \" :\r\n                        {\r\n                            mSTRING_LITERAL(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case a :\r\n                    case b :\r\n                    case c :\r\n                    case d :\r\n                    case e :\r\n                    case f :\r\n                    case g :\r\n                    case h :\r\n                        {\r\n                            mSQUARE_NAME(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case - :\r\n                        {\r\n                            mPIECE_MOVE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case x :\r\n                        {\r\n                            mPIECE_CAPTURE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case = :\r\n                        {\r\n                            mPAWN_PROMOTION(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case W :\r\n                        {\r\n                            mTAG_WHITE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case D :\r\n                        {\r\n                            mTAG_DATE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case E :\r\n                        {\r\n                            mTAG_EVENT(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    case S :\r\n                        {\r\n                            mTAG_SITE(true);\r\n                            theRetToken = _returnToken;\r\n                            break;\r\n                        }\r\n                    default :\r\n                        if (((LA(1)) == O) && ((LA(2)) == -)) {\r\n                            mRIGHT_CASTLING(true);\r\n                            theRetToken = _returnToken;\r\n                        } else\r\n                            if ((((LA(1)) >= 1) && ((LA(1)) <= 9)) && (PGNLexer._tokenSet_0.member(LA(2)))) {\r\n                                mMOVE_INDEX(true);\r\n                                theRetToken = _returnToken;\r\n                            } else\r\n                                if (((LA(1)) == B) && ((LA(2)) == l)) {\r\n                                    mTAG_BLACK(true);\r\n                                    theRetToken = _returnToken;\r\n                                } else\r\n                                    if (((LA(1)) == R) && ((LA(2)) == o)) {\r\n                                        mTAG_ROUND(true);\r\n                                        theRetToken = _returnToken;\r\n                                    } else\r\n                                        if (((LA(1)) == R) && ((LA(2)) == e)) {\r\n                                            mTAG_RESULT(true);\r\n                                            theRetToken = _returnToken;\r\n                                        } else\r\n                                            if (((LA(1)) == O) && ((LA(2)) == p)) {\r\n                                                mTAG_OPENING(true);\r\n                                                theRetToken = _returnToken;\r\n                                            } else\r\n                                                if ((PGNLexer._tokenSet_1.member(LA(1))) && true) {\r\n                                                    mFIGURINE_LETTER_CODE(true);\r\n                                                    theRetToken = _returnToken;\r\n                                                } else\r\n                                                    if (((((LA(1)) == *) || ((LA(1)) == 0)) || ((LA(1)) == 1)) && true) {\r\n                                                        mGAME_TERMINATOR(true);\r\n                                                        theRetToken = _returnToken;\r\n                                                    } else {\r\n                                                        if ((LA(1)) == (EOF_CHAR)) {\r\n                                                            uponEOF();\r\n                                                            _returnToken = makeToken(Token.EOF_TYPE);\r\n                                                        } else {\r\n                                                            throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                                                        }\r\n                                                    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n                }\r\n                if ((_returnToken) == null)\r\n                    continue tryAgain;\r\n                // found SKIP token\r\n\r\n                _ttype = _returnToken.getType();\r\n                _ttype = testLiteralsTable(_ttype);\r\n                _returnToken.setType(_ttype);\r\n                return _returnToken;\r\n            } catch (RecognitionException e) {\r\n                throw new antlr.TokenStreamRecognitionException(e);\r\n            }\r\n        } catch (CharStreamException cse) {\r\n            if (cse instanceof CharStreamIOException) {\r\n                throw new antlr.TokenStreamIOException(((CharStreamIOException) (cse)).io);\r\n            } else {\r\n                throw new TokenStreamException(cse.getMessage());\r\n            }\r\n        }\r\n    }\r\n}'),(491,'-init-(java.io.File)','de.java_chess.javaChess.pgn.PGNOutputStream.-init-(java.io.File)','63','PGNOutputStream','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new PGNOutputStream instance.\r\n *\r\n * @param file\r\n * 		The file to write into.\r\n */\r\npublic PGNOutputStream(File file) throws IOException {\r\n    super(file);\r\n}'),(492,'write(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.pgn.PGNOutputStream.write(de.java_chess.javaChess.notation.GameNotation)','63','PGNOutputStream','// Methods\r\n/**\r\n * Write the notation of a game.\r\n *\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\npublic final void write(GameNotation gameNotation) throws IOException {\r\n    // Check, if there is some header available.\r\n    String header = gameNotation.getPGNheader();\r\n    if (!(\"\".equals(header))) {\r\n        header += \"\n\";\r\n        write(header.getBytes());\r\n    }\r\n    write(gameNotation.toString().getBytes());\r\n}'),(493,'-init-(antlr.TokenBuffer,int)','de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer,int)','64','PGNParser','protected PGNParser(TokenBuffer tokenBuf, int k) {\r\n    super(tokenBuf, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(494,'-init-(antlr.TokenBuffer)','de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer)','64','PGNParser','public PGNParser(TokenBuffer tokenBuf) {\r\n    this(tokenBuf, 2);\r\n}'),(495,'-init-(antlr.TokenStream,int)','de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream,int)','64','PGNParser','protected PGNParser(TokenStream lexer, int k) {\r\n    super(lexer, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(496,'-init-(antlr.TokenStream)','de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream)','64','PGNParser','public PGNParser(TokenStream lexer) {\r\n    this(lexer, 2);\r\n}'),(497,'-init-(antlr.ParserSharedInputState)','de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.ParserSharedInputState)','64','PGNParser','public PGNParser(ParserSharedInputState state) {\r\n    super(state, 2);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(498,'blackTag()','de.java_chess.javaChess.pgn.PGNParser.blackTag()','64','PGNParser','public final void blackTag() throws RecognitionException, TokenStreamException {\r\n    Token name = null;\r\n    match(PGNTokenTypes.TAG_BLACK);\r\n    whiteSpaces();\r\n    name = LT(1);\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n    getNotation().setPlayerInfo(name.getText(), false);\r\n}'),(499,'dateTag()','de.java_chess.javaChess.pgn.PGNParser.dateTag()','64','PGNParser','public final void dateTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_DATE);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}'),(500,'eventTag()','de.java_chess.javaChess.pgn.PGNParser.eventTag()','64','PGNParser','public final void eventTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_EVENT);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}'),(501,'getGameLoader()','de.java_chess.javaChess.pgn.PGNParser.getGameLoader()','64','PGNParser','/**\r\n * Get the current game loader.\r\n *\r\n * @return The current game loader.\r\n */\r\nprivate final GameLoader getGameLoader() {\r\n    return _gameLoader;\r\n}'),(502,'getNotation()','de.java_chess.javaChess.pgn.PGNParser.getNotation()','64','PGNParser','/**\r\n * Get the current notation.\r\n *\r\n * @return The current notation.\r\n */\r\npublic final GameNotation getNotation() {\r\n    return _notation;\r\n}'),(503,'move()','de.java_chess.javaChess.pgn.PGNParser.move()','64','PGNParser','public final void move() throws RecognitionException, TokenStreamException {\r\n    Token mI = null;\r\n    PlyNotation notation = null;\r\n    mI = LT(1);\r\n    match(PGNTokenTypes.MOVE_INDEX);\r\n    if (!((++(_moveIndex)) == (Integer.parseInt(mI.getText()))))\r\n        throw new SemanticException(\" ++_moveIndex == Integer.parseInt( mI.getText()) \");\r\n\r\n    whiteSpaces();\r\n    notation = ply();\r\n    getNotation().addPly(notation);\r\n    whiteSpaces();\r\n    notation = ply();\r\n    getNotation().addPly(notation);\r\n    whiteSpaces();\r\n}'),(504,'moveTextSection()','de.java_chess.javaChess.pgn.PGNParser.moveTextSection()','64','PGNParser','public final void moveTextSection() throws RecognitionException, TokenStreamException {\r\n    _moveIndex = 0;\r\n    {\r\n        _loop17 : do {\r\n            if ((LA(1)) == (PGNTokenTypes.MOVE_INDEX)) {\r\n                move();\r\n            } else {\r\n                break _loop17;\r\n            }\r\n        } while (true );\r\n    }\r\n    match(PGNTokenTypes.GAME_TERMINATOR);\r\n}'),(505,'openingTag()','de.java_chess.javaChess.pgn.PGNParser.openingTag()','64','PGNParser','public final void openingTag() throws RecognitionException, TokenStreamException {\r\n    Token name = null;\r\n    match(PGNTokenTypes.TAG_OPENING);\r\n    whiteSpaces();\r\n    name = LT(1);\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n    getNotation().setOpeningInfo(name.getText());\r\n}'),(506,'pgnGame(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.pgn.PGNParser.pgnGame(de.java_chess.javaChess.notation.GameNotation)','64','PGNParser','public final void pgnGame(GameNotation notationBuffer) throws RecognitionException, TokenStreamException {\r\n    setNotation(notationBuffer);\r\n    setGameLoader(new GameLoader());\r\n    whiteSpaces();\r\n    tagPairSection();\r\n    moveTextSection();\r\n}'),(507,'ply()','de.java_chess.javaChess.pgn.PGNParser.ply()','64','PGNParser','public final PlyNotation ply() throws RecognitionException, TokenStreamException {\r\n    PlyNotation notation = null;\r\n    Token lc = null;\r\n    Token snOrg = null;\r\n    Token snDest = null;\r\n    Token lc2 = null;\r\n    PGNPlyFragment plyFragment = new PGNPlyFragment();\r\n    {\r\n        switch (LA(1)) {\r\n            case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n            case PGNTokenTypes.SQUARE_NAME :\r\n            case PGNTokenTypes.PIECE_MOVE :\r\n            case PGNTokenTypes.PIECE_CAPTURE :\r\n                {\r\n                    {\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                    {\r\n                                        lc = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        plyFragment.setPieceTypeFromLetter(lc.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                        {\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.SQUARE_NAME :\r\n                                        {\r\n                                            snOrg = LT(1);\r\n                                            match(PGNTokenTypes.SQUARE_NAME);\r\n                                            plyFragment.setOrigin(snOrg.getText());\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_MOVE);\r\n                                            plyFragment.setCapture(false);\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_CAPTURE);\r\n                                            plyFragment.setCapture(true);\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            snDest = LT(1);\r\n                            match(PGNTokenTypes.SQUARE_NAME);\r\n                            plyFragment.setDestination(snDest.getText());\r\n                        }\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.PAWN_PROMOTION :\r\n                                    {\r\n                                        match(PGNTokenTypes.PAWN_PROMOTION);\r\n                                        lc2 = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        if (!((!(\"P\".equals(lc2.getText()))) && (!(\"K\".equals(lc2.getText())))))\r\n                                            throw new SemanticException(\" ! \"P\".equals( lc2.getText()) && ! \"K\".equals( lc2.getText())\");\r\n\r\n                                        plyFragment.setPawnPromotion(lc2.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.GAME_TERMINATOR :\r\n                                case PGNTokenTypes.MOVE_INDEX :\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                case PGNTokenTypes.LEFT_CASTLING :\r\n                                case PGNTokenTypes.RIGHT_CASTLING :\r\n                                case PGNTokenTypes.WS :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.LEFT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.LEFT_CASTLING);\r\n                    plyFragment.setCastling(true);\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.RIGHT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.RIGHT_CASTLING);\r\n                    plyFragment.setCastling(false);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                }\r\n        }\r\n    }\r\n    // When we have all the info from the PGN file, we can try to\r\n    // create a ply notation from it.\r\n    notation = getGameLoader().completePly(plyFragment);\r\n    if (!(notation != null))\r\n        throw new SemanticException(\"notation != null\");\r\n\r\n    return notation;\r\n}'),(508,'resultTag()','de.java_chess.javaChess.pgn.PGNParser.resultTag()','64','PGNParser','public final void resultTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_RESULT);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}'),(509,'roundTag()','de.java_chess.javaChess.pgn.PGNParser.roundTag()','64','PGNParser','public final void roundTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_ROUND);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}'),(510,'setGameLoader(de.java_chess.javaChess.pgn.GameLoader)','de.java_chess.javaChess.pgn.PGNParser.setGameLoader(de.java_chess.javaChess.pgn.GameLoader)','64','PGNParser','/**\r\n * Set a new game loader.\r\n *\r\n * @param loader\r\n * 		The new game loader.\r\n */\r\nprivate final void setGameLoader(GameLoader loader) {\r\n    _gameLoader = loader;\r\n}'),(511,'setNotation(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.pgn.PGNParser.setNotation(de.java_chess.javaChess.notation.GameNotation)','64','PGNParser','/**\r\n * Set a new buffer for the game notation.\r\n *\r\n * @param notation\r\n * 		The new notation buffer.\r\n */\r\npublic final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}'),(512,'siteTag()','de.java_chess.javaChess.pgn.PGNParser.siteTag()','64','PGNParser','public final void siteTag() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.TAG_SITE);\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n}'),(513,'tagPair()','de.java_chess.javaChess.pgn.PGNParser.tagPair()','64','PGNParser','public final void tagPair() throws RecognitionException, TokenStreamException {\r\n    match(PGNTokenTypes.LBRACK);\r\n    whiteSpaces();\r\n    {\r\n        switch (LA(1)) {\r\n            case PGNTokenTypes.TAG_EVENT :\r\n                {\r\n                    eventTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_SITE :\r\n                {\r\n                    siteTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_DATE :\r\n                {\r\n                    dateTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_ROUND :\r\n                {\r\n                    roundTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_WHITE :\r\n                {\r\n                    whiteTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_BLACK :\r\n                {\r\n                    blackTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_RESULT :\r\n                {\r\n                    resultTag();\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.TAG_OPENING :\r\n                {\r\n                    openingTag();\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                }\r\n        }\r\n    }\r\n    whiteSpaces();\r\n    match(PGNTokenTypes.RBRACK);\r\n}'),(514,'tagPairSection()','de.java_chess.javaChess.pgn.PGNParser.tagPairSection()','64','PGNParser','public final void tagPairSection() throws RecognitionException, TokenStreamException {\r\n    {\r\n        _loop4 : do {\r\n            if ((LA(1)) == (PGNTokenTypes.LBRACK)) {\r\n                tagPair();\r\n                whiteSpaces();\r\n            } else {\r\n                break _loop4;\r\n            }\r\n        } while (true );\r\n    }\r\n}'),(515,'whiteSpaces()','de.java_chess.javaChess.pgn.PGNParser.whiteSpaces()','64','PGNParser','public final void whiteSpaces() throws RecognitionException, TokenStreamException {\r\n    {\r\n        _loop29 : do {\r\n            if ((LA(1)) == (PGNTokenTypes.WS)) {\r\n                match(PGNTokenTypes.WS);\r\n            } else {\r\n                break _loop29;\r\n            }\r\n        } while (true );\r\n    }\r\n}'),(516,'whiteTag()','de.java_chess.javaChess.pgn.PGNParser.whiteTag()','64','PGNParser','public final void whiteTag() throws RecognitionException, TokenStreamException {\r\n    Token name = null;\r\n    match(PGNTokenTypes.TAG_WHITE);\r\n    whiteSpaces();\r\n    name = LT(1);\r\n    match(PGNTokenTypes.STRING_LITERAL);\r\n    getNotation().setPlayerInfo(name.getText(), true);\r\n}'),(517,'-init-()','de.java_chess.javaChess.pgn.PGNPlyFragment.-init-()','65','PGNPlyFragment','PGNPlyFragment() {\r\n}'),(518,'getDestination()','de.java_chess.javaChess.pgn.PGNPlyFragment.getDestination()','65','PGNPlyFragment','/**\r\n * Get the current destination of this ply.\r\n *\r\n * @return The currently known destination of this ply.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}'),(519,'getNewPieceType()','de.java_chess.javaChess.pgn.PGNPlyFragment.getNewPieceType()','65','PGNPlyFragment','/**\r\n * Get the new piece type after the pawn promotion.\r\n *\r\n * @return The new piece type after the pawn promotion.\r\n */\r\npublic final byte getNewPieceType() {\r\n    return _newPieceType;\r\n}'),(520,'getOrigin()','de.java_chess.javaChess.pgn.PGNPlyFragment.getOrigin()','65','PGNPlyFragment','/**\r\n * Get the current origin of this ply.\r\n *\r\n * @return The currently known origin of this ply.\r\n */\r\npublic final Position getOrigin() {\r\n    return _origin;\r\n}'),(521,'getPieceType()','de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceType()','65','PGNPlyFragment','/**\r\n * Get the type of the moved piece.\r\n *\r\n * @return The type of the moved piece.\r\n */\r\npublic final byte getPieceType() {\r\n    return _pieceType;\r\n}'),(522,'getPieceTypeFromLetter(char)','de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)','65','PGNPlyFragment','/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(523,'isCapture()','de.java_chess.javaChess.pgn.PGNPlyFragment.isCapture()','65','PGNPlyFragment','/**\r\n * Check, if this ply fragment is a capture.\r\n *\r\n * @return true, if this move is a capture.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}'),(524,'isCastling()','de.java_chess.javaChess.pgn.PGNPlyFragment.isCastling()','65','PGNPlyFragment','/**\r\n * Check, if this ply fragment is a castling.\r\n *\r\n * @return true, if this ply fragment represents a castling. False otherwise.\r\n */\r\npublic final boolean isCastling() {\r\n    return _castling;\r\n}'),(525,'isLeftCastling()','de.java_chess.javaChess.pgn.PGNPlyFragment.isLeftCastling()','65','PGNPlyFragment','/**\r\n * Check, if this castling goes to the left.\r\n *\r\n * @return true, if this castling goes to the left.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _leftCastling;\r\n}'),(526,'isPawnPromotion()','de.java_chess.javaChess.pgn.PGNPlyFragment.isPawnPromotion()','65','PGNPlyFragment','/**\r\n * Check, if this move is a pawn promotion.\r\n *\r\n * @return true, if this move is a pawn promotion. False otherwise.\r\n */\r\npublic final boolean isPawnPromotion() {\r\n    return _pawnPromotion;\r\n}'),(527,'setCapture(boolean)','de.java_chess.javaChess.pgn.PGNPlyFragment.setCapture(boolean)','65','PGNPlyFragment','/**\r\n * Set the flag, if this move captures a piece.\r\n *\r\n * @param capture\r\n * 		true, if this move capures a piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}'),(528,'setCastling(boolean)','de.java_chess.javaChess.pgn.PGNPlyFragment.setCastling(boolean)','65','PGNPlyFragment','/**\r\n * Set this ply as a castling.\r\n *\r\n * @param goesLeft\r\n * 		true, if the castling goes to the left.\r\n */\r\npublic final void setCastling(boolean left) {\r\n    _castling = true;\r\n    _leftCastling = left;\r\n}'),(529,'setDestination(java.lang.String)','de.java_chess.javaChess.pgn.PGNPlyFragment.setDestination(java.lang.String)','65','PGNPlyFragment','/**\r\n * Set the name of the destination square.\r\n *\r\n * @param squareName\r\n * 		The name of the destination square.\r\n */\r\npublic final void setDestination(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _destination = new PositionImpl(squareName);\r\n}'),(530,'setOrigin(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(de.java_chess.javaChess.position.Position)','65','PGNPlyFragment','/**\r\n * Set the name of the origin square.\r\n *\r\n * @param position\r\n * 		The position of the origin square.\r\n */\r\npublic final void setOrigin(Position position) {\r\n    // Store the position.\r\n    _origin = position;\r\n}'),(531,'setOrigin(java.lang.String)','de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(java.lang.String)','65','PGNPlyFragment','/**\r\n * Set the name of the origin square.\r\n *\r\n * @param squareName\r\n * 		The name of the origin square.\r\n */\r\npublic final void setOrigin(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _origin = new PositionImpl(squareName);\r\n}'),(532,'setPawnPromotion(char)','de.java_chess.javaChess.pgn.PGNPlyFragment.setPawnPromotion(char)','65','PGNPlyFragment','/**\r\n * Make this ply a pawn promotion and set the piece type after the promotion.\r\n *\r\n * @param newPieceTypeLetter\r\n * 		The piece type after the pawn promotion as a figurine letter code.\r\n */\r\npublic final void setPawnPromotion(char newPieceTypeLetter) {\r\n    _pawnPromotion = true;\r\n    _newPieceType = getPieceTypeFromLetter(newPieceTypeLetter);\r\n}'),(533,'setPieceType(byte)','de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceType(byte)','65','PGNPlyFragment','/**\r\n * Set the type of the moved piece.\r\n *\r\n * @param type\r\n * 		The type of the moved piece.\r\n */\r\nprivate final void setPieceType(byte type) {\r\n    _pieceType = type;\r\n}'),(534,'setPieceTypeFromLetter(char)','de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceTypeFromLetter(char)','65','PGNPlyFragment','// Constructors\r\n// Methods\r\n/**\r\n * Set the piece type from a figurine letter code.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n */\r\npublic final void setPieceTypeFromLetter(char letter) {\r\n    setPieceType(getPieceTypeFromLetter(letter));\r\n}'),(535,'getColor()','de.java_chess.javaChess.piece.Piece.getColor()','67','Piece','/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic byte getColor();'),(536,'getType()','de.java_chess.javaChess.piece.Piece.getType()','67','Piece','// Methods\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of the piece.\r\n */\r\npublic byte getType();'),(537,'getTypeAndColor()','de.java_chess.javaChess.piece.Piece.getTypeAndColor()','67','Piece','/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic byte getTypeAndColor();'),(538,'isWhite()','de.java_chess.javaChess.piece.Piece.isWhite()','67','Piece','/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic boolean isWhite();'),(539,'setColor(byte)','de.java_chess.javaChess.piece.Piece.setColor(byte)','67','Piece','/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * 		new color of this piece.\r\n */\r\npublic void setColor(byte color);'),(540,'setType(byte)','de.java_chess.javaChess.piece.Piece.setType(byte)','67','Piece','/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * 		The new type of this piece.\r\n */\r\npublic void setType(byte type);'),(541,'-init-(byte)','de.java_chess.javaChess.piece.PieceImpl.-init-(byte)','68','PieceImpl','// Constructors\r\n/**\r\n * Create a new piece instance.\r\n *\r\n * @param typeColor\r\n * 		The color and type of piece, with color in bit 0\r\n * 		and the type color in bit 1-3.\r\n */\r\npublic PieceImpl(byte typeColor) {\r\n    _typeColor = typeColor;\r\n}'),(542,'-init-(byte,byte)','de.java_chess.javaChess.piece.PieceImpl.-init-(byte,byte)','68','PieceImpl','/**\r\n * Create a new Piece instance from type and color.\r\n *\r\n * @param type\r\n * 		The type of the piece.\r\n * @param color\r\n * 		The color of the piece.\r\n */\r\npublic PieceImpl(byte type, byte color) {\r\n    this(((byte) ((type << 1) + color)));\r\n}'),(543,'getColor()','de.java_chess.javaChess.piece.PieceImpl.getColor()','68','PieceImpl','/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic final byte getColor() {\r\n    return ((byte) ((_typeColor) & ((byte) (1))));\r\n}'),(544,'getType()','de.java_chess.javaChess.piece.PieceImpl.getType()','68','PieceImpl','// Methods\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic final byte getType() {\r\n    return ((byte) ((_typeColor) >> 1));\r\n}'),(545,'getTypeAndColor()','de.java_chess.javaChess.piece.PieceImpl.getTypeAndColor()','68','PieceImpl','/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic final byte getTypeAndColor() {\r\n    return _typeColor;\r\n}'),(546,'isWhite()','de.java_chess.javaChess.piece.PieceImpl.isWhite()','68','PieceImpl','/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic final boolean isWhite() {\r\n    return ((_typeColor) & 1) != 0;\r\n}'),(547,'setColor(byte)','de.java_chess.javaChess.piece.PieceImpl.setColor(byte)','68','PieceImpl','/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * 		new color of this piece.\r\n */\r\npublic final void setColor(byte color) {\r\n    _typeColor &= ((byte) (14));\r\n    _typeColor |= color;\r\n}'),(548,'setType(byte)','de.java_chess.javaChess.piece.PieceImpl.setType(byte)','68','PieceImpl','/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * 		The type of this piece as defined as\r\n * 		constants in the Piece interface.\r\n */\r\npublic final void setType(byte type) {\r\n    _typeColor &= ((byte) (1));\r\n    _typeColor |= type << 1;\r\n}'),(549,'clone()','de.java_chess.javaChess.ply.AnalyzedPly.clone()','69','AnalyzedPly','/**\r\n * Clone this ply.\r\n *\r\n * @return A clone of this ply.\r\n */\r\nObject clone();'),(550,'getPly()','de.java_chess.javaChess.ply.AnalyzedPly.getPly()','69','AnalyzedPly','// Methods\r\n/**\r\n * Get the analyzed ply.\r\n *\r\n * @return The analyzed ply.\r\n */\r\nPly getPly();'),(551,'getScore()','de.java_chess.javaChess.ply.AnalyzedPly.getScore()','69','AnalyzedPly','/**\r\n * Get the scrore of this ply.\r\n *\r\n * @return The score of this ply.\r\n */\r\nshort getScore();'),(552,'setPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.ply.AnalyzedPly.setPly(de.java_chess.javaChess.ply.Ply)','69','AnalyzedPly','/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * 		The new ply.\r\n */\r\nvoid setPly(Ply ply);'),(553,'setScore(short)','de.java_chess.javaChess.ply.AnalyzedPly.setScore(short)','69','AnalyzedPly','/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * 		The new score for this ply.\r\n */\r\nvoid setScore(short score);'),(554,'-init-(de.java_chess.javaChess.ply.Ply,short)','de.java_chess.javaChess.ply.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)','70','AnalyzedPlyImpl','// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}'),(555,'clone()','de.java_chess.javaChess.ply.AnalyzedPlyImpl.clone()','70','AnalyzedPlyImpl','/**\r\n * Clone this ply.\r\n *\r\n * @return A clone of this ply.\r\n */\r\npublic Object clone() {\r\n    return new AnalyzedPlyImpl(getPly(), getScore());\r\n}'),(556,'getPly()','de.java_chess.javaChess.ply.AnalyzedPlyImpl.getPly()','70','AnalyzedPlyImpl','// Methods\r\n/**\r\n * Get the analyzed ply.\r\n *\r\n * @return The analyzed ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}'),(557,'getScore()','de.java_chess.javaChess.ply.AnalyzedPlyImpl.getScore()','70','AnalyzedPlyImpl','/**\r\n * Get the scrore of this ply.\r\n *\r\n * @return The score of this ply.\r\n */\r\npublic final short getScore() {\r\n    return _score;\r\n}'),(558,'setPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.ply.AnalyzedPlyImpl.setPly(de.java_chess.javaChess.ply.Ply)','70','AnalyzedPlyImpl','/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * 		The new ply.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(559,'setScore(short)','de.java_chess.javaChess.ply.AnalyzedPlyImpl.setScore(short)','70','AnalyzedPlyImpl','/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * 		The new score for this ply.\r\n */\r\npublic final void setScore(short score) {\r\n    _score = score;\r\n}'),(560,'isLeftCastling()','de.java_chess.javaChess.ply.CastlingPly.isLeftCastling()','71','CastlingPly','// Static variables\r\n// Methods\r\n/**\r\n * Check, if this castling goes to the left side of the board.\r\n *\r\n * @return true, if the castling goes to the left side, false otherwise.\r\n */\r\nboolean isLeftCastling();'),(561,'setLeftCastling(boolean)','de.java_chess.javaChess.ply.CastlingPly.setLeftCastling(boolean)','71','CastlingPly','/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\nvoid setLeftCastling(boolean goesLeft);'),(562,'-init-(de.java_chess.javaChess.position.Position,boolean)','de.java_chess.javaChess.ply.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)','72','CastlingPlyImpl','// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}'),(563,'isLeftCastling()','de.java_chess.javaChess.ply.CastlingPlyImpl.isLeftCastling()','72','CastlingPlyImpl','// Methods\r\n/**\r\n * Check, if this castling goes to the left side of the board.\r\n *\r\n * @return true, if the castling goes to the left side, false otherwise.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _goesLeft;\r\n}'),(564,'setLeftCastling(boolean)','de.java_chess.javaChess.ply.CastlingPlyImpl.setLeftCastling(boolean)','72','CastlingPlyImpl','/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\npublic final void setLeftCastling(boolean goesLeft) {\r\n    _goesLeft = goesLeft;\r\n}'),(565,'toString()','de.java_chess.javaChess.ply.CastlingPlyImpl.toString()','72','CastlingPlyImpl','/**\r\n * Get a string representation of this castling.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic final String toString() {\r\n    return isLeftCastling() ? \"O-O-O\" : \"O-O\";\r\n}'),(566,'getAttackedPosition()','de.java_chess.javaChess.ply.EnPassantPly.getAttackedPosition()','73','EnPassantPly','// Methods\r\n/**\r\n * Get the position of the attacked pawn.\r\n *\r\n * @return Get the position of the attacked pawn.\r\n */\r\nPosition getAttackedPosition();'),(567,'setAttackedPosition(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.ply.EnPassantPly.setAttackedPosition(de.java_chess.javaChess.position.Position)','73','EnPassantPly','/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * 		The position of the attacked pawn.\r\n */\r\nvoid setAttackedPosition(Position attackedPosition);'),(568,'-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)','74','EnPassantPlyImpl','// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * 		The source square of the attacking pawn.\r\n * @param destination\r\n * 		The destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * 		The position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}'),(569,'getAttackedPosition()','de.java_chess.javaChess.ply.EnPassantPlyImpl.getAttackedPosition()','74','EnPassantPlyImpl','// Methods\r\n/**\r\n * Get the position of the attacked pawn.\r\n *\r\n * @return Get the position of the attacked pawn.\r\n */\r\npublic final Position getAttackedPosition() {\r\n    return _attackedPosition;\r\n}'),(570,'setAttackedPosition(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.ply.EnPassantPlyImpl.setAttackedPosition(de.java_chess.javaChess.position.Position)','74','EnPassantPlyImpl','/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * 		The position of the attacked pawn.\r\n */\r\npublic final void setAttackedPosition(Position attackedPosition) {\r\n    _attackedPosition = attackedPosition;\r\n}'),(571,'equals(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.ply.Ply.equals(de.java_chess.javaChess.ply.Ply)','75','Ply','/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * 		The other ply.\r\n * @return true, if the 2 plies are equal. False otherwise.\r\n */\r\nboolean equals(Ply ply);'),(572,'getDestination()','de.java_chess.javaChess.ply.Ply.getDestination()','75','Ply','/**\r\n * Get the destination of the piece.\r\n *\r\n * @return The destination square of this ply.\r\n */\r\nPosition getDestination();'),(573,'getSource()','de.java_chess.javaChess.ply.Ply.getSource()','75','Ply','// Static variables\r\n// Methods\r\n/**\r\n * Get the source of the ply.\r\n *\r\n * @return The source square of this ply.\r\n */\r\nPosition getSource();'),(574,'isCapture()','de.java_chess.javaChess.ply.Ply.isCapture()','75','Ply','/**\r\n * Check, if this ply captures another piece.\r\n *\r\n * @return true, if another piece is captured with this ply.\r\n */\r\nboolean isCapture();'),(575,'setDestination(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.ply.Ply.setDestination(de.java_chess.javaChess.position.Position)','75','Ply','/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * 		The new destination square of this ply.\r\n */\r\nvoid setDestination(Position destination);'),(576,'setSource(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.ply.Ply.setSource(de.java_chess.javaChess.position.Position)','75','Ply','/**\r\n * Set the source of the ply.\r\n *\r\n * @param source\r\n * 		The new source square for this ply.\r\n */\r\nvoid setSource(Position source);'),(577,'-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)','de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)','76','PlyImpl','// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param capture\r\n * 		Flag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}'),(578,'equals(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)','76','PlyImpl','/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * 		The other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}'),(579,'getDestination()','de.java_chess.javaChess.ply.PlyImpl.getDestination()','76','PlyImpl','/**\r\n * Get the destination of the piece.\r\n *\r\n * @return The destination of the piece.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}'),(580,'getSource()','de.java_chess.javaChess.ply.PlyImpl.getSource()','76','PlyImpl','// Methods\r\n/**\r\n * Get the source of the ply.\r\n *\r\n * @return The source of the piece.\r\n */\r\npublic final Position getSource() {\r\n    return _source;\r\n}'),(581,'isCapture()','de.java_chess.javaChess.ply.PlyImpl.isCapture()','76','PlyImpl','/**\r\n * Check, if this ply captures another piece.\r\n *\r\n * @return true, if another piece is captured with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}'),(582,'setCapture(boolean)','de.java_chess.javaChess.ply.PlyImpl.setCapture(boolean)','76','PlyImpl','/**\r\n * Set a flag, if this ply captures another piece.\r\n *\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}'),(583,'setDestination(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.ply.PlyImpl.setDestination(de.java_chess.javaChess.position.Position)','76','PlyImpl','/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * 		The new destination of the piece.\r\n */\r\npublic final void setDestination(Position destination) {\r\n    _destination = destination;\r\n}'),(584,'setSource(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.ply.PlyImpl.setSource(de.java_chess.javaChess.position.Position)','76','PlyImpl','/**\r\n * Set the source of the ply.\r\n *\r\n * @param The\r\n * 		new source of the piece.\r\n */\r\npublic final void setSource(Position source) {\r\n    _source = source;\r\n}'),(585,'toString()','de.java_chess.javaChess.ply.PlyImpl.toString()','76','PlyImpl','/**\r\n * Convert the ply into something human readable. Its not exactly chess\r\n * notation, since we dont have a board to check, if it is a move or\r\n * a attack.\r\n *\r\n * @return The ply as a string.\r\n */\r\npublic String toString() {\r\n    return ((getSource().toSquareName()) + \"-\") + (getDestination().toSquareName());\r\n}'),(586,'getTypeAfterTransformation()','de.java_chess.javaChess.ply.TransformationPly.getTypeAfterTransformation()','77','TransformationPly','// Methods\r\n/**\r\n * Get the new type of the piece after the transformation.\r\n *\r\n * @return The new piece after the transformation.\r\n */\r\nbyte getTypeAfterTransformation();'),(587,'setTypeAfterTransformation(byte)','de.java_chess.javaChess.ply.TransformationPly.setTypeAfterTransformation(byte)','77','TransformationPly','/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * 		The new piece type after the transformation.\r\n */\r\nvoid setTypeAfterTransformation(byte pieceType);'),(588,'-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)','de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)','78','TransformationPlyImpl','// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param pieceType\r\n * 		The piece type after the transformation.\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}'),(589,'getTypeAfterTransformation()','de.java_chess.javaChess.ply.TransformationPlyImpl.getTypeAfterTransformation()','78','TransformationPlyImpl','// Methods\r\n/**\r\n * Get the new type of the piece after the transformation.\r\n *\r\n * @return The new piece after the transformation.\r\n */\r\npublic final byte getTypeAfterTransformation() {\r\n    return _newPieceType;\r\n}'),(590,'setTypeAfterTransformation(byte)','de.java_chess.javaChess.ply.TransformationPlyImpl.setTypeAfterTransformation(byte)','78','TransformationPlyImpl','/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * 		The new piece type after the transformation.\r\n */\r\npublic final void setTypeAfterTransformation(byte pieceType) {\r\n    _newPieceType = pieceType;\r\n}'),(591,'-init-()','de.java_chess.javaChess.position.IllegalPositionException.-init-()','79','IllegalPositionException','IllegalPositionException() {\r\n}'),(592,'equals(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.position.Position.equals(de.java_chess.javaChess.position.Position)','80','Position','/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * 		position.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\nboolean equals(Position pos);'),(593,'getLineIndex()','de.java_chess.javaChess.position.Position.getLineIndex()','80','Position','/**\r\n * Get the line index of this position.\r\n *\r\n * @return The line index of this position (0-7).\r\n */\r\nint getLineIndex();'),(594,'getRowIndex()','de.java_chess.javaChess.position.Position.getRowIndex()','80','Position','/**\r\n * Get the row index of this position.\r\n *\r\n * @return The row index of this position (0-7).\r\n */\r\nint getRowIndex();'),(595,'getSquareIndex()','de.java_chess.javaChess.position.Position.getSquareIndex()','80','Position','// Methods\r\n/**\r\n * Get the square index of this position instance.\r\n *\r\n * @return The square index of this piece position (0-63).\r\n */\r\nint getSquareIndex();'),(596,'setSquareIndex(int)','de.java_chess.javaChess.position.Position.setSquareIndex(int)','80','Position','/**\r\n * The square index of this position instance.\r\n *\r\n * @param index\r\n * 		The square index of this position (0-63).\r\n */\r\nvoid setSquareIndex(int index);'),(597,'toSquareName()','de.java_chess.javaChess.position.Position.toSquareName()','80','Position','/**\r\n * Get the name of this square.\r\n *\r\n * @return The suare name of this position (i.e. a4).\r\n */\r\nString toSquareName();'),(598,'-init-(int)','de.java_chess.javaChess.position.PositionImpl.-init-(int)','81','PositionImpl','// Constructors\r\n/**\r\n * Create a position from a given square index.\r\n *\r\n * @param squareIndex\r\n * 		The index of the square (0..63).\r\n */\r\npublic PositionImpl(int squareIndex) {\r\n    setSquareIndex(squareIndex);\r\n}'),(599,'-init-(java.lang.String)','de.java_chess.javaChess.position.PositionImpl.-init-(java.lang.String)','81','PositionImpl','/**\r\n * Create a position from a given square name (i.e. d4).\r\n *\r\n * @param squareName\r\n * 		The name of the square.\r\n * @throws IllegalPositionException\r\n * 		If the argument is not a valid square name.\r\n */\r\npublic PositionImpl(String squareName) throws IllegalPositionException {\r\n    // -1 indicates an error here.\r\n    int squareIndex = -1;\r\n    // Trim and convert the name to lower case.\r\n    squareName = squareName.trim().toLowerCase();\r\n    // Check if the name has no extra characters\r\n    if ((squareName.length()) != 2) {\r\n        throw new IllegalPositionException();\r\n    } else {\r\n        // Get the line.\r\n        char lineLetter = squareName.charAt(0);\r\n        if ((lineLetter < a) || (lineLetter > h)) {\r\n            throw new IllegalPositionException();\r\n        } else {\r\n            // Compute the index of the line.\r\n            int lineIndex = lineLetter - a;\r\n            // Get the name of the row.\r\n            char rowLetter = squareName.charAt(1);\r\n            if ((rowLetter < 1) || (rowLetter > 8)) {\r\n                throw new IllegalPositionException();\r\n            } else {\r\n                int rowIndex = rowLetter - 1;\r\n                // The square index is 8 * row + line.\r\n                squareIndex = (rowIndex << 3) + lineIndex;\r\n            }\r\n        }\r\n    }\r\n    // Set the computed square index.\r\n    setSquareIndex(squareIndex);\r\n}'),(600,'equals(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)','81','PositionImpl','/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * 		position.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}'),(601,'getLineIndex()','de.java_chess.javaChess.position.PositionImpl.getLineIndex()','81','PositionImpl','/**\r\n * Get the line index of this postion (0-7).\r\n *\r\n * @return The line index of this position.\r\n */\r\npublic final int getLineIndex() {\r\n    return (_squareIndex) & 7;\r\n}'),(602,'getRowIndex()','de.java_chess.javaChess.position.PositionImpl.getRowIndex()','81','PositionImpl','/**\r\n * Get the row index of this position (0-7).\r\n *\r\n * @return The row index of this position.\r\n */\r\npublic final int getRowIndex() {\r\n    return (_squareIndex) >> 3;\r\n}'),(603,'getSquareIndex()','de.java_chess.javaChess.position.PositionImpl.getSquareIndex()','81','PositionImpl','// Methods\r\n/**\r\n * Get the square index of this position (0-63).\r\n *\r\n * @return The square index of this position.\r\n */\r\npublic final int getSquareIndex() {\r\n    return _squareIndex;\r\n}'),(604,'setSquareIndex(int)','de.java_chess.javaChess.position.PositionImpl.setSquareIndex(int)','81','PositionImpl','/**\r\n * Set the square index of this position.\r\n *\r\n * @param squareIndex\r\n * 		The new square index of this position.\r\n */\r\npublic final void setSquareIndex(int squareIndex) {\r\n    _squareIndex = squareIndex;\r\n}'),(605,'toSquareName()','de.java_chess.javaChess.position.PositionImpl.toSquareName()','81','PositionImpl','/**\r\n * Convert this position to a square name (like a4).\r\n *\r\n * @return The suare name of this position.\r\n */\r\npublic final String toSquareName() {\r\n    byte[] byteRepresentation = new byte[2];\r\n    byteRepresentation[0] = ((byte) (((int) (a)) + (getLineIndex())));\r\n    byteRepresentation[1] = ((byte) (((int) (1)) + (getRowIndex())));\r\n    return new String(byteRepresentation);\r\n}'),(606,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.renderer.ChessBoardRenderer.doPly(de.java_chess.javaChess.ply.Ply)','82','ChessBoardRenderer','/**\r\n * Render a piece move.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\nvoid doPly(Ply ply);'),(607,'getBoard()','de.java_chess.javaChess.renderer.ChessBoardRenderer.getBoard()','82','ChessBoardRenderer','/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nBoard getBoard();'),(608,'repaintBoard()','de.java_chess.javaChess.renderer.ChessBoardRenderer.repaintBoard()','82','ChessBoardRenderer','/**\r\n * Repaint the current board.\r\n */\r\nvoid repaintBoard();'),(609,'reset()','de.java_chess.javaChess.renderer.ChessBoardRenderer.reset()','82','ChessBoardRenderer','/**\r\n * Reset the renderer for a new game.\r\n */\r\nvoid reset();'),(610,'setBoard(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.renderer.ChessBoardRenderer.setBoard(de.java_chess.javaChess.board.Board)','82','ChessBoardRenderer','/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(Board board);'),(611,'-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)','de.java_chess.javaChess.renderer2d.AnimationLayer.-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)','83','AnimationLayer','// Constructors\r\n/**\r\n * Create a new AnimationLayer instance.\r\n *\r\n * @param piecesLayer\r\n * 		The layer with the pieces.\r\n */\r\nAnimationLayer(PiecesLayer piecesLayer) {\r\n    setPiecesLayer(piecesLayer);\r\n}'),(612,'animatePly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.renderer2d.AnimationLayer.animatePly(de.java_chess.javaChess.ply.Ply)','83','AnimationLayer','// Methods\r\n/**\r\n * Animate the move of a piece.\r\n */\r\nvoid animatePly(Ply ply) {\r\n    _ply = ply;\r\n}'),(613,'getPiecesLayer()','de.java_chess.javaChess.renderer2d.AnimationLayer.getPiecesLayer()','83','AnimationLayer','/**\r\n * Paint the animated piece.\r\n *\r\n * @param g\r\n * 		The graphics context.\r\n */\r\n/* public void paint( Graphics g) {\nSystem.out.println( \"Repaint piece at \" + _currentPoint.x + \",\" + _currentPoint.y);\n// g.drawImage( _piece, _currentPoint.x, _currentPoint.y, this);\n}\n */\r\n/**\r\n * Get the current pieces layer.\r\n *\r\n * @return The current pieces layer.\r\n */\r\nPiecesLayer getPiecesLayer() {\r\n    return _piecesLayer;\r\n}'),(614,'run()','de.java_chess.javaChess.renderer2d.AnimationLayer.run()','83','AnimationLayer','/**\r\n * The run method to start the animation thread.\r\n */\r\npublic void run() {\r\n    ImageIcon icon = ((ImageIcon) (getPiecesLayer().getPositionRenderer(_ply.getSource().getSquareIndex()).getIcon()));\r\n    JLabel movingPiece = new JLabel(icon);\r\n    // _piece = (PieceRenderer)icon.getImage();\r\n    getPiecesLayer().getPositionRenderer(_ply.getSource().getSquareIndex()).setIcon(null);\r\n    getPiecesLayer().repaint();\r\n    int xOffset = ((ChessBoardRenderer2D.getSquareSize()) - (icon.getIconWidth())) / 2;\r\n    int yOffset = ((ChessBoardRenderer2D.getSquareSize()) - (icon.getIconHeight())) / 2;\r\n    _currentPoint = new Point(((((_ply.getSource().getSquareIndex()) & 7) * (ChessBoardRenderer2D.getSquareSize())) + xOffset), (((7 - ((_ply.getSource().getSquareIndex()) >> 3)) * (ChessBoardRenderer2D.getSquareSize())) + yOffset));\r\n    Point endPoint = new Point(((((_ply.getDestination().getSquareIndex()) & 7) * (ChessBoardRenderer2D.getSquareSize())) + xOffset), (((7 - ((_ply.getDestination().getSquareIndex()) >> 3)) * (ChessBoardRenderer2D.getSquareSize())) + yOffset));\r\n    int xMoveOffset = ((_currentPoint.x) < (endPoint.x)) ? 1 : (_currentPoint.x) > (endPoint.x) ? -1 : 0;\r\n    int yMoveOffset = ((_currentPoint.y) < (endPoint.y)) ? 1 : (_currentPoint.y) > (endPoint.y) ? -1 : 0;\r\n    movingPiece.setLocation(_currentPoint);\r\n    while (!(_currentPoint.equals(endPoint))) {\r\n        if ((_currentPoint.x) == (endPoint.x)) {\r\n            xMoveOffset = 0;\r\n        }\r\n        if ((_currentPoint.y) == (endPoint.y)) {\r\n            yMoveOffset = 0;\r\n        }\r\n        _currentPoint.x += xMoveOffset;\r\n        _currentPoint.y += yMoveOffset;\r\n        // invalidate();\r\n        // repaint();\r\n        // paint( getGraphics());\r\n        // getGraphics().drawImage( _piece, _currentPoint.x, _currentPoint.y, this);\r\n        movingPiece.setLocation(_currentPoint);\r\n        paintImmediately(((_currentPoint.x) - 1), ((_currentPoint.y) - 1), ChessBoardRenderer2D.getSquareSize(), ChessBoardRenderer2D.getSquareSize());\r\n        try {\r\n            Thread.sleep(5);\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n        // getGraphics().clearRect( _currentPoint.x - 1, _currentPoint.y - 1, ChessBoardRenderer2D.getSquareSize() + 1, ChessBoardRenderer2D.getSquareSize() + 1);\r\n    } \r\n    movingPiece.setVisible(false);\r\n    getPiecesLayer().getPositionRenderer(_ply.getDestination().getSquareIndex()).setIcon(icon);\r\n    _ply = null;\r\n    _animationThread = null;\r\n}'),(615,'setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)','de.java_chess.javaChess.renderer2d.AnimationLayer.setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)','83','AnimationLayer','/**\r\n * Set a new pieces layer.\r\n *\r\n * @param piecesLayer\r\n * 		The new pieces layer.\r\n */\r\nvoid setPiecesLayer(PiecesLayer piecesLayer) {\r\n    _piecesLayer = piecesLayer;\r\n}'),(616,'start()','de.java_chess.javaChess.renderer2d.AnimationLayer.start()','83','AnimationLayer','/**\r\n * The method to start the thread.\r\n */\r\npublic void start() {\r\n    if ((_animationThread) == null) {\r\n        _animationThread = new Thread(this);\r\n        _animationThread.start();\r\n    }\r\n}'),(617,'-init-()','de.java_chess.javaChess.renderer2d.BoardLayer.-init-()','84','BoardLayer','// Constructors\r\nBoardLayer() {\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n}'),(618,'getBoardSize()','de.java_chess.javaChess.renderer2d.BoardLayer.getBoardSize()','84','BoardLayer','/**\r\n * Get the board size.\r\n *\r\n * @return The board size.\r\n */\r\nfinal int getBoardSize() {\r\n    return _boardSize;\r\n}'),(619,'getMaximumSize()','de.java_chess.javaChess.renderer2d.BoardLayer.getMaximumSize()','84','BoardLayer','/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}'),(620,'getMinimumSize()','de.java_chess.javaChess.renderer2d.BoardLayer.getMinimumSize()','84','BoardLayer','/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(getBoardSize(), getBoardSize());\r\n}'),(621,'getPreferredSize()','de.java_chess.javaChess.renderer2d.BoardLayer.getPreferredSize()','84','BoardLayer','/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}'),(622,'getSquareSize()','de.java_chess.javaChess.renderer2d.BoardLayer.getSquareSize()','84','BoardLayer','/**\r\n * Get the square size.\r\n *\r\n * @return The square size.\r\n */\r\nfinal int getSquareSize() {\r\n    return _squareSize;\r\n}'),(623,'paintComponent(java.awt.Graphics)','de.java_chess.javaChess.renderer2d.BoardLayer.paintComponent(java.awt.Graphics)','84','BoardLayer','// Methods\r\npublic void paintComponent(Graphics g) {\r\n    // g.setColor( new Color( 190, 190, 140) );\r\n    // g.setColor( new Color( 229, 229, 225) );\r\n    g.setColor(new Color(247, 247, 245));\r\n    g.fillRect(0, 0, _boardSize, _boardSize);\r\n    // g.setColor( new Color( 122, 80, 44));\r\n    // g.setColor( new Color( 250, 105, 86));\r\n    // g.setColor( new Color( 235, 142, 9));\r\n    g.setColor(new Color(249, 134, 89));\r\n    for (int i = 0; i < 8; i++)\r\n        for (int j = 0; j < 8; j++)\r\n            if (((i % 2) != 0) && ((j % 2) == 0))\r\n                g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n            else\r\n                if (((i % 2) == 0) && ((j % 2) != 0))\r\n                    g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n\r\n\r\n\r\n\r\n}'),(624,'-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)','85','ChessBoardRenderer2D','// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * 		The game controller.\r\n * @param board\r\n * 		The current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}'),(625,'clearBoard()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.clearBoard()','85','ChessBoardRenderer2D','/**\r\n * Repaint the board after a game position change.\r\n */\r\npublic final void clearBoard() {\r\n    _piecesLayer.clearBoard();\r\n    repaint();\r\n}'),(626,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.doPly(de.java_chess.javaChess.ply.Ply)','85','ChessBoardRenderer2D','/**\r\n * Render a ply (the move of a piece).\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    _piecesLayer.doPly(ply);\r\n    repaint();\r\n}'),(627,'getBoard()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getBoard()','85','ChessBoardRenderer2D','/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}'),(628,'getMaximumSize()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMaximumSize()','85','ChessBoardRenderer2D','/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}'),(629,'getMinimumSize()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMinimumSize()','85','ChessBoardRenderer2D','/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)), ((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)));\r\n}'),(630,'getPreferredSize()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getPreferredSize()','85','ChessBoardRenderer2D','/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}'),(631,'getSquareSize()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getSquareSize()','85','ChessBoardRenderer2D','/**\r\n * Get the size of a square.\r\n *\r\n * @return The size of a square as a int (since height and width are the same).\r\n */\r\npublic static final int getSquareSize() {\r\n    return ChessBoardRenderer2D._squareSize;\r\n}'),(632,'repaintBoard()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.repaintBoard()','85','ChessBoardRenderer2D','/**\r\n * Repaint the board after a game position change.\r\n */\r\npublic final void repaintBoard() {\r\n    _piecesLayer.repaintBoard();\r\n    repaint();\r\n}'),(633,'reset()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.reset()','85','ChessBoardRenderer2D','/**\r\n * Reset the renderer for a new game.\r\n */\r\npublic void reset() {\r\n    repaintBoard();\r\n}'),(634,'setBoard(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.setBoard(de.java_chess.javaChess.board.Board)','85','ChessBoardRenderer2D','/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}'),(635,'-init-(java.awt.Component)','de.java_chess.javaChess.renderer2d.ChessSet.-init-(java.awt.Component)','86','ChessSet','// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new chess set component.\r\n *\r\n * @param c\r\n * 		The parent component.\r\n */\r\npublic ChessSet(Component c) {\r\n    super(240, 80, BufferedImage.TYPE_INT_ARGB);\r\n    Image im = null;\r\n    // try {\r\n    // URL url = getClass().getResource(\"ChessPieces_neu.gif\");\r\n    // im = Toolkit.getDefaultToolkit().getImage( url );\r\n    // im = Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/ChessPieces02.gif\"));\r\n    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // original\r\n    // im = ResourceLoader.getInstance().loadImage( \"ChessPieces02.gif\");\r\n    // achraf\r\n    URL urlStart = getClass().getResource(\"images/ChessPieces02.gif\");\r\n    im = Toolkit.getDefaultToolkit().getImage(urlStart);\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // } catch( MalformedURLException ignored) {}\r\n    MediaTracker mT = new MediaTracker(c);\r\n    mT.addImage(im, 0);\r\n    try {\r\n        mT.waitForID(0);\r\n    } catch (InterruptedException ie) {\r\n    }\r\n    Graphics g = getGraphics();\r\n    g.drawImage(im, 0, 0, c);\r\n}'),(636,'-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)','de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)','87','ControlLayer','// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}'),(637,'-init-()','de.java_chess.javaChess.renderer2d.ControlLayer.-init-()','87','ControlLayer','1() {\r\n}'),(638,'getController()','de.java_chess.javaChess.renderer2d.ControlLayer.getController()','87','ControlLayer','/**\r\n * Get the game controller.\r\n *\r\n * @return The game controller.\r\n */\r\nprivate final GameController getController() {\r\n    return _controller;\r\n}'),(639,'markSquare(int,java.awt.Graphics)','de.java_chess.javaChess.renderer2d.ControlLayer.markSquare(int,java.awt.Graphics)','87','ControlLayer','/**\r\n * Draw a marker at the given square.\r\n *\r\n * @param square\r\n * 		The square to mark.\r\n * @param g\r\n * 		The graphics context.\r\n */\r\nprivate final void markSquare(int square, Graphics g) {\r\n    int xpos = (square & 7) * (_squareSize);\r\n    // Compute the location of the\r\n    int ypos = (7 - (square >> 3)) * (_squareSize);// square\r\n\r\n    int rectSize = (_squareSize) - 1;\r\n    // and its size.\r\n    g.setColor(Color.blue);\r\n    // Simply draw a blue frame there.\r\n    for (int i = 0; i < 3; i++) {\r\n        g.drawRect((xpos++), (ypos++), rectSize, rectSize);\r\n        rectSize -= 2;\r\n    }\r\n}'),(640,'paintComponent(java.awt.Graphics)','de.java_chess.javaChess.renderer2d.ControlLayer.paintComponent(java.awt.Graphics)','87','ControlLayer','// Methods\r\n/**\r\n * Overridden  paintComponent method to draw the marker for\r\n * the source square.\r\n *\r\n * @param g\r\n * 		The graphics context.\r\n */\r\npublic void paintComponent(Graphics g) {\r\n    if ((_sourceSquare) != (-1)) {\r\n        // If a source square is selected,\r\n        markSquare(_sourceSquare, g);// mark it.\r\n\r\n    }\r\n}'),(641,'setController(de.java_chess.javaChess.GameController)','de.java_chess.javaChess.renderer2d.ControlLayer.setController(de.java_chess.javaChess.GameController)','87','ControlLayer','/**\r\n * Set a new game controller.\r\n *\r\n * @param The\r\n * 		new game controller.\r\n */\r\nprivate final void setController(GameController controller) {\r\n    _controller = controller;\r\n}'),(642,'-init-()','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.-init-()','88','CountdownTimerPanel','/**\r\n * The start time of the thread.\r\n */\r\n// long _startTime;\r\n// Constructors\r\n/**\r\n * Create a new countdown timer panel.\r\n */\r\npublic CountdownTimerPanel() {\r\n    _actionListeners = new ArrayList();\r\n    // _startTime = -1L;\r\n    _display = new JLabel(\"0:00:00\", JLabel.RIGHT);\r\n    _display.setPreferredSize(new Dimension(CountdownTimerPanel._displayWidth, CountdownTimerPanel._displayHeight));\r\n    _display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    add(_display);\r\n}'),(643,'addActionListener(java.awt.event.ActionListener)','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.addActionListener(java.awt.event.ActionListener)','88','CountdownTimerPanel','// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}'),(644,'alignText()','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.alignText()','88','CountdownTimerPanel','public void alignText() {\r\n    this._display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    this._display.setHorizontalAlignment(SwingConstants.CENTER);\r\n}'),(645,'display(long)','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.display(long)','88','CountdownTimerPanel','/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * 		The current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, CountdownTimerPanel._displayWidth, CountdownTimerPanel._displayHeight);\r\n}'),(646,'getRemainingTime()','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.getRemainingTime()','88','CountdownTimerPanel','/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}'),(647,'notifyListeners(java.awt.event.ActionEvent)','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.notifyListeners(java.awt.event.ActionEvent)','88','CountdownTimerPanel','/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * 		The action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}'),(648,'run()','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.run()','88','CountdownTimerPanel','/**\r\n * The actual thread method.\r\n */\r\npublic void run() {\r\n    long startTime = System.currentTimeMillis();// The time when this run started.\r\n\r\n    long runningTime;\r\n    // The length of this run.\r\n    try {\r\n        // While theres still time left and noone stopped the thread.\r\n        do {\r\n            Thread.sleep(100);// Wait 1/10 of a second.\r\n\r\n            runningTime = (System.currentTimeMillis()) - startTime;\r\n            display(((_remainingTime) - runningTime));// decrease the time by a second and display it.\r\n\r\n        } while (((_remainingTime) >= runningTime) && ((Thread.currentThread()) == (_timerThread)) );\r\n        _remainingTime -= runningTime;// Substract the length of this thinking time.\r\n\r\n        // Now notify all the action listeners, that the timer has stopped.\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((_remainingTime) < 0L ? \"timeout\" : \"interrupted\")));\r\n    } catch (InterruptedException ignored) {\r\n    }\r\n}'),(649,'setCountdown(int)','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.setCountdown(int)','88','CountdownTimerPanel','/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * 		The length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    // _startTime = -1L;\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}'),(650,'start()','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.start()','88','CountdownTimerPanel','/**\r\n * Start the timer.\r\n */\r\npublic void start() {\r\n    if ((_time) > 0L) {\r\n        // if( _startTime == -1L) {\r\n        // _startTime = System.currentTimeMillis();\r\n        // }\r\n        if ((_timerThread) == null) {\r\n            _timerThread = new Thread(this);\r\n            _timerThread.start();\r\n        }\r\n    }\r\n}'),(651,'stop()','de.java_chess.javaChess.renderer2d.CountdownTimerPanel.stop()','88','CountdownTimerPanel','/**\r\n * Stop the timer.\r\n */\r\npublic void stop() {\r\n    // If there is a running thread.\r\n    if ((_timerThread) != null) {\r\n        Thread timerThread = _timerThread;// Copy it.\r\n\r\n        _timerThread = null;\r\n        // Signal to stop the thread.\r\n        try {\r\n            timerThread.join();// And wait for the thread to end.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n}'),(652,'-init-()','de.java_chess.javaChess.renderer2d.EnginePanel.-init-()','89','EnginePanel','/**\r\n * Standardconstructor\r\n */\r\npublic EnginePanel() {\r\n    super();\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(653,'getText()','de.java_chess.javaChess.renderer2d.EnginePanel.getText()','89','EnginePanel','/**\r\n * Get the current text of the panel.\r\n *\r\n * @return The current text of the panel.\r\n */\r\npublic final String getText() {\r\n    return this.jtEngine.getText();\r\n}'),(654,'jbInit()','de.java_chess.javaChess.renderer2d.EnginePanel.jbInit()','89','EnginePanel','/**\r\n * Construction a la JBuilder to be able to use the JBuilder designer\r\n *\r\n * @throws Exception\r\n * 		\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagEngine);\r\n    this.jtEngine.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.jtEngine.setEditable(false);\r\n    this.jtEngine.setLineWrap(true);\r\n    this.jtEngine.setWrapStyleWord(true);\r\n    this.jScrollPane = new JScrollPane(this.jtEngine);\r\n    this.jlHeadline = new JLabel(\"Engine and debug output:\");\r\n    this.add(this.jScrollPane, new GridBagConstraints(0, 1, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(this.jlHeadline, new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    // ,GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n}'),(655,'modifyText(java.lang.String)','de.java_chess.javaChess.renderer2d.EnginePanel.modifyText(java.lang.String)','89','EnginePanel','/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * 		The text to add\r\n */\r\npublic final void modifyText(String newText) {\r\n    String sCurrentText = getText();\r\n    if (!(sCurrentText.equals(\"\"))) {\r\n        setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtEngine.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        setText(newText);\r\n    }\r\n}'),(656,'setText(java.lang.String)','de.java_chess.javaChess.renderer2d.EnginePanel.setText(java.lang.String)','89','EnginePanel','/**\r\n * Set the current text of the engine panel.\r\n *\r\n * @param newText\r\n * 		The new text to set.\r\n */\r\npublic final void setText(String newText) {\r\n    this.jtEngine.setText(newText);\r\n}'),(657,'-init-()','de.java_chess.javaChess.renderer2d.GameTimerPanel.-init-()','90','GameTimerPanel','// Constructors\r\n/**\r\n * Create a new timer instance for a game.\r\n */\r\npublic GameTimerPanel() {\r\n    super();\r\n    // Create a new array for the action listeners.\r\n    _actionListeners = new ArrayList();\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(658,'-init-(int)','de.java_chess.javaChess.renderer2d.GameTimerPanel.-init-(int)','90','GameTimerPanel','/**\r\n * Create a given game timer with a countdown time.\r\n *\r\n * @param maxTime\r\n * 		The remaining time.\r\n */\r\npublic GameTimerPanel(int maxTime) {\r\n    this();\r\n    setCountdown(maxTime);\r\n}'),(659,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.renderer2d.GameTimerPanel.actionPerformed(java.awt.event.ActionEvent)','90','GameTimerPanel','/**\r\n * Get a event from one of the timers.\r\n *\r\n * ActionEvent event The event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    if (!(\"interrupted\".equals(event.getActionCommand()))) {\r\n        // This event means, that the timer sending the event has stopped,\r\n        // so stop the entire timer for now.\r\n        stop();\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((event.getSource()) == (_white) ? \"timeout white\" : \"timeout black\")));\r\n    }\r\n}'),(660,'addActionListener(java.awt.event.ActionListener)','de.java_chess.javaChess.renderer2d.GameTimerPanel.addActionListener(java.awt.event.ActionListener)','90','GameTimerPanel','/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}'),(661,'isRunning()','de.java_chess.javaChess.renderer2d.GameTimerPanel.isRunning()','90','GameTimerPanel','/**\r\n * Get the active state of this timer.\r\n *\r\n * @return The active state of this timer.\r\n */\r\npublic boolean isRunning() {\r\n    return _running;\r\n}'),(662,'jbInit()','de.java_chess.javaChess.renderer2d.GameTimerPanel.jbInit()','90','GameTimerPanel','/**\r\n * Construction a la JBuilder to be able to use JBuilder designer\r\n *\r\n * @throws Exception\r\n * 		\r\n */\r\nprivate void jbInit() throws Exception {\r\n    _white = new TimerPanel(false);\r\n    _white.addActionListener(this);\r\n    _black = new TimerPanel(false);\r\n    _black.addActionListener(this);\r\n    _white.setBackground(Color.white);\r\n    _white.alignText();\r\n    _black.setBackground(Color.white);\r\n    _black.alignText();\r\n    _white.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    _black.setBorder(BorderFactory.createLineBorder(Color.black));\r\n    this.jlWhite.setText(\"White: \");\r\n    this.jlWhite.setForeground(Color.white);\r\n    jlWhite.setHorizontalAlignment(SwingConstants.CENTER);\r\n    this.jlBlack.setText(\"Black: \");\r\n    this.jlBlack.setForeground(Color.black);\r\n    jlBlack.setHorizontalAlignment(SwingConstants.CENTER);\r\n    // Layout the entire timer.\r\n    setLayout(new GridLayout(1, 4));\r\n    // Add the timers with a label for each of them\r\n    this.add(jlWhite, null);\r\n    add(_white);\r\n    this.add(jlBlack, null);\r\n    add(_black);\r\n}'),(663,'notifyListeners(java.awt.event.ActionEvent)','de.java_chess.javaChess.renderer2d.GameTimerPanel.notifyListeners(java.awt.event.ActionEvent)','90','GameTimerPanel','/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * 		The action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}'),(664,'reset(int)','de.java_chess.javaChess.renderer2d.GameTimerPanel.reset(int)','90','GameTimerPanel','// Methods\r\n/**\r\n * Reset to a given time.\r\n *\r\n * @param time\r\n * 		The time to reset to.\r\n */\r\npublic void reset(int time) {\r\n    stop();// Stop the timer.\r\n\r\n    setCountdown(time);\r\n    setNoClockRunning();\r\n}'),(665,'setBlackClockRunning()','de.java_chess.javaChess.renderer2d.GameTimerPanel.setBlackClockRunning()','90','GameTimerPanel','public void setBlackClockRunning() {\r\n    _white.setBackground(Color.lightGray);\r\n    _black.setBackground(Color.white);\r\n}'),(666,'setCountdown(int)','de.java_chess.javaChess.renderer2d.GameTimerPanel.setCountdown(int)','90','GameTimerPanel','/**\r\n * Set the remaining time for each timer.\r\n *\r\n * @param time\r\n * 		The remaining time for each time.\r\n */\r\npublic void setCountdown(int time) {\r\n    _white.setCountdown(time);\r\n    _black.setCountdown(time);\r\n}'),(667,'setNoClockRunning()','de.java_chess.javaChess.renderer2d.GameTimerPanel.setNoClockRunning()','90','GameTimerPanel','/**\r\n * Set both timers inactive.\r\n */\r\npublic void setNoClockRunning() {\r\n    _white.setBackground(Color.white);\r\n    _black.setBackground(Color.white);\r\n}'),(668,'setRunning(boolean)','de.java_chess.javaChess.renderer2d.GameTimerPanel.setRunning(boolean)','90','GameTimerPanel','/**\r\n * Set the new running state of the timer.\r\n *\r\n * @param active\r\n * 		The new state of the timer panel.\r\n */\r\npublic void setRunning(boolean active) {\r\n    _running = active;\r\n}'),(669,'setWhiteClockRunning()','de.java_chess.javaChess.renderer2d.GameTimerPanel.setWhiteClockRunning()','90','GameTimerPanel','public void setWhiteClockRunning() {\r\n    _white.setBackground(Color.white);\r\n    _black.setBackground(Color.lightGray);\r\n}'),(670,'start()','de.java_chess.javaChess.renderer2d.GameTimerPanel.start()','90','GameTimerPanel','/**\r\n * Start the game\r\n */\r\npublic void start() {\r\n    _black.start();\r\n    _whiteActive = false;\r\n    setBlackClockRunning();\r\n    setRunning(true);\r\n}'),(671,'stop()','de.java_chess.javaChess.renderer2d.GameTimerPanel.stop()','90','GameTimerPanel','/**\r\n * Stop the entire timer.\r\n */\r\npublic void stop() {\r\n    _white.stop();\r\n    _black.stop();\r\n    setRunning(false);\r\n}'),(672,'toggle()','de.java_chess.javaChess.renderer2d.GameTimerPanel.toggle()','90','GameTimerPanel','/**\r\n * Toggle the timer for one player to the other.\r\n */\r\npublic void toggle() {\r\n    if (_whiteActive) {\r\n        setBlackClockRunning();\r\n        _white.stop();\r\n        _black.start();\r\n    } else {\r\n        setWhiteClockRunning();\r\n        _black.stop();\r\n        _white.start();\r\n    }\r\n    _whiteActive = !(_whiteActive);\r\n}'),(673,'-init-()','de.java_chess.javaChess.renderer2d.NavigationPanel.-init-()','91','NavigationPanel','/**\r\n * Standardconstructor\r\n */\r\npublic NavigationPanel() {\r\n    super();\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(674,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.renderer2d.NavigationPanel.actionPerformed(java.awt.event.ActionEvent)','91','NavigationPanel','/**\r\n * React on mouseclick\r\n */\r\npublic void actionPerformed(ActionEvent ae) {\r\n    if (ae.getSource().equals(jbStart))\r\n        moveToStart();\r\n\r\n    if (ae.getSource().equals(jbBack))\r\n        moveOnePlyBack();\r\n\r\n    if (ae.getSource().equals(jbForward))\r\n        moveOnePlyForward();\r\n\r\n    if (ae.getSource().equals(jbEnd))\r\n        moveToEnd();\r\n\r\n}'),(675,'jbInit()','de.java_chess.javaChess.renderer2d.NavigationPanel.jbInit()','91','NavigationPanel','/**\r\n * Construction a la JBuilder to be able to use the JBuilder designer\r\n *\r\n * @throws Exception\r\n * 		\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagNavigation);\r\n    jbBack.setBackground(Color.white);\r\n    jbBack.setToolTipText(\"one ply back\");\r\n    jbStart.setBackground(Color.white);\r\n    jbStart.setToolTipText(\"to start position\");\r\n    jbForward.setBackground(Color.white);\r\n    jbForward.setToolTipText(\"one ply forward\");\r\n    jbEnd.setBackground(Color.white);\r\n    jbEnd.setToolTipText(\"to end position\");\r\n    URL urlBack = getClass().getResource(\"images/back03.gif\");\r\n    Image imBack = Toolkit.getDefaultToolkit().getImage(urlBack);\r\n    jbBack.setIcon(new ImageIcon(imBack));\r\n    URL urlStart = getClass().getResource(\"images/start03.gif\");\r\n    Image imStart = Toolkit.getDefaultToolkit().getImage(urlStart);\r\n    jbStart.setIcon(new ImageIcon(imStart));\r\n    URL urlForward = getClass().getResource(\"images/forward03.gif\");\r\n    Image imForward = Toolkit.getDefaultToolkit().getImage(urlForward);\r\n    jbForward.setIcon(new ImageIcon(imForward));\r\n    URL urlEnd = getClass().getResource(\"images/end03.gif\");\r\n    Image imEnd = Toolkit.getDefaultToolkit().getImage(urlEnd);\r\n    jbEnd.setIcon(new ImageIcon(imEnd));\r\n    // jbBack.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/back02.gif\"))));\r\n    // jbStart.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/start02.gif\"))));\r\n    // jbForward.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/forward02.gif\"))));\r\n    // jbEnd.setIcon( new ImageIcon( Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/end02.gif\"))));\r\n    jbBack.addActionListener(this);\r\n    jbStart.addActionListener(this);\r\n    jbForward.addActionListener(this);\r\n    jbEnd.addActionListener(this);\r\n    this.add(jbStart, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jbBack, new GridBagConstraints(1, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jbForward, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jbEnd, new GridBagConstraints(3, 0, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n}'),(676,'moveOnePlyBack()','de.java_chess.javaChess.renderer2d.NavigationPanel.moveOnePlyBack()','91','NavigationPanel','/**\r\n * Moves one half move back in the game history\r\n */\r\nprivate void moveOnePlyBack() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    // System.out.println( \"Einen Halbzug zur�ck\" );\r\n}'),(677,'moveOnePlyForward()','de.java_chess.javaChess.renderer2d.NavigationPanel.moveOnePlyForward()','91','NavigationPanel','/**\r\n * Moves one half move forward in the game\r\n */\r\nprivate void moveOnePlyForward() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    System.out.println(\"Einen Halbzug vor\");\r\n}'),(678,'moveToEnd()','de.java_chess.javaChess.renderer2d.NavigationPanel.moveToEnd()','91','NavigationPanel','/**\r\n * Moves to the end position of the game\r\n */\r\nprivate void moveToEnd() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    System.out.println(\"Zum Partieende\");\r\n}'),(679,'moveToStart()','de.java_chess.javaChess.renderer2d.NavigationPanel.moveToStart()','91','NavigationPanel','/**\r\n * Moves to the beginning of the game\r\n */\r\nprivate void moveToStart() {\r\n    /**\r\n     *\r\n     *\r\n     * @unknown still to implement\r\n     */\r\n    // System.out.println( \"Zum Partieanfang\" );\r\n}'),(680,'-init-(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.renderer2d.NotationPanel.-init-(de.java_chess.javaChess.notation.GameNotation)','92','NotationPanel','/**\r\n * Standardconstructor\r\n */\r\npublic NotationPanel(GameNotation gameNotation) {\r\n    super();\r\n    // Store the game notation in this instance.\r\n    setGameNotation(gameNotation);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(681,'actionPerformed(java.awt.event.ActionEvent)','de.java_chess.javaChess.renderer2d.NotationPanel.actionPerformed(java.awt.event.ActionEvent)','92','NotationPanel','public void actionPerformed(ActionEvent e) {\r\n    boolean bWhiteOrBlack = true;\r\n    PlayerDialog playerDialog = null;\r\n    if (e.getSource().equals(jbWhite)) {\r\n        playerDialog = new PlayerDialog(1, getWhitePlayerName());\r\n        bWhiteOrBlack = true;\r\n    } else\r\n        if (e.getSource().equals(jbBlack)) {\r\n            playerDialog = new PlayerDialog(2, getBlackPlayerName());\r\n            bWhiteOrBlack = false;\r\n        }\r\n\r\n    if (playerDialog != null) {\r\n        Tools.setDialogToCenter(playerDialog);\r\n        playerDialog.show();\r\n        if (bWhiteOrBlack == true) {\r\n            jbWhite.setText(playerDialog.getNewName());\r\n        } else {\r\n            jbBlack.setText(playerDialog.getNewName());\r\n        }\r\n    }\r\n}'),(682,'getBlackPlayerName()','de.java_chess.javaChess.renderer2d.NotationPanel.getBlackPlayerName()','92','NotationPanel','/**\r\n * Returns the black players name\r\n *\r\n * @return The String for the black player\r\n */\r\npublic String getBlackPlayerName() {\r\n    return this.jbBlack.getText();\r\n}'),(683,'getWhitePlayerName()','de.java_chess.javaChess.renderer2d.NotationPanel.getWhitePlayerName()','92','NotationPanel','/**\r\n * Returns the white players name\r\n *\r\n * @return The String for the white player\r\n */\r\npublic String getWhitePlayerName() {\r\n    return this.jbWhite.getText();\r\n}'),(684,'jbInit()','de.java_chess.javaChess.renderer2d.NotationPanel.jbInit()','92','NotationPanel','/**\r\n * Construction a la JBuilder to be able to use JBuilder designer\r\n *\r\n * @throws Exception\r\n * 		\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagText);\r\n    this.jtNotation.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.jtNotation.setEditable(false);\r\n    this.jtNotation.setLineWrap(true);\r\n    this.jtNotation.setWrapStyleWord(true);\r\n    this.jScrollPane = new JScrollPane(this.jtNotation);\r\n    this.jlHeadline = new JLabel(\"Notation and game details:\");\r\n    jlHeadline.setFont(new Font(\"Dialog\", 1, 12));\r\n    jpPlayers.setLayout(gridBagLayout1);\r\n    jlWhite.setText(\"White:\");\r\n    try {\r\n        // Get the account of the user.\r\n        String username = System.getProperty(\"user.name\");\r\n        // Capitalize the name.\r\n        username = (Character.toUpperCase(username.charAt(0))) + (username.substring(1));\r\n        // Use it as the default player name.\r\n        setWhitePlayerName(username);\r\n    } catch (Exception e) {\r\n        setWhitePlayerName(\"white player name\");\r\n    }\r\n    // jbWhite.setText(\"white player name\");\r\n    jbWhite.setBackground(Color.white);\r\n    jbWhite.setForeground(Color.black);\r\n    jbWhite.setFocusPainted(false);\r\n    jbWhite.addActionListener(this);\r\n    jlBlack.setText(\"Black:\");\r\n    // jbBlack.setText(\"black player name\");\r\n    setBlackPlayerName(\"Java-Chess\");\r\n    jbBlack.setBackground(Color.black);\r\n    jbBlack.setForeground(Color.white);\r\n    jbBlack.setFocusPainted(false);\r\n    jbBlack.addActionListener(this);\r\n    this.add(jScrollPane, new GridBagConstraints(0, 2, 1, 1, 1.0, 1.0, GridBagConstraints.NORTHWEST, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jlHeadline, new GridBagConstraints(0, 0, 1, 1, 1.0, 0.0, GridBagConstraints.NORTHWEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 0));\r\n    this.add(jpPlayers, new GridBagConstraints(0, 1, 1, 1, 0.0, 0.0, GridBagConstraints.CENTER, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    jpPlayers.add(jlWhite, new GridBagConstraints(0, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 0, 0, 0), 0, 4));\r\n    jpPlayers.add(jbWhite, new GridBagConstraints(1, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 5, 0, 5), 0, 0));\r\n    jpPlayers.add(jlBlack, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.NONE, new Insets(0, 5, 0, 0), 0, 0));\r\n    jpPlayers.add(jbBlack, new GridBagConstraints(3, 0, 1, 1, 1.0, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 5, 0, 5), 0, 0));\r\n}'),(685,'modifyText(java.lang.String)','de.java_chess.javaChess.renderer2d.NotationPanel.modifyText(java.lang.String)','92','NotationPanel','/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * 		The text to add\r\n */\r\npublic void modifyText(String newText) {\r\n    String sCurrentText = this.jtNotation.getText();\r\n    if ((sCurrentText.equals(\"\")) == false) {\r\n        this.jtNotation.setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtNotation.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        this.jtNotation.setText(newText);\r\n    }\r\n}'),(686,'setBlackPlayerName(java.lang.String)','de.java_chess.javaChess.renderer2d.NotationPanel.setBlackPlayerName(java.lang.String)','92','NotationPanel','/**\r\n * Sets the black players name\r\n *\r\n * @param newName\r\n * 		The new string for the black player\r\n */\r\npublic void setBlackPlayerName(String newName) {\r\n    this.jbBlack.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, false);\r\n    }\r\n}'),(687,'setGameNotation(de.java_chess.javaChess.notation.GameNotation)','de.java_chess.javaChess.renderer2d.NotationPanel.setGameNotation(de.java_chess.javaChess.notation.GameNotation)','92','NotationPanel','/**\r\n * Set a new notation object.\r\n *\r\n * @param gameNotation\r\n * 		The new game notation.\r\n */\r\npublic void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}'),(688,'setText(java.lang.String)','de.java_chess.javaChess.renderer2d.NotationPanel.setText(java.lang.String)','92','NotationPanel','/**\r\n * Set a new notation.\r\n *\r\n * @param newNotation\r\n * 		The new notation.\r\n */\r\npublic void setText(String newNotation) {\r\n    this.jtNotation.setText(newNotation);\r\n}'),(689,'setWhitePlayerName(java.lang.String)','de.java_chess.javaChess.renderer2d.NotationPanel.setWhitePlayerName(java.lang.String)','92','NotationPanel','/**\r\n * Sets the white players name\r\n *\r\n * @param newName\r\n * 		The new string for the white player\r\n */\r\npublic void setWhitePlayerName(String newName) {\r\n    this.jbWhite.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, true);\r\n    }\r\n}'),(690,'-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)','de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)','93','PieceRenderer','// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * 		The color of the piece.\r\n * @param piece\r\n * 		The type of the piece.\r\n * @param set\r\n * 		The set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}'),(691,'-init-(de.java_chess.javaChess.board.Board)','de.java_chess.javaChess.renderer2d.PiecesLayer.-init-(de.java_chess.javaChess.board.Board)','94','PiecesLayer','PiecesLayer(Board board) {\r\n    super(new GridLayout(8, 8));\r\n    _set = new ChessSet(this);\r\n    _animationLayer = new AnimationLayer(this);\r\n    _board = board;\r\n    int _boardSize = 8 * (ChessBoardRenderer2D.getSquareSize());\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    setOpaque(false);\r\n    repaintBoard();\r\n}'),(692,'clearBoard()','de.java_chess.javaChess.renderer2d.PiecesLayer.clearBoard()','94','PiecesLayer','final void clearBoard() {\r\n    // Create a renderer for each chessboard square\r\n    Position pos = new PositionImpl(0);// Avoid to create new position instances for each square\r\n\r\n    for (int s = 0; s < 64; s++) {\r\n        pos.setSquareIndex(s);\r\n        _square[s] = new PositionRenderer();\r\n    }\r\n    // Remove all the squares, in case this is a reset and the pieces layer already contains the\r\n    // squares of an existing board.\r\n    removeAll();\r\n    // The order of the component adding is different then the order of the chessboard squares.\r\n    // _square[0] = square a1 of the chessboard, but the components are added from the left\r\n    // upper square (= a8)\r\n    for (int s = 63; s >= 0; s--) {\r\n        add(_square[((s & (~7)) + (7 - (s & 7)))]);\r\n    }\r\n    repaint();\r\n}'),(693,'doPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.renderer2d.PiecesLayer.doPly(de.java_chess.javaChess.ply.Ply)','94','PiecesLayer','/**\r\n * Render a ply.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    if (_animatedMoves) {\r\n        getAnimationLayer().animatePly(ply);\r\n        getAnimationLayer().start();\r\n        repaint();\r\n    } else {\r\n        // Check, if it was a castling\r\n        if (ply instanceof CastlingPly) {\r\n            int source = ply.getSource().getSquareIndex();\r\n            if (((CastlingPly) (ply)).isLeftCastling()) {\r\n                _square[(source - 2)].getPieceFrom(_square[source]);\r\n                _square[(source - 1)].getPieceFrom(_square[(source - 4)]);// Move the rook to the right\r\n\r\n            } else {\r\n                _square[(source + 2)].getPieceFrom(_square[source]);\r\n                _square[(source + 1)].getPieceFrom(_square[(source + 3)]);// Move the rook to the left\r\n\r\n            }\r\n        } else {\r\n            // If a pawn has just reached the last row\r\n            if (ply instanceof TransformationPly) {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // Now change the rendering to the new piece type.\r\n                _square[ply.getDestination().getSquareIndex()].setIcon(new ImageIcon(new PieceRenderer(((ply.getDestination().getSquareIndex()) < 8 ? Piece.BLACK : Piece.WHITE), ((TransformationPly) (ply)).getTypeAfterTransformation(), _set, this)));\r\n            } else {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // If its a en passant ply, remove the attacked pawn.\r\n                if (ply instanceof EnPassantPly) {\r\n                    _square[((EnPassantPly) (ply)).getAttackedPosition().getSquareIndex()].setIcon(null);\r\n                }\r\n            }\r\n        }\r\n        repaint();\r\n    }\r\n}'),(694,'getAnimationLayer()','de.java_chess.javaChess.renderer2d.PiecesLayer.getAnimationLayer()','94','PiecesLayer','/**\r\n * Get the current animation layer.\r\n *\r\n * @return The current animation layer.\r\n */\r\nfinal AnimationLayer getAnimationLayer() {\r\n    return _animationLayer;\r\n}'),(695,'getPositionRenderer(int)','de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)','94','PiecesLayer','/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * 		The index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}'),(696,'repaintBoard()','de.java_chess.javaChess.renderer2d.PiecesLayer.repaintBoard()','94','PiecesLayer','final void repaintBoard() {\r\n    // removeAll();\r\n    // Create a renderer for each chessboard square\r\n    Position pos = new PositionImpl(0);// Avoid to create new position instances for each square\r\n\r\n    for (int s = 0; s < 64; s++) {\r\n        pos.setSquareIndex(s);\r\n        Piece p = _board.getPiece(pos);\r\n        _square[s] = (p != null) ? new PositionRenderer(new PieceRenderer(p.getColor(), p.getType(), _set, this)) : new PositionRenderer();\r\n    }\r\n    // Remove all the squares, in case this is a reset and the pieces layer already contains the\r\n    // squares of an existing board.\r\n    removeAll();\r\n    // The order of the component adding is different then the order of the chessboard squares.\r\n    // _square[0] = square a1 of the chessboard, but the components are added from the left\r\n    // upper square (= a8)\r\n    for (int s = 63; s >= 0; s--) {\r\n        add(_square[((s & (~7)) + (7 - (s & 7)))]);\r\n    }\r\n    repaint();\r\n}'),(697,'-init-()','de.java_chess.javaChess.renderer2d.PositionRenderer.-init-()','95','PositionRenderer','// Instance variables.\r\n// Constructors\r\n/**\r\n * Create a new position rendering for a empty position.\r\n */\r\nPositionRenderer() {\r\n    super();// Create a empty JLabel instance.\r\n\r\n    // Even if we do not have to render an image yet, it might\r\n    // get added later, when a piece moves on this square.\r\n    setHorizontalAlignment(SwingConstants.CENTER);\r\n    setVerticalAlignment(SwingConstants.CENTER);\r\n}'),(698,'-init-(java.awt.Image)','de.java_chess.javaChess.renderer2d.PositionRenderer.-init-(java.awt.Image)','95','PositionRenderer','/**\r\n * Create a new position rendering with a given image of a piece.\r\n *\r\n * image The image for the rendering.\r\n */\r\nPositionRenderer(Image image) {\r\n    super(new ImageIcon(image));\r\n}'),(699,'getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)','de.java_chess.javaChess.renderer2d.PositionRenderer.getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)','95','PositionRenderer','// Methods\r\n/**\r\n * Move a piece from another position to this one.\r\n *\r\n * positionRenderer The position renderer for the source.\r\n */\r\nvoid getPieceFrom(PositionRenderer positionRenderer) {\r\n    setIcon(positionRenderer.getIcon());\r\n    positionRenderer.setIcon(null);\r\n}'),(700,'setIcon(javax.swing.ImageIcon)','de.java_chess.javaChess.renderer2d.PositionRenderer.setIcon(javax.swing.ImageIcon)','95','PositionRenderer','/**\r\n * Set a new icon and align it properly.\r\n *\r\n * @param icon\r\n * 		The new icon.\r\n */\r\npublic void setIcon(ImageIcon icon) {\r\n    super.setIcon(icon);\r\n    if (icon != null) {\r\n        invalidate();\r\n    } else {\r\n        revalidate();\r\n    }\r\n}'),(701,'-init-()','de.java_chess.javaChess.renderer2d.StatusPanel.-init-()','96','StatusPanel','public StatusPanel() {\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(702,'-init-(java.lang.String)','de.java_chess.javaChess.renderer2d.StatusPanel.-init-(java.lang.String)','96','StatusPanel','public StatusPanel(String sVersionNumber) {\r\n    this.sVersion = sVersionNumber;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(703,'jbInit()','de.java_chess.javaChess.renderer2d.StatusPanel.jbInit()','96','StatusPanel','/**\r\n * Die GUI nach Nomenklatur des JBuilder\r\n *\r\n * @throws Exception\r\n * 		\r\n */\r\nprivate void jbInit() throws Exception {\r\n    this.setLayout(gridBagLayout);\r\n    jlAction.setBorder(BorderFactory.createLoweredBevelBorder());\r\n    this.jlStatus.setBorder(BorderFactory.createBevelBorder(BevelBorder.LOWERED, Color.white, Color.white, new Color(148, 145, 140), new Color(103, 101, 98)));\r\n    this.jlStatus.setText(\" Your turn! \");\r\n    this.jlStatus.setForeground(Color.black);\r\n    this.jlStatus.setFont(this.textFont);\r\n    this.jlAction.setText(\"Placeholder for action(s) in progress\");\r\n    this.jlAction.setFont(this.textFont);\r\n    this.jlAction.setForeground(Color.black);\r\n    this.jlVersion.setBorder(BorderFactory.createLoweredBevelBorder());\r\n    this.jlVersion.setText((\"Version: \" + (this.sVersion)));\r\n    this.jlVersion.setFont(this.textFont);\r\n    this.jlVersion.setForeground(Color.black);\r\n    add(jlAction, new GridBagConstraints(0, 0, 1, 1, 0.6, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    add(jlStatus, new GridBagConstraints(1, 0, 1, 1, 0.2, 0.0, GridBagConstraints.WEST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    add(jlVersion, new GridBagConstraints(2, 0, 1, 1, 0.0, 0.0, GridBagConstraints.EAST, GridBagConstraints.HORIZONTAL, new Insets(0, 0, 0, 0), 0, 0));\r\n    setBackground(Color.lightGray);\r\n}'),(704,'setActionText(java.lang.String)','de.java_chess.javaChess.renderer2d.StatusPanel.setActionText(java.lang.String)','96','StatusPanel','public void setActionText(String newActionText) {\r\n    this.jlAction.setText(newActionText);\r\n}'),(705,'setStatusText(java.lang.String)','de.java_chess.javaChess.renderer2d.StatusPanel.setStatusText(java.lang.String)','96','StatusPanel','public void setStatusText(String newStatusText) {\r\n    this.jlStatus.setText(newStatusText);\r\n}'),(706,'setVersionInfo(java.lang.String)','de.java_chess.javaChess.renderer2d.StatusPanel.setVersionInfo(java.lang.String)','96','StatusPanel','public void setVersionInfo(String newVersionText) {\r\n    this.jlVersion.setText(newVersionText);\r\n}'),(707,'-init-(boolean)','de.java_chess.javaChess.renderer2d.TimerPanel.-init-(boolean)','97','TimerPanel','// Constructors\r\n/**\r\n * Create a new timer panel.\r\n *\r\n * @param countdown\r\n * 		Flag to indicate, if we count downwards.\r\n */\r\npublic TimerPanel(boolean countdown) {\r\n    setCountingDirection(countdown);\r\n    _actionListeners = new ArrayList();\r\n    _display = new JLabel(\"0:00:00\", JLabel.RIGHT);\r\n    _display.setPreferredSize(new Dimension(TimerPanel._displayWidth, TimerPanel._displayHeight));\r\n    _display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    add(_display);\r\n}'),(708,'addActionListener(java.awt.event.ActionListener)','de.java_chess.javaChess.renderer2d.TimerPanel.addActionListener(java.awt.event.ActionListener)','97','TimerPanel','// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}'),(709,'alignText()','de.java_chess.javaChess.renderer2d.TimerPanel.alignText()','97','TimerPanel','public void alignText() {\r\n    this._display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    this._display.setHorizontalAlignment(SwingConstants.CENTER);\r\n}'),(710,'display(long)','de.java_chess.javaChess.renderer2d.TimerPanel.display(long)','97','TimerPanel','/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * 		The current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    if (!(isCountdown())) {\r\n        time = (_time) - time;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, TimerPanel._displayWidth, TimerPanel._displayHeight);\r\n}'),(711,'getRemainingTime()','de.java_chess.javaChess.renderer2d.TimerPanel.getRemainingTime()','97','TimerPanel','/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}'),(712,'isCountdown()','de.java_chess.javaChess.renderer2d.TimerPanel.isCountdown()','97','TimerPanel','/**\r\n * Check, if this timer counts downwards.\r\n *\r\n * @return true, if the counter counts downwards.\r\n */\r\nprivate final boolean isCountdown() {\r\n    return _countdown;\r\n}'),(713,'notifyListeners(java.awt.event.ActionEvent)','de.java_chess.javaChess.renderer2d.TimerPanel.notifyListeners(java.awt.event.ActionEvent)','97','TimerPanel','/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * 		The action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}'),(714,'run()','de.java_chess.javaChess.renderer2d.TimerPanel.run()','97','TimerPanel','/**\r\n * The actual thread method.\r\n */\r\npublic void run() {\r\n    long startTime = System.currentTimeMillis();// The time when this run started.\r\n\r\n    long runningTime;\r\n    // The length of this run.\r\n    try {\r\n        // While theres still time left and noone stopped the thread.\r\n        do {\r\n            Thread.sleep(100);// Wait 1/10 of a second.\r\n\r\n            runningTime = (System.currentTimeMillis()) - startTime;\r\n            display(((_remainingTime) - runningTime));// decrease the time by a second and display it.\r\n\r\n        } while (((_remainingTime) >= runningTime) && ((Thread.currentThread()) == (_timerThread)) );\r\n        _remainingTime -= runningTime;// Substract the length of this thinking time.\r\n\r\n        // Now notify all the action listeners, that the timer has stopped.\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((_remainingTime) < 0L ? \"timeout\" : \"interrupted\")));\r\n    } catch (InterruptedException ignored) {\r\n    }\r\n}'),(715,'setCountdown(int)','de.java_chess.javaChess.renderer2d.TimerPanel.setCountdown(int)','97','TimerPanel','/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * 		The length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}'),(716,'setCountingDirection(boolean)','de.java_chess.javaChess.renderer2d.TimerPanel.setCountingDirection(boolean)','97','TimerPanel','/**\r\n * Set the counting direction.\r\n *\r\n * @param countdown\r\n * 		Flag to indicate, if we want a countdown.\r\n */\r\nprivate final void setCountingDirection(boolean countdown) {\r\n    _countdown = countdown;\r\n}'),(717,'start()','de.java_chess.javaChess.renderer2d.TimerPanel.start()','97','TimerPanel','/**\r\n * Start the timer.\r\n */\r\npublic void start() {\r\n    if ((_time) > 0L) {\r\n        if ((_timerThread) == null) {\r\n            _timerThread = new Thread(this);\r\n            _timerThread.start();\r\n        }\r\n    }\r\n}'),(718,'stop()','de.java_chess.javaChess.renderer2d.TimerPanel.stop()','97','TimerPanel','/**\r\n * Stop the timer.\r\n */\r\npublic void stop() {\r\n    // If there is a running thread.\r\n    if ((_timerThread) != null) {\r\n        Thread timerThread = _timerThread;// Copy it.\r\n\r\n        _timerThread = null;\r\n        // Signal to stop the thread.\r\n        try {\r\n            timerThread.join();// And wait for the thread to end.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n}'),(719,'-init-()','de.java_chess.javaChess.test.JavaChessTest.-init-()','98','JavaChessTest','JavaChessTest() {\r\n}'),(720,'suite()','de.java_chess.javaChess.test.JavaChessTest.suite()','98','JavaChessTest','// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Create the main test suite.\r\n *\r\n * @return The main test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite.\r\n    TestSuite suite = new TestSuite();\r\n    // Add the test suite for the engine.\r\n    suite.addTest(ChessEngineTest.suite());\r\n    return suite;\r\n}'),(721,'addActionListener(java.awt.event.ActionListener)','de.java_chess.javaChess.timer.GameTimer.addActionListener(java.awt.event.ActionListener)','99','GameTimer','/**\r\n * Add a action listener to the timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\nvoid addActionListener(ActionListener listener);'),(722,'isRunning()','de.java_chess.javaChess.timer.GameTimer.isRunning()','99','GameTimer','/**\r\n * Check if the timer is actually running.\r\n *\r\n * @return true, if the timer is active, false otherwise.\r\n */\r\nboolean isRunning();'),(723,'start()','de.java_chess.javaChess.timer.GameTimer.start()','99','GameTimer','// Methods\r\n/**\r\n * Start the entire timer.\r\n */\r\nvoid start();'),(724,'stop()','de.java_chess.javaChess.timer.GameTimer.stop()','99','GameTimer','/**\r\n * Stop the entire timer.\r\n */\r\nvoid stop();'),(725,'toggle()','de.java_chess.javaChess.timer.GameTimer.toggle()','99','GameTimer','/**\r\n * Toggle from one player to the other.\r\n */\r\nvoid toggle();'),(726,'-init-(java.lang.Object[],int)','de.java_chess.javaChess.util.ArrayStackIterator.-init-(java.lang.Object[],int)','100','ArrayStackIterator','// Constructors\r\n/**\r\n * Create a new iterator instance.\r\n *\r\n * @param items\r\n * 		The array with the items.\r\n * @param nItems\r\n * 		The number of items (since the array is most likely longer).\r\n */\r\npublic ArrayStackIterator(Object[] items, int nItems) {\r\n    _items = items;\r\n    _nItems = nItems;\r\n    _curElement = 0;\r\n}'),(727,'hasNext()','de.java_chess.javaChess.util.ArrayStackIterator.hasNext()','100','ArrayStackIterator','// Methods\r\n/**\r\n * Check, if there are more elements to iterate over.\r\n *\r\n * @return true, if there are more elements.\r\n */\r\npublic final boolean hasNext() {\r\n    return (_curElement) < (_nItems);\r\n}'),(728,'next()','de.java_chess.javaChess.util.ArrayStackIterator.next()','100','ArrayStackIterator','/**\r\n * Get the next elements from the collection.\r\n *\r\n * @return The next element from the collection.\r\n */\r\npublic final Object next() {\r\n    return _items[((_curElement)++)];\r\n}'),(729,'remove()','de.java_chess.javaChess.util.ArrayStackIterator.remove()','100','ArrayStackIterator','/**\r\n * Remove the returned object (just a dummy in this case).\r\n */\r\npublic final void remove() {\r\n    // Do nothing...\r\n}'),(730,'-init-()','de.java_chess.javaChess.util.ResourceLoader.-init-()','101','ResourceLoader','// Constructors\r\n/**\r\n * Create a new loader instance.\r\n */\r\nprivate ResourceLoader() {\r\n    _locations = new ArrayList();\r\n}'),(731,'addLocation(java.lang.String)','de.java_chess.javaChess.util.ResourceLoader.addLocation(java.lang.String)','101','ResourceLoader','/**\r\n * Add a new location to load resources from.\r\n *\r\n * @param location\r\n * 		The location to use.\r\n */\r\npublic final void addLocation(String location) {\r\n    if (!(location.endsWith(\"/\"))) {\r\n        location += \"/\";\r\n    }\r\n    _locations.add(location);\r\n}'),(732,'getInstance()','de.java_chess.javaChess.util.ResourceLoader.getInstance()','101','ResourceLoader','// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final ResourceLoader getInstance() {\r\n    if ((ResourceLoader._instance) == null) {\r\n        ResourceLoader._instance = new ResourceLoader();\r\n    }\r\n    return ResourceLoader._instance;\r\n}'),(733,'loadImage(java.lang.String)','de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)','101','ResourceLoader','/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}'),(734,'-init-(int,int)','de.java_chess.javaChess.util.StringTextDocument.-init-(int,int)','102','StringTextDocument','/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * 		The number of allowed character to enter in the JTextField\r\n */\r\npublic StringTextDocument(int type, int characterCount) {\r\n    super();\r\n    iCharacterCount = characterCount;\r\n    iType = type;\r\n}'),(735,'canBecomeValid(java.lang.String)','de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)','102','StringTextDocument','/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * 		The string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}'),(736,'insertString(int,java.lang.String,javax.swing.text.AttributeSet)','de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)','102','StringTextDocument','/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * 		The number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * 		Flag whether the string to enter has to be parsed for\r\n * 		numbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}'),(737,'isValid(java.lang.String)','de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)','102','StringTextDocument','/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * 		The string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}'),(738,'isValidLine(char)','de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)','102','StringTextDocument','/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * 		The character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}'),(739,'isValidSquare(java.lang.String,boolean)','de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)','102','StringTextDocument','/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(740,'-init-()','de.java_chess.javaChess.util.Tools.-init-()','103','Tools','public Tools() {\r\n}'),(741,'setDialogToCenter(javax.swing.JDialog)','de.java_chess.javaChess.util.Tools.setDialogToCenter(javax.swing.JDialog)','103','Tools','/**\r\n * Sets the Dialog to the center of the screen\r\n *\r\n * @param dialog\r\n * 		The dialog which is to be centered on the screen\r\n */\r\npublic static void setDialogToCenter(JDialog dialog) {\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    Dimension dialogSize = dialog.getSize();\r\n    dialog.setLocation((((screenSize.width) - (dialogSize.width)) / 2), (((screenSize.height) - (dialogSize.height)) / 2));\r\n}'),(742,'-init-()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.-init-()','104','UnsynchronizedArrayStack','// Constructors\r\n/**\r\n * Create a new stack instance.\r\n */\r\npublic UnsynchronizedArrayStack() {\r\n    this(30);\r\n}'),(743,'-init-(int)','de.java_chess.javaChess.util.UnsynchronizedArrayStack.-init-(int)','104','UnsynchronizedArrayStack','/**\r\n * Create a new stack instance with a given initial\r\n * capacity.\r\n *\r\n * @param capacity\r\n * 		The initial capacity.\r\n */\r\npublic UnsynchronizedArrayStack(int capacity) {\r\n    _nItems = 0;\r\n    _items = new Object[capacity];\r\n}'),(744,'clear()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.clear()','104','UnsynchronizedArrayStack','/**\r\n * Remove all the elements of the stack.\r\n */\r\npublic final void clear() {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        _items[i] = null;\r\n    }\r\n    _nItems = 0;\r\n}'),(745,'empty()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.empty()','104','UnsynchronizedArrayStack','// Methods\r\n/**\r\n * Test, if this stack is empty.\r\n *\r\n * @return true, if the stack is empty. False otherwise.\r\n */\r\npublic final boolean empty() {\r\n    return (_nItems) == 0;\r\n}'),(746,'increaseCapacity()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.increaseCapacity()','104','UnsynchronizedArrayStack','/**\r\n * Increase the capacity of the stack.\r\n */\r\nprivate final void increaseCapacity() {\r\n    // Create a new bigger array.\r\n    Object[] newStack = new Object[(_items.length) + (_incSize)];\r\n    // Copy the content of the old array to the new one.\r\n    System.arraycopy(_items, 0, newStack, 0, _nItems);\r\n    // Set the new array.\r\n    _items = newStack;\r\n}'),(747,'iterator()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.iterator()','104','UnsynchronizedArrayStack','/**\r\n * Get a iterator for the elements of this stack.\r\n *\r\n * @return A iterator for the elements of this stack.\r\n */\r\npublic final Iterator iterator() {\r\n    return new ArrayStackIterator(_items, _nItems);\r\n}'),(748,'peek()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.peek()','104','UnsynchronizedArrayStack','/**\r\n * Look at the object, that is at the top of the stack without removing it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object peek() {\r\n    return empty() ? null : _items[((_nItems) - 1)];\r\n}'),(749,'pop()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.pop()','104','UnsynchronizedArrayStack','/**\r\n * Remove the object at the top of the stack and return it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object pop() {\r\n    if (!(empty())) {\r\n        Object item = _items[(--(_nItems))];\r\n        _items[_nItems] = null;\r\n        return item;\r\n    }\r\n    return null;\r\n}'),(750,'push(java.lang.Object)','de.java_chess.javaChess.util.UnsynchronizedArrayStack.push(java.lang.Object)','104','UnsynchronizedArrayStack','/**\r\n * Push an item on the stack.\r\n *\r\n * @param item\r\n * 		The item to push on the stack.\r\n */\r\npublic final void push(Object item) {\r\n    try {\r\n        _items[_nItems] = item;\r\n        (_nItems)++;\r\n    } catch (ArrayIndexOutOfBoundsException ae) {\r\n        increaseCapacity();\r\n        push(item);\r\n    }\r\n}'),(751,'search(java.lang.Object)','de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)','104','UnsynchronizedArrayStack','/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}'),(752,'size()','de.java_chess.javaChess.util.UnsynchronizedArrayStack.size()','104','UnsynchronizedArrayStack','/**\r\n * Get the current number of elements on the stack.\r\n *\r\n * @param The\r\n * 		current size of the stack.\r\n */\r\npublic final int size() {\r\n    return _nItems;\r\n}'),(753,'getMovedPieces()','de.java_chess.javaChess.game.GameImpl$GameStatus.getMovedPieces()','null','null','/**\r\n * Get the bitmask for the moved pieces.\r\n *\r\n * @return The bitmask for the moved pieces.\r\n */\r\nprivate final long getMovedPieces() {\r\n    return _movedPieces;\r\n}'),(754,'getPly()','de.java_chess.javaChess.game.GameImpl$GameStatus.getPly()','null','null','// Methods\r\n/**\r\n * Get the ply, that lead to this game status.\r\n *\r\n * @return The ply, that lead to this game status.\r\n */\r\nfinal Ply getPly() {\r\n    return _ply;\r\n}'),(755,'hasBeenMoved(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)','null','null','/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}'),(756,'setMoved(de.java_chess.javaChess.position.Position)','de.java_chess.javaChess.game.GameImpl$GameStatus.setMoved(de.java_chess.javaChess.position.Position)','null','null','/**\r\n * Mark a piece moved from its initial position.\r\n *\r\n * @param position\r\n * 		The position of the moved piece.\r\n */\r\nprivate final void setMoved(Position position) {\r\n    _movedPieces |= 1L << (position.getSquareIndex());\r\n}'),(757,'setMovedPieces(long)','de.java_chess.javaChess.game.GameImpl$GameStatus.setMovedPieces(long)','null','null','/**\r\n * Set the bitmask for the moved pieces.\r\n *\r\n * @param bitmask\r\n * 		The new bitmask for the moved pieces.\r\n */\r\nprivate final void setMovedPieces(long bitmask) {\r\n    _movedPieces = bitmask;\r\n}'),(758,'setPly(de.java_chess.javaChess.ply.Ply)','de.java_chess.javaChess.game.GameImpl$GameStatus.setPly(de.java_chess.javaChess.ply.Ply)','null','null','/**\r\n * Set the ply, that lead to this game status.\r\n *\r\n * @param ply\r\n * 		The ply, that lead to this game status.\r\n */\r\nfinal void setPly(Ply ply) {\r\n    _ply = ply;\r\n}');
/*!40000 ALTER TABLE `methods` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-03-09 17:04:46
