-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: databasechess
-- ------------------------------------------------------
-- Server version	8.0.11

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `parameters`
--

DROP TABLE IF EXISTS `parameters`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `parameters` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `parametername` varchar(200) DEFAULT NULL,
  `parametertype` varchar(200) DEFAULT NULL,
  `parameterclass` int(11) DEFAULT NULL,
  `classid` int(11) DEFAULT NULL,
  `classname` varchar(200) DEFAULT NULL,
  `methodid` int(11) DEFAULT NULL,
  `methodname` varchar(300) DEFAULT NULL,
  `isreturn` tinyint(4) NOT NULL,
  `sourcecode` longtext NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=180 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `parameters`
--

LOCK TABLES `parameters` WRITE;
/*!40000 ALTER TABLE `parameters` DISABLE KEYS */;
INSERT INTO `parameters` VALUES (1,'Game game','de.java_chess.javaChess.game.Game',50,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(2,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(3,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(4,'Board board','de.java_chess.javaChess.board.Board',13,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(5,'GameTimer timer','de.java_chess.javaChess.timer.GameTimer',99,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(6,'Game game','de.java_chess.javaChess.game.Game',50,1,'de.java_chess.javaChess.GameController',16,'de.java_chess.javaChess.GameController.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(7,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,1,'de.java_chess.javaChess.GameController',17,'de.java_chess.javaChess.GameController.setGameNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set the current game notation.\r\n *\r\n * @param gameNotation\r\n * 		The new game notation.\r\n */\r\npublic final void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}'),(8,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,1,'de.java_chess.javaChess.GameController',15,'de.java_chess.javaChess.GameController.setEngine(de.java_chess.javaChess.engine.ChessEngine)',0,'/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * 		The new engine.\r\n */\r\nfinal void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}'),(9,'Board board','de.java_chess.javaChess.board.Board',13,1,'de.java_chess.javaChess.GameController',14,'de.java_chess.javaChess.GameController.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nfinal void setBoard(Board board) {\r\n    _board = board;\r\n}'),(10,'ChessBoardRenderer renderer','de.java_chess.javaChess.renderer.ChessBoardRenderer',82,1,'de.java_chess.javaChess.GameController',19,'de.java_chess.javaChess.GameController.setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)',0,'/**\r\n * Set a new renderer.\r\n *\r\n * @param renderer\r\n * 		The new renderer.\r\n */\r\nfinal void setRenderer(ChessBoardRenderer renderer) {\r\n    _renderer = renderer;\r\n}'),(11,'GameTimer timer','de.java_chess.javaChess.timer.GameTimer',99,1,'de.java_chess.javaChess.GameController',18,'de.java_chess.javaChess.GameController.setGameTimer(de.java_chess.javaChess.timer.GameTimer)',0,'/**\r\n * Set a new game timer.\r\n *\r\n * @param timer\r\n * 		The new game timer.\r\n */\r\nfinal void setGameTimer(GameTimer timer) {\r\n    _gameTimer = timer;\r\n    timer.addActionListener(this);\r\n}'),(12,'Ply ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',23,'de.java_chess.javaChess.GameController.userPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * The user moved a piece.\r\n *\r\n * @param ply\r\n * 		The ply of the user.\r\n */\r\npublic final void userPly(Ply ply) {\r\n    // Before any user ply can be applied, we have to stop\r\n    // the permanent brain, so the engine is free to process\r\n    // the user ply.\r\n    getEngine().stopPermanentBrain();\r\n    // plyInterpretation\r\n    ply = convertUserPly(ply);\r\n    // Check if the user has the right to move a piece\r\n    // and made a valid move.\r\n    if ((_moveRight) != (_computerIsWhite)) {\r\n        if ((((_gameState) != (GameState.CHECKMATE)) && ((_gameState) != (GameState.DRAW))) && ((_gameState) != (GameState.TIMEOUT))) {\r\n            if (getEngine().validateUserPly(ply)) {\r\n                doPly(ply);// Ok => move the piece.\r\n\r\n            } else {\r\n                // The user had to right to move or made an invalid move.\r\n                signalUserInputError(\"invalid move\");\r\n            }\r\n        } else {\r\n            signalUserInputError(\"game is already over\");\r\n        }\r\n    } else {\r\n        signalUserInputError(\"user is not about to move\");\r\n    }\r\n}'),(13,'Ply ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(14,'de.java_chess.javaChess.ply.Ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(15,'Ply ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',5,'de.java_chess.javaChess.GameController.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to do.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    // If the game is over, stop here.\r\n    if ((_gameState) == (GameState.TIMEOUT)) {\r\n        return;\r\n    }\r\n    // Store the ply notation to set the check flags a bit later, since they are computed in the gameOver()\r\n    // call in the move right toggle.\r\n    PlyNotation plyNotation = new PlyNotationImpl(ply, getBoard().getPiece(ply.getSource()));\r\n    getGame().doPly(ply);\r\n    getBoard().doPly(ply);\r\n    getRenderer().doPly(ply);\r\n    // Now try to get some info on the current game state.\r\n    boolean gameOver = gameOver((!(_moveRight)));\r\n    // Set check info for this ply.\r\n    if ((_gameState) == (GameState.CHECKMATE)) {\r\n        plyNotation.setCheckMate(true);\r\n    } else {\r\n        if ((_gameState) == (GameState.CHECK)) {\r\n            plyNotation.setCheck(true);\r\n        }\r\n    }\r\n    // Add the ply to the notation.\r\n    getGameNotation().addPly(plyNotation);\r\n    if (gameOver) {\r\n        getGameTimer().stop();// The game has ended.\r\n\r\n        if ((_gameState) == (GameState.DRAW)) {\r\n            signalGameOver(\"Draw! Use File -> Reset to play again!\");\r\n        } else {\r\n            signalGameOver(((_moveRight) == (_computerIsWhite) ? \"Checkmate! I win! :-)\" : \"Checkmate! I lose... :-(\"));\r\n        }\r\n    } else {\r\n        toggleMoveRight();\r\n    }\r\n}'),(16,'JavaChessAction action','de.java_chess.javaChess.action.JavaChessAction',6,3,'de.java_chess.javaChess.JavaChess',29,'de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)',0,'/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * 		The action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}'),(17,'ChessEngineImpl engine','de.java_chess.javaChess.engine.ChessEngineImpl',24,3,'de.java_chess.javaChess.JavaChess',26,'de.java_chess.javaChess.JavaChess.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)',0,'public void engineStatusChanged(ChessEngineImpl engine) {\r\n    if ((this.jpStatus) != null) {\r\n        this.jpStatus.setActionText(engine.getStatusDisplayString());\r\n    }\r\n}'),(18,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,9,'de.java_chess.javaChess.action.SaveGameAction',49,'de.java_chess.javaChess.action.SaveGameAction.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * 		The game notation.\r\n */\r\npublic SaveGameAction(GameNotation gameNotation) {\r\n    super(\"Save game\");\r\n    _gameNotation = gameNotation;\r\n}'),(19,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,9,'de.java_chess.javaChess.action.SaveGameAction',50,'de.java_chess.javaChess.action.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * 		The name of the action.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}'),(20,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,10,'de.java_chess.javaChess.action.SaveGameAsAction',53,'de.java_chess.javaChess.action.SaveGameAsAction.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\npublic SaveGameAsAction(GameNotation gameNotation) {\r\n    super(\"Save game as...\", gameNotation);\r\n    _gameNotation = gameNotation;\r\n}'),(21,'Position position','de.java_chess.javaChess.position.Position',80,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',68,'de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}'),(22,'de.java_chess.javaChess.piece.Piece','de.java_chess.javaChess.piece.Piece',67,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',68,'de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}'),(23,'Piece piece','de.java_chess.javaChess.piece.Piece',67,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',71,'de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * 		The piece to set, or null to empty the square.\r\n * @param position\r\n * 		The position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}'),(24,'Position position','de.java_chess.javaChess.position.Position',80,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',71,'de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * 		The piece to set, or null to empty the square.\r\n * @param position\r\n * 		The position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}'),(25,'Ply ply','de.java_chess.javaChess.ply.Ply',75,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',62,'de.java_chess.javaChess.bitboard.BitBoardImpl.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    Piece movedPiece = getPiece(ply.getSource());\r\n    // Check, if it was a castling\r\n    if (ply instanceof CastlingPly) {\r\n        int offset = (movedPiece.isWhite()) ? 0 : 56;\r\n        if (((CastlingPly) (ply)).isLeftCastling()) {\r\n            setPiece(movedPiece, new PositionImpl((2 + offset)));\r\n            // Move the rook to the right\r\n            doPly(new PlyImpl(new PositionImpl((0 + offset)), new PositionImpl((3 + offset)), false));\r\n        } else {\r\n            setPiece(movedPiece, new PositionImpl((6 + offset)));\r\n            // Move the rook to the left\r\n            doPly(new PlyImpl(new PositionImpl((7 + offset)), new PositionImpl((5 + offset)), false));\r\n        }\r\n    } else {\r\n        // If a pawn has just reached the last row\r\n        if (ply instanceof TransformationPly) {\r\n            // Set a piece of the new type on the destination square.\r\n            setPiece(new PieceImpl(((TransformationPly) (ply)).getTypeAfterTransformation(), movedPiece.getColor()), ply.getDestination());\r\n        } else {\r\n            // Copy the piece from source square to destination square.\r\n            setPiece(movedPiece, ply.getDestination());\r\n            // If its a en passant ply, remove the attacked pawn.\r\n            if (ply instanceof EnPassantPly) {\r\n                setPiece(null, ((EnPassantPly) (ply)).getAttackedPosition());\r\n            }\r\n        }\r\n    }\r\n    // Empty the source square.\r\n    setPiece(null, ply.getSource());\r\n}'),(26,'Ply ply','de.java_chess.javaChess.ply.Ply',75,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',65,'de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}'),(27,'de.java_chess.javaChess.board.Board','de.java_chess.javaChess.board.Board',13,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',65,'de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}'),(28,'Position position','de.java_chess.javaChess.position.Position',80,13,'de.java_chess.javaChess.board.Board',76,'de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);'),(29,'de.java_chess.javaChess.piece.Piece','de.java_chess.javaChess.piece.Piece',67,13,'de.java_chess.javaChess.board.Board',76,'de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);'),(30,'Piece piece','de.java_chess.javaChess.piece.Piece',67,13,'de.java_chess.javaChess.board.Board',78,'de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * 		The piece to set.\r\n * @param position\r\n * 		The position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);'),(31,'Position position','de.java_chess.javaChess.position.Position',80,13,'de.java_chess.javaChess.board.Board',78,'de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * 		The piece to set.\r\n * @param position\r\n * 		The position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);'),(32,'Ply ply','de.java_chess.javaChess.ply.Ply',75,13,'de.java_chess.javaChess.board.Board',73,'de.java_chess.javaChess.board.Board.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * 		The move to perform.\r\n */\r\nvoid doPly(Ply ply);'),(33,'Ply ply','de.java_chess.javaChess.ply.Ply',75,13,'de.java_chess.javaChess.board.Board',75,'de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);'),(34,'de.java_chess.javaChess.board.Board','de.java_chess.javaChess.board.Board',13,13,'de.java_chess.javaChess.board.Board',75,'de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);'),(35,'DialogAbout adaptee','de.java_chess.javaChess.dialogs.DialogAbout',14,15,'de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter',86,'de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.-init-(de.java_chess.javaChess.dialogs.DialogAbout)',0,'DialogAbout_CloseButton_keyAdapter(DialogAbout adaptee) {\r\n    this.adaptee = adaptee;\r\n}'),(36,'SetupBoardDialog dialog','de.java_chess.javaChess.dialogs.SetupBoardDialog',18,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',96,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)',0,'public void setCallingDialog(SetupBoardDialog dialog) {\r\n    this.setupBoardDialog = dialog;\r\n}'),(37,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',122,'de.java_chess.javaChess.engine.BitBoardAnalyzer.setBoard(de.java_chess.javaChess.bitboard.BitBoard)',0,'/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(BitBoard board);'),(38,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',121,'de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);'),(39,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',118,'de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);'),(40,'Game game','de.java_chess.javaChess.game.Game',50,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',124,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)',0,'// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * 		A PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}'),(41,'PlyGenerator plyGenerator','de.java_chess.javaChess.engine.PlyGenerator',25,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',124,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)',0,'// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * 		A PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}'),(42,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',132,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setBoard(de.java_chess.javaChess.bitboard.BitBoard)',0,'/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(BitBoard board) {\r\n    _board = board;\r\n}'),(43,'Game game','de.java_chess.javaChess.game.Game',50,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',133,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(44,'PlyGenerator plyGenerator','de.java_chess.javaChess.engine.PlyGenerator',25,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',135,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)',0,'/**\r\n * Set a new PlyGenerator instance.\r\n *\r\n * @param plyGenerator\r\n * 		The new PlyGenerator instance.\r\n */\r\nprivate final void setPlyGenerator(PlyGenerator plyGenerator) {\r\n    _plyGenerator = plyGenerator;\r\n}'),(45,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',131,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}'),(46,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',126,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}'),(47,'Game game','de.java_chess.javaChess.game.Game',50,23,'de.java_chess.javaChess.engine.ChessEngine',148,'de.java_chess.javaChess.engine.ChessEngine.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\nvoid setGame(Game game);'),(48,'Board board','de.java_chess.javaChess.board.Board',13,23,'de.java_chess.javaChess.engine.ChessEngine',147,'de.java_chess.javaChess.engine.ChessEngine.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(Board board);'),(49,'Ply ply','de.java_chess.javaChess.ply.Ply',75,23,'de.java_chess.javaChess.engine.ChessEngine',152,'de.java_chess.javaChess.engine.ChessEngine.validateUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\nboolean validateUserPly(Ply ply);'),(50,'Game game','de.java_chess.javaChess.game.Game',50,24,'de.java_chess.javaChess.engine.ChessEngineImpl',153,'de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)',0,'// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(51,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,24,'de.java_chess.javaChess.engine.ChessEngineImpl',153,'de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)',0,'// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(52,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',153,'de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)',0,'// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(53,'Game game','de.java_chess.javaChess.game.Game',50,24,'de.java_chess.javaChess.engine.ChessEngineImpl',188,'de.java_chess.javaChess.engine.ChessEngineImpl.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(54,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',186,'de.java_chess.javaChess.engine.ChessEngineImpl.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic void setBoard(Board board) {\r\n    _board = board;\r\n}'),(55,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,24,'de.java_chess.javaChess.engine.ChessEngineImpl',189,'de.java_chess.javaChess.engine.ChessEngineImpl.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * 		The new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}'),(56,'PermanentBrain permanentBrain','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',34,24,'de.java_chess.javaChess.engine.ChessEngineImpl',193,'de.java_chess.javaChess.engine.ChessEngineImpl.setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)',0,'/**\r\n * Set a new permanent brain.\r\n *\r\n * @param permanentBrain\r\n * 		The new permanent brain.\r\n */\r\nprivate final void setPermanentBrain(PermanentBrain permanentBrain) {\r\n    _permanentBrain = permanentBrain;\r\n}'),(57,'OpeningBook book','de.java_chess.javaChess.engine.opening_book.OpeningBook',31,24,'de.java_chess.javaChess.engine.ChessEngineImpl',192,'de.java_chess.javaChess.engine.ChessEngineImpl.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)',0,'/**\r\n * Set a new opening book.\r\n *\r\n * @param book\r\n * 		The new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}'),(58,'Ply lastPly','de.java_chess.javaChess.ply.Ply',75,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(59,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(60,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',158,'de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}'),(61,'Ply ply','de.java_chess.javaChess.ply.Ply',75,24,'de.java_chess.javaChess.engine.ChessEngineImpl',203,'de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}'),(62,'EnginePanel panel','de.java_chess.javaChess.renderer2d.EnginePanel',89,24,'de.java_chess.javaChess.engine.ChessEngineImpl',187,'de.java_chess.javaChess.engine.ChessEngineImpl.setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)',0,'/**\r\n * Sets the EnginePanel to be able to output in the panel and not only with\r\n * System.out.println(...)\r\n *\r\n * @param panel\r\n * 		The EnginePanel to set\r\n */\r\npublic void setEnginePanel(EnginePanel panel) {\r\n    this._enginePanel = panel;\r\n}'),(63,'StatusPanel myPanel','de.java_chess.javaChess.renderer2d.StatusPanel',96,24,'de.java_chess.javaChess.engine.ChessEngineImpl',196,'de.java_chess.javaChess.engine.ChessEngineImpl.setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)',0,'public void setStatusPanel(StatusPanel myPanel) {\r\n    if ((this._statusPanel) != myPanel)\r\n        this._statusPanel = myPanel;\r\n\r\n}'),(64,'EngineStatusListener listener','de.java_chess.javaChess.listener.EngineStatusListener',53,24,'de.java_chess.javaChess.engine.ChessEngineImpl',156,'de.java_chess.javaChess.engine.ChessEngineImpl.addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)',0,'/**\r\n * Registers an object for notification.\r\n *\r\n * @param listener\r\n * 		The object to be registered.\r\n */\r\npublic void addEngineStatusListener(EngineStatusListener listener) {\r\n    listeners.add(listener);\r\n}'),(65,'Game game','de.java_chess.javaChess.game.Game',50,25,'de.java_chess.javaChess.engine.PlyGenerator',204,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}'),(66,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,25,'de.java_chess.javaChess.engine.PlyGenerator',204,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}'),(67,'Game game','de.java_chess.javaChess.game.Game',50,25,'de.java_chess.javaChess.engine.PlyGenerator',205,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param board\r\n * 		The board to operate on.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}'),(68,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,25,'de.java_chess.javaChess.engine.PlyGenerator',205,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param board\r\n * 		The board to operate on.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}'),(69,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,25,'de.java_chess.javaChess.engine.PlyGenerator',205,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param board\r\n * 		The board to operate on.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}'),(70,'Game game','de.java_chess.javaChess.game.Game',50,25,'de.java_chess.javaChess.engine.PlyGenerator',237,'de.java_chess.javaChess.engine.PlyGenerator.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(71,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,25,'de.java_chess.javaChess.engine.PlyGenerator',238,'de.java_chess.javaChess.engine.PlyGenerator.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * 		The new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}'),(72,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,25,'de.java_chess.javaChess.engine.PlyGenerator',229,'de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * 		The ply, that lead to the given board.\r\n * @param board\r\n * 		The board with the game position.\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}'),(73,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,25,'de.java_chess.javaChess.engine.PlyGenerator',236,'de.java_chess.javaChess.engine.PlyGenerator.setBoard(de.java_chess.javaChess.bitboard.BitBoard)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nfinal void setBoard(BitBoard board) {\r\n    _board = board;\r\n}'),(74,'BitBoardAnalyzer analyzer','de.java_chess.javaChess.engine.BitBoardAnalyzer',20,25,'de.java_chess.javaChess.engine.PlyGenerator',235,'de.java_chess.javaChess.engine.PlyGenerator.setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)',0,'/**\r\n * Set the last ply.\r\n *\r\n * @param lastPly\r\n * 		The last ply.\r\n */\r\n/* final void setLastPly( Ply lastPly) {\n// _lastPly = lastPly;\n}\n */\r\n/**\r\n * Set a analyzer for check tests.\r\n *\r\n * @param analyzer\r\n * 		The new analyzer to set.\r\n */\r\npublic final void setAnalyzer(BitBoardAnalyzer analyzer) {\r\n    _analyzer = analyzer;\r\n}'),(75,'Ply ply','de.java_chess.javaChess.ply.Ply',75,25,'de.java_chess.javaChess.engine.PlyGenerator',217,'de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)',0,'/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * 		The ply to add.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}'),(76,'PlyHashtableEntry ply','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry',27,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',243,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)',0,'/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * 		The new entry, that the hashtable might store.\r\n */\r\nvoid pushEntry(PlyHashtableEntry ply);'),(77,'Board board','de.java_chess.javaChess.board.Board',13,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',241,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The board before the move.\r\n * @param white\r\n * 		Flag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);'),(78,'de.java_chess.javaChess.ply.Ply','de.java_chess.javaChess.ply.Ply',75,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',241,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)',1,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The board before the move.\r\n * @param white\r\n * 		Flag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);'),(79,'Board board','de.java_chess.javaChess.board.Board',13,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',252,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)',0,'// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * 		The board before the ply.\r\n * @param ply\r\n * 		The ply to store.\r\n * @param searchDepth\r\n * 		The search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(80,'Ply ply','de.java_chess.javaChess.ply.Ply',75,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',252,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)',0,'// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * 		The board before the ply.\r\n * @param ply\r\n * 		The ply to store.\r\n * @param searchDepth\r\n * 		The search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(81,'Board board','de.java_chess.javaChess.board.Board',13,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',259,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board for this entry.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}'),(82,'Ply ply','de.java_chess.javaChess.ply.Ply',75,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',260,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply.\r\n *\r\n * @param ply\r\n * 		The ply to set.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(83,'Board board','de.java_chess.javaChess.board.Board',13,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',257,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}'),(84,'PlyHashtableEntry ply','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry',27,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',266,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)',0,'/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * 		The new entry, that the hashtable might store.\r\n */\r\npublic final void pushEntry(PlyHashtableEntry ply) {\r\n    // Compute and store the key for this ply.\r\n    Long hashKey = new Long(ply.hashKey());\r\n    // Check if this ply is not already in the hashtable\r\n    PlyHashtableEntry oldEntry = ((PlyHashtableEntry) (_hashtable.get(hashKey)));\r\n    if (oldEntry != null) {\r\n        // There is a entry with the same key\r\n        if ((oldEntry.getSearchDepth()) >= (ply.getSearchDepth())) {\r\n            return;// This entry shouldnt be replaced.\r\n\r\n        }\r\n    } else {\r\n        // Now we actually add a new entry to the table.\r\n        // Check, if the hashtable has not exceeded its maximum capacity\r\n        // and remove older entries, if necessary.\r\n        while ((getSize()) >= (getMaximumSize())) {\r\n            removeOldestEntry();\r\n        } \r\n    }\r\n    // Put the new ply into the hashtable\r\n    _hashtable.put(hashKey, ply);\r\n    // Append the new ply at the end of the list of plies.\r\n    // ATTENTION: this will only work, if theres only _one_\r\n    // ply for each key!\r\n    _orderedList.add(hashKey);\r\n}'),(85,'Board board','de.java_chess.javaChess.board.Board',13,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',264,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(86,'de.java_chess.javaChess.ply.Ply','de.java_chess.javaChess.ply.Ply',75,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',264,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)',1,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(87,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,30,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl',271,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		Flag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}'),(88,'Ply ply','de.java_chess.javaChess.ply.Ply',75,31,'de.java_chess.javaChess.engine.opening_book.OpeningBook',274,'de.java_chess.javaChess.engine.opening_book.OpeningBook.doUserPly(de.java_chess.javaChess.ply.Ply)',0,'// Methods\r\n/**\r\n * Advance the game by one user ply.\r\n *\r\n * @param ply\r\n * 		The ply from the user.\r\n */\r\nvoid doUserPly(Ply ply);'),(89,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',277,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'// Constructors\r\n/**\r\n * Create a new instance of this class.\r\n *\r\n * @param notation\r\n * 		The notation of the current game.\r\n */\r\npublic OpeningBookImpl(GameNotation notation) {\r\n    setNotation(notation);\r\n    // Create a new dynamic array for the openings.\r\n    _openings = new ArrayList();\r\n    // Reset the opening book.\r\n    reset();\r\n}'),(90,'Ply ply','de.java_chess.javaChess.ply.Ply',75,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',279,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.doUserPly(de.java_chess.javaChess.ply.Ply)',0,'// Methods\r\n/**\r\n * The user just did a ply.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n */\r\npublic final void doUserPly(Ply ply) {\r\n    // If we are already in a opening, check if the current user\r\n    // move doesnt lead us out of the opening line.\r\n    if ((_currentOpening) != (-1)) {\r\n        if (!(isInOpening(_currentOpening))) {\r\n            _currentOpening = -1;\r\n        }\r\n    }\r\n}'),(91,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',285,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.setNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set the notation of the current game.\r\n *\r\n * @param notation\r\n * 		The notation of the current game.\r\n */\r\nprivate final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}'),(92,'OpeningBook book','de.java_chess.javaChess.engine.opening_book.OpeningBook',31,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',286,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)',0,'// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param book\r\n * 		The opening book, we are operating on.\r\n */\r\npublic LoadOpeningsAction(OpeningBook book) {\r\n    super(\"Load openings from PGN...\");\r\n    setOpeningBook(book);\r\n}'),(93,'OpeningBook book','de.java_chess.javaChess.engine.opening_book.OpeningBook',31,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',291,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)',0,'/**\r\n * Set the opening book, we are operating on.\r\n *\r\n * @param book\r\n * 		The new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}'),(94,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',292,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.-init-(de.java_chess.javaChess.engine.ChessEngine)',0,'// Constructors\r\n/**\r\n * Create a new PermanentBrain instance.\r\n *\r\n * @param engine\r\n * 		The used chess engine.\r\n */\r\npublic PermanentBrain(ChessEngine engine) {\r\n    setEngine(engine);\r\n}'),(95,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',298,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.setEngine(de.java_chess.javaChess.engine.ChessEngine)',0,'/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * 		The new chess engine.\r\n */\r\nprivate final void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}'),(96,'Ply ply','de.java_chess.javaChess.ply.Ply',75,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',294,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * 		The ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}'),(97,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPly','de.java_chess.javaChess.engine.permanent_brain.PreComputedPly',35,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',294,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * 		The ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}'),(98,'AnalyzedPly ply','de.java_chess.javaChess.ply.AnalyzedPly',69,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',303,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)',0,'// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * 		The computed ply.\r\n * @param searchDepth\r\n * 		The used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(99,'AnalyzedPly ply','de.java_chess.javaChess.ply.AnalyzedPly',69,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',306,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setPly(de.java_chess.javaChess.ply.AnalyzedPly)',0,'/**\r\n * Set the computed ply.\r\n *\r\n * @param ply\r\n * 		The computed ply.\r\n */\r\nprivate final void setPly(AnalyzedPly ply) {\r\n    _ply = ply;\r\n}'),(100,'Ply ply','de.java_chess.javaChess.ply.Ply',75,38,'de.java_chess.javaChess.engine.test.AnalyzerTest2',314,'de.java_chess.javaChess.engine.test.AnalyzerTest2.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(101,'Ply ply','de.java_chess.javaChess.ply.Ply',75,39,'de.java_chess.javaChess.engine.test.BoardConsistencyTest1',321,'de.java_chess.javaChess.engine.test.BoardConsistencyTest1.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(102,'Ply ply','de.java_chess.javaChess.ply.Ply',75,42,'de.java_chess.javaChess.engine.test.MinimaxTest1',331,'de.java_chess.javaChess.engine.test.MinimaxTest1.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(103,'Ply ply','de.java_chess.javaChess.ply.Ply',75,43,'de.java_chess.javaChess.engine.test.MinimaxTest2',336,'de.java_chess.javaChess.engine.test.MinimaxTest2.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(104,'Ply ply','de.java_chess.javaChess.ply.Ply',75,44,'de.java_chess.javaChess.engine.test.PlyGeneratorTest1',341,'de.java_chess.javaChess.engine.test.PlyGeneratorTest1.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(105,'Ply ply','de.java_chess.javaChess.ply.Ply',75,45,'de.java_chess.javaChess.engine.test.PlyGeneratorTest2',346,'de.java_chess.javaChess.engine.test.PlyGeneratorTest2.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(106,'Ply ply','de.java_chess.javaChess.ply.Ply',75,46,'de.java_chess.javaChess.engine.test.PlyGeneratorTest3',351,'de.java_chess.javaChess.engine.test.PlyGeneratorTest3.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(107,'Ply ply','de.java_chess.javaChess.ply.Ply',75,47,'de.java_chess.javaChess.engine.test.PlyGeneratorTest4',356,'de.java_chess.javaChess.engine.test.PlyGeneratorTest4.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(108,'Ply ply','de.java_chess.javaChess.ply.Ply',75,48,'de.java_chess.javaChess.engine.test.PlyGeneratorTest5',361,'de.java_chess.javaChess.engine.test.PlyGeneratorTest5.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(109,'Ply ply','de.java_chess.javaChess.ply.Ply',75,49,'de.java_chess.javaChess.engine.test.PlyGeneratorTest6',366,'de.java_chess.javaChess.engine.test.PlyGeneratorTest6.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(110,'Ply ply','de.java_chess.javaChess.ply.Ply',75,50,'de.java_chess.javaChess.game.Game',370,'de.java_chess.javaChess.game.Game.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Add a new ply to the game.\r\n *\r\n * @unknown The new ply.\r\n */\r\nvoid doPly(Ply ply);'),(111,'Position position','de.java_chess.javaChess.position.Position',80,50,'de.java_chess.javaChess.game.Game',373,'de.java_chess.javaChess.game.Game.hasBeenMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * 		The position to check.\r\n */\r\nboolean hasBeenMoved(Position position);'),(112,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',388,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,long)',0,'// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * 		The ply for this game status.\r\n * @param bitmask\r\n * 		The moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}'),(113,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',389,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * 		The first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}'),(114,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',390,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)',0,'/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * 		The previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}'),(115,'GameImpl.GameStatus previousStatus','de.java_chess.javaChess.game.GameImpl$GameStatus',51,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',390,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)',0,'/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * 		The previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}'),(116,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',396,'de.java_chess.javaChess.game.GameImpl$GameStatus.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply, that lead to this game status.\r\n *\r\n * @param ply\r\n * 		The ply, that lead to this game status.\r\n */\r\nfinal void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(117,'Position position','de.java_chess.javaChess.position.Position',80,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',394,'de.java_chess.javaChess.game.GameImpl$GameStatus.setMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Mark a piece moved from its initial position.\r\n *\r\n * @param position\r\n * 		The position of the moved piece.\r\n */\r\nprivate final void setMoved(Position position) {\r\n    _movedPieces |= 1L << (position.getSquareIndex());\r\n}'),(118,'Position position','de.java_chess.javaChess.position.Position',80,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',393,'de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}'),(119,'Ply ply','de.java_chess.javaChess.ply.Ply',75,52,'de.java_chess.javaChess.game.GameImpl',380,'de.java_chess.javaChess.game.GameImpl.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Do a new ply in this game.\r\n *\r\n * @param ply\r\n * 		The next ply.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    // Add a new game status, that derives from the previous status.\r\n    _gameStatus.push(((getLastGameStatus()) == null ? new GameImpl.GameStatus(ply) : new GameImpl.GameStatus(ply, getLastGameStatus())));\r\n}'),(120,'Position position','de.java_chess.javaChess.position.Position',80,52,'de.java_chess.javaChess.game.GameImpl',384,'de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * 		The position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}'),(121,'ChessEngineImpl engine','de.java_chess.javaChess.engine.ChessEngineImpl',24,53,'de.java_chess.javaChess.listener.EngineStatusListener',397,'de.java_chess.javaChess.listener.EngineStatusListener.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)',0,'public void engineStatusChanged(ChessEngineImpl engine);'),(122,'NotationPanel panel','de.java_chess.javaChess.renderer2d.NotationPanel',92,54,'de.java_chess.javaChess.menu.EditMenu',401,'de.java_chess.javaChess.menu.EditMenu.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)',0,'/**\r\n * Sets the NotationPanel to be able to perform some actions there\r\n *\r\n * @param panel\r\n * 		The NotationPanel object\r\n */\r\npublic final void setNotationPanel(NotationPanel panel) {\r\n    this.notationPanel = panel;\r\n}'),(123,'PlyNotation plyNotation','de.java_chess.javaChess.notation.PlyNotation',57,55,'de.java_chess.javaChess.notation.GameNotation',402,'de.java_chess.javaChess.notation.GameNotation.addPly(de.java_chess.javaChess.notation.PlyNotation)',0,'/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * 		The notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation);'),(124,'PlyNotation plyNotation','de.java_chess.javaChess.notation.PlyNotation',57,56,'de.java_chess.javaChess.notation.GameNotationImpl',414,'de.java_chess.javaChess.notation.GameNotationImpl.addPly(de.java_chess.javaChess.notation.PlyNotation)',0,'/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * 		The notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation) {\r\n    _plies.add(plyNotation);\r\n    int nPlies = _plies.size();// Get the number of plies.\r\n\r\n    if ((nPlies & 1) != 0) {\r\n        if (nPlies > 1) {\r\n            // Start a new line\r\n            _notation.append(\"\n\");\r\n        }\r\n        _notation.append(((\"\" + ((nPlies >> 1) + 1)) + \". \"));\r\n    } else {\r\n        _notation.append(\" \");\r\n    }\r\n    _notation.append(plyNotation.toString());\r\n    // If theres a panel, display the current notation.\r\n    if (null != (getNotationPanel())) {\r\n        getNotationPanel().setText(toString());\r\n    }\r\n}'),(125,'NotationPanel notationPanel','de.java_chess.javaChess.renderer2d.NotationPanel',92,56,'de.java_chess.javaChess.notation.GameNotationImpl',423,'de.java_chess.javaChess.notation.GameNotationImpl.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)',0,'/**\r\n * Set the panel for the notation output.\r\n *\r\n * @param notationPanel\r\n * 		The panel for the output.\r\n */\r\npublic final void setNotationPanel(NotationPanel notationPanel) {\r\n    _notationPanel = notationPanel;\r\n}'),(126,'Piece piece','de.java_chess.javaChess.piece.Piece',67,57,'de.java_chess.javaChess.notation.PlyNotation',436,'de.java_chess.javaChess.notation.PlyNotation.setPiece(de.java_chess.javaChess.piece.Piece)',0,'/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * 		The moved ply.\r\n */\r\nvoid setPiece(Piece piece);'),(127,'Ply ply','de.java_chess.javaChess.ply.Ply',75,57,'de.java_chess.javaChess.notation.PlyNotation',437,'de.java_chess.javaChess.notation.PlyNotation.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * 		The ply for this notation.\r\n */\r\nvoid setPly(Ply ply);'),(128,'Ply ply','de.java_chess.javaChess.ply.Ply',75,58,'de.java_chess.javaChess.notation.PlyNotationImpl',439,'de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)',0,'// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n * @param piece\r\n * 		The moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}'),(129,'Piece piece','de.java_chess.javaChess.piece.Piece',67,58,'de.java_chess.javaChess.notation.PlyNotationImpl',439,'de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)',0,'// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n * @param piece\r\n * 		The moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}'),(130,'Piece piece','de.java_chess.javaChess.piece.Piece',67,58,'de.java_chess.javaChess.notation.PlyNotationImpl',449,'de.java_chess.javaChess.notation.PlyNotationImpl.setPiece(de.java_chess.javaChess.piece.Piece)',0,'/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * 		The moved ply.\r\n */\r\npublic final void setPiece(Piece piece) {\r\n    _piece = piece;\r\n}'),(131,'Ply ply','de.java_chess.javaChess.ply.Ply',75,58,'de.java_chess.javaChess.notation.PlyNotationImpl',450,'de.java_chess.javaChess.notation.PlyNotationImpl.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * 		The ply for this notation.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(132,'PGNPlyFragment plyFragment','de.java_chess.javaChess.pgn.PGNPlyFragment',65,59,'de.java_chess.javaChess.pgn.GameLoader',453,'de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)',0,'// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * 		The info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}'),(133,'de.java_chess.javaChess.notation.PlyNotation','de.java_chess.javaChess.notation.PlyNotation',57,59,'de.java_chess.javaChess.pgn.GameLoader',453,'de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)',1,'// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * 		The info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}'),(134,'Ply ply','de.java_chess.javaChess.ply.Ply',75,59,'de.java_chess.javaChess.pgn.GameLoader',454,'de.java_chess.javaChess.pgn.GameLoader.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply, when it is completely loaded.\r\n *\r\n * param ply The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n    // The other color is about to move now.\r\n    _whiteMoves = !(_whiteMoves);\r\n}'),(135,'PGNParser parser','de.java_chess.javaChess.pgn.PGNParser',64,60,'de.java_chess.javaChess.pgn.PGNFile',459,'de.java_chess.javaChess.pgn.PGNFile.setPGNParser(de.java_chess.javaChess.pgn.PGNParser)',0,'/**\r\n * Set the current parser.\r\n *\r\n * @param parser\r\n * 		The new PGN parser.\r\n */\r\nprivate final void setPGNParser(PGNParser parser) {\r\n    _parser = parser;\r\n}'),(136,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,63,'de.java_chess.javaChess.pgn.PGNOutputStream',492,'de.java_chess.javaChess.pgn.PGNOutputStream.write(de.java_chess.javaChess.notation.GameNotation)',0,'// Methods\r\n/**\r\n * Write the notation of a game.\r\n *\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\npublic final void write(GameNotation gameNotation) throws IOException {\r\n    // Check, if there is some header available.\r\n    String header = gameNotation.getPGNheader();\r\n    if (!(\"\".equals(header))) {\r\n        header += \"\n\";\r\n        write(header.getBytes());\r\n    }\r\n    write(gameNotation.toString().getBytes());\r\n}'),(137,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,64,'de.java_chess.javaChess.pgn.PGNParser',511,'de.java_chess.javaChess.pgn.PGNParser.setNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set a new buffer for the game notation.\r\n *\r\n * @param notation\r\n * 		The new notation buffer.\r\n */\r\npublic final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}'),(138,'GameLoader loader','de.java_chess.javaChess.pgn.GameLoader',59,64,'de.java_chess.javaChess.pgn.PGNParser',510,'de.java_chess.javaChess.pgn.PGNParser.setGameLoader(de.java_chess.javaChess.pgn.GameLoader)',0,'/**\r\n * Set a new game loader.\r\n *\r\n * @param loader\r\n * 		The new game loader.\r\n */\r\nprivate final void setGameLoader(GameLoader loader) {\r\n    _gameLoader = loader;\r\n}'),(139,'GameNotation notationBuffer','de.java_chess.javaChess.notation.GameNotation',55,64,'de.java_chess.javaChess.pgn.PGNParser',506,'de.java_chess.javaChess.pgn.PGNParser.pgnGame(de.java_chess.javaChess.notation.GameNotation)',0,'public final void pgnGame(GameNotation notationBuffer) throws RecognitionException, TokenStreamException {\r\n    setNotation(notationBuffer);\r\n    setGameLoader(new GameLoader());\r\n    whiteSpaces();\r\n    tagPairSection();\r\n    moveTextSection();\r\n}'),(140,'Position position','de.java_chess.javaChess.position.Position',80,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',530,'de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the name of the origin square.\r\n *\r\n * @param position\r\n * 		The position of the origin square.\r\n */\r\npublic final void setOrigin(Position position) {\r\n    // Store the position.\r\n    _origin = position;\r\n}'),(141,'Ply ply','de.java_chess.javaChess.ply.Ply',75,69,'de.java_chess.javaChess.ply.AnalyzedPly',552,'de.java_chess.javaChess.ply.AnalyzedPly.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * 		The new ply.\r\n */\r\nvoid setPly(Ply ply);'),(142,'Ply ply','de.java_chess.javaChess.ply.Ply',75,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',554,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)',0,'// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}'),(143,'Ply ply','de.java_chess.javaChess.ply.Ply',75,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',558,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * 		The new ply.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(144,'Position source','de.java_chess.javaChess.position.Position',80,72,'de.java_chess.javaChess.ply.CastlingPlyImpl',562,'de.java_chess.javaChess.ply.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}'),(145,'Position attackedPosition','de.java_chess.javaChess.position.Position',80,73,'de.java_chess.javaChess.ply.EnPassantPly',567,'de.java_chess.javaChess.ply.EnPassantPly.setAttackedPosition(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * 		The position of the attacked pawn.\r\n */\r\nvoid setAttackedPosition(Position attackedPosition);'),(146,'Position source','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',568,'de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)',0,'// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * 		The source square of the attacking pawn.\r\n * @param destination\r\n * 		The destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * 		The position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}'),(147,'Position destination','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',568,'de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)',0,'// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * 		The source square of the attacking pawn.\r\n * @param destination\r\n * 		The destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * 		The position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}'),(148,'Position attackedPosition','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',568,'de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)',0,'// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * 		The source square of the attacking pawn.\r\n * @param destination\r\n * 		The destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * 		The position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}'),(149,'Position attackedPosition','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',570,'de.java_chess.javaChess.ply.EnPassantPlyImpl.setAttackedPosition(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * 		The position of the attacked pawn.\r\n */\r\npublic final void setAttackedPosition(Position attackedPosition) {\r\n    _attackedPosition = attackedPosition;\r\n}'),(150,'Position source','de.java_chess.javaChess.position.Position',80,75,'de.java_chess.javaChess.ply.Ply',576,'de.java_chess.javaChess.ply.Ply.setSource(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the source of the ply.\r\n *\r\n * @param source\r\n * 		The new source square for this ply.\r\n */\r\nvoid setSource(Position source);'),(151,'Position destination','de.java_chess.javaChess.position.Position',80,75,'de.java_chess.javaChess.ply.Ply',575,'de.java_chess.javaChess.ply.Ply.setDestination(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * 		The new destination square of this ply.\r\n */\r\nvoid setDestination(Position destination);'),(152,'Ply ply','de.java_chess.javaChess.ply.Ply',75,75,'de.java_chess.javaChess.ply.Ply',571,'de.java_chess.javaChess.ply.Ply.equals(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * 		The other ply.\r\n * @return true, if the 2 plies are equal. False otherwise.\r\n */\r\nboolean equals(Ply ply);'),(153,'Position source','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',577,'de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param capture\r\n * 		Flag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}'),(154,'Position destination','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',577,'de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param capture\r\n * 		Flag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}'),(155,'Position source','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',584,'de.java_chess.javaChess.ply.PlyImpl.setSource(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the source of the ply.\r\n *\r\n * @param The\r\n * 		new source of the piece.\r\n */\r\npublic final void setSource(Position source) {\r\n    _source = source;\r\n}'),(156,'Position destination','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',583,'de.java_chess.javaChess.ply.PlyImpl.setDestination(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * 		The new destination of the piece.\r\n */\r\npublic final void setDestination(Position destination) {\r\n    _destination = destination;\r\n}'),(157,'Ply ply','de.java_chess.javaChess.ply.Ply',75,76,'de.java_chess.javaChess.ply.PlyImpl',578,'de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * 		The other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}'),(158,'Position source','de.java_chess.javaChess.position.Position',80,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',588,'de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param pieceType\r\n * 		The piece type after the transformation.\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}'),(159,'Position destination','de.java_chess.javaChess.position.Position',80,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',588,'de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param pieceType\r\n * 		The piece type after the transformation.\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}'),(160,'Position pos','de.java_chess.javaChess.position.Position',80,80,'de.java_chess.javaChess.position.Position',592,'de.java_chess.javaChess.position.Position.equals(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * 		position.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\nboolean equals(Position pos);'),(161,'Position pos','de.java_chess.javaChess.position.Position',80,81,'de.java_chess.javaChess.position.PositionImpl',600,'de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * 		position.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}'),(162,'Board board','de.java_chess.javaChess.board.Board',13,82,'de.java_chess.javaChess.renderer.ChessBoardRenderer',610,'de.java_chess.javaChess.renderer.ChessBoardRenderer.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(Board board);'),(163,'Ply ply','de.java_chess.javaChess.ply.Ply',75,82,'de.java_chess.javaChess.renderer.ChessBoardRenderer',606,'de.java_chess.javaChess.renderer.ChessBoardRenderer.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Render a piece move.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\nvoid doPly(Ply ply);'),(164,'PiecesLayer piecesLayer','de.java_chess.javaChess.renderer2d.PiecesLayer',94,83,'de.java_chess.javaChess.renderer2d.AnimationLayer',611,'de.java_chess.javaChess.renderer2d.AnimationLayer.-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'// Constructors\r\n/**\r\n * Create a new AnimationLayer instance.\r\n *\r\n * @param piecesLayer\r\n * 		The layer with the pieces.\r\n */\r\nAnimationLayer(PiecesLayer piecesLayer) {\r\n    setPiecesLayer(piecesLayer);\r\n}'),(165,'Ply ply','de.java_chess.javaChess.ply.Ply',75,83,'de.java_chess.javaChess.renderer2d.AnimationLayer',612,'de.java_chess.javaChess.renderer2d.AnimationLayer.animatePly(de.java_chess.javaChess.ply.Ply)',0,'// Methods\r\n/**\r\n * Animate the move of a piece.\r\n */\r\nvoid animatePly(Ply ply) {\r\n    _ply = ply;\r\n}'),(166,'PiecesLayer piecesLayer','de.java_chess.javaChess.renderer2d.PiecesLayer',94,83,'de.java_chess.javaChess.renderer2d.AnimationLayer',615,'de.java_chess.javaChess.renderer2d.AnimationLayer.setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'/**\r\n * Set a new pieces layer.\r\n *\r\n * @param piecesLayer\r\n * 		The new pieces layer.\r\n */\r\nvoid setPiecesLayer(PiecesLayer piecesLayer) {\r\n    _piecesLayer = piecesLayer;\r\n}'),(167,'GameController controller','de.java_chess.javaChess.GameController',1,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',624,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)',0,'// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * 		The game controller.\r\n * @param board\r\n * 		The current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}'),(168,'Board board','de.java_chess.javaChess.board.Board',13,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',624,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)',0,'// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * 		The game controller.\r\n * @param board\r\n * 		The current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}'),(169,'Ply ply','de.java_chess.javaChess.ply.Ply',75,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',626,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Render a ply (the move of a piece).\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    _piecesLayer.doPly(ply);\r\n    repaint();\r\n}'),(170,'Board board','de.java_chess.javaChess.board.Board',13,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',634,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}'),(171,'GameController controller','de.java_chess.javaChess.GameController',1,87,'de.java_chess.javaChess.renderer2d.ControlLayer',636,'de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}'),(172,'PiecesLayer pl','de.java_chess.javaChess.renderer2d.PiecesLayer',94,87,'de.java_chess.javaChess.renderer2d.ControlLayer',636,'de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}'),(173,'GameController controller','de.java_chess.javaChess.GameController',1,87,'de.java_chess.javaChess.renderer2d.ControlLayer',641,'de.java_chess.javaChess.renderer2d.ControlLayer.setController(de.java_chess.javaChess.GameController)',0,'/**\r\n * Set a new game controller.\r\n *\r\n * @param The\r\n * 		new game controller.\r\n */\r\nprivate final void setController(GameController controller) {\r\n    _controller = controller;\r\n}'),(174,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,92,'de.java_chess.javaChess.renderer2d.NotationPanel',680,'de.java_chess.javaChess.renderer2d.NotationPanel.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Standardconstructor\r\n */\r\npublic NotationPanel(GameNotation gameNotation) {\r\n    super();\r\n    // Store the game notation in this instance.\r\n    setGameNotation(gameNotation);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(175,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,92,'de.java_chess.javaChess.renderer2d.NotationPanel',687,'de.java_chess.javaChess.renderer2d.NotationPanel.setGameNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set a new notation object.\r\n *\r\n * @param gameNotation\r\n * 		The new game notation.\r\n */\r\npublic void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}'),(176,'ChessSet set','de.java_chess.javaChess.renderer2d.ChessSet',86,93,'de.java_chess.javaChess.renderer2d.PieceRenderer',690,'de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)',0,'// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * 		The color of the piece.\r\n * @param piece\r\n * 		The type of the piece.\r\n * @param set\r\n * 		The set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}'),(177,'Board board','de.java_chess.javaChess.board.Board',13,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',691,'de.java_chess.javaChess.renderer2d.PiecesLayer.-init-(de.java_chess.javaChess.board.Board)',0,'PiecesLayer(Board board) {\r\n    super(new GridLayout(8, 8));\r\n    _set = new ChessSet(this);\r\n    _animationLayer = new AnimationLayer(this);\r\n    _board = board;\r\n    int _boardSize = 8 * (ChessBoardRenderer2D.getSquareSize());\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    setOpaque(false);\r\n    repaintBoard();\r\n}'),(178,'Ply ply','de.java_chess.javaChess.ply.Ply',75,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',693,'de.java_chess.javaChess.renderer2d.PiecesLayer.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Render a ply.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    if (_animatedMoves) {\r\n        getAnimationLayer().animatePly(ply);\r\n        getAnimationLayer().start();\r\n        repaint();\r\n    } else {\r\n        // Check, if it was a castling\r\n        if (ply instanceof CastlingPly) {\r\n            int source = ply.getSource().getSquareIndex();\r\n            if (((CastlingPly) (ply)).isLeftCastling()) {\r\n                _square[(source - 2)].getPieceFrom(_square[source]);\r\n                _square[(source - 1)].getPieceFrom(_square[(source - 4)]);// Move the rook to the right\r\n\r\n            } else {\r\n                _square[(source + 2)].getPieceFrom(_square[source]);\r\n                _square[(source + 1)].getPieceFrom(_square[(source + 3)]);// Move the rook to the left\r\n\r\n            }\r\n        } else {\r\n            // If a pawn has just reached the last row\r\n            if (ply instanceof TransformationPly) {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // Now change the rendering to the new piece type.\r\n                _square[ply.getDestination().getSquareIndex()].setIcon(new ImageIcon(new PieceRenderer(((ply.getDestination().getSquareIndex()) < 8 ? Piece.BLACK : Piece.WHITE), ((TransformationPly) (ply)).getTypeAfterTransformation(), _set, this)));\r\n            } else {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // If its a en passant ply, remove the attacked pawn.\r\n                if (ply instanceof EnPassantPly) {\r\n                    _square[((EnPassantPly) (ply)).getAttackedPosition().getSquareIndex()].setIcon(null);\r\n                }\r\n            }\r\n        }\r\n        repaint();\r\n    }\r\n}'),(179,'PositionRenderer positionRenderer','de.java_chess.javaChess.renderer2d.PositionRenderer',95,95,'de.java_chess.javaChess.renderer2d.PositionRenderer',699,'de.java_chess.javaChess.renderer2d.PositionRenderer.getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)',0,'// Methods\r\n/**\r\n * Move a piece from another position to this one.\r\n *\r\n * positionRenderer The position renderer for the source.\r\n */\r\nvoid getPieceFrom(PositionRenderer positionRenderer) {\r\n    setIcon(positionRenderer.getIcon());\r\n    positionRenderer.setIcon(null);\r\n}');
/*!40000 ALTER TABLE `parameters` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2020-11-28 21:29:49
