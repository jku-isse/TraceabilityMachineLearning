-- MySQL dump 10.13  Distrib 5.7.17, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: databasechess
-- ------------------------------------------------------
-- Server version	8.0.11

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `parameters`
--

DROP TABLE IF EXISTS `parameters`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `parameters` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `parametername` longtext,
  `parametertype` longtext,
  `parameterclass` int(11) DEFAULT NULL,
  `classid` int(11) DEFAULT NULL,
  `classname` longtext,
  `methodid` int(11) DEFAULT NULL,
  `methodname` longtext,
  `isreturn` tinyint(4) NOT NULL,
  `sourcecode` longtext NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=710 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `parameters`
--

LOCK TABLES `parameters` WRITE;
/*!40000 ALTER TABLE `parameters` DISABLE KEYS */;
INSERT INTO `parameters` VALUES (1,'Game game','de.java_chess.javaChess.game.Game',50,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(2,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(3,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(4,'Board board','de.java_chess.javaChess.board.Board',13,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(5,'GameTimer timer','de.java_chess.javaChess.timer.GameTimer',99,1,'de.java_chess.javaChess.GameController',1,'de.java_chess.javaChess.GameController.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.engine.ChessEngine,de.java_chess.javaChess.board.Board,de.java_chess.javaChess.timer.GameTimer)',0,'// Constructors\r\n/**\r\n * Create a new controller instance.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n * @param engine\r\n * 		The current engine.\r\n * @param board\r\n * 		The current board.\r\n * @param timer\r\n * 		The game timer.\r\n */\r\npublic GameController(Game game, GameNotation gameNotation, ChessEngine engine, Board board, GameTimer timer) {\r\n    setGame(game);\r\n    setGameNotation(gameNotation);\r\n    setEngine(engine);\r\n    setBoard(board);\r\n    setGameTimer(timer);\r\n}'),(6,'Game game','de.java_chess.javaChess.game.Game',50,1,'de.java_chess.javaChess.GameController',16,'de.java_chess.javaChess.GameController.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(7,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,1,'de.java_chess.javaChess.GameController',17,'de.java_chess.javaChess.GameController.setGameNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set the current game notation.\r\n *\r\n * @param gameNotation\r\n * 		The new game notation.\r\n */\r\npublic final void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}'),(8,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,1,'de.java_chess.javaChess.GameController',15,'de.java_chess.javaChess.GameController.setEngine(de.java_chess.javaChess.engine.ChessEngine)',0,'/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * 		The new engine.\r\n */\r\nfinal void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}'),(9,'Board board','de.java_chess.javaChess.board.Board',13,1,'de.java_chess.javaChess.GameController',14,'de.java_chess.javaChess.GameController.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nfinal void setBoard(Board board) {\r\n    _board = board;\r\n}'),(10,'ChessBoardRenderer renderer','de.java_chess.javaChess.renderer.ChessBoardRenderer',82,1,'de.java_chess.javaChess.GameController',19,'de.java_chess.javaChess.GameController.setRenderer(de.java_chess.javaChess.renderer.ChessBoardRenderer)',0,'/**\r\n * Set a new renderer.\r\n *\r\n * @param renderer\r\n * 		The new renderer.\r\n */\r\nfinal void setRenderer(ChessBoardRenderer renderer) {\r\n    _renderer = renderer;\r\n}'),(11,'GameTimer timer','de.java_chess.javaChess.timer.GameTimer',99,1,'de.java_chess.javaChess.GameController',18,'de.java_chess.javaChess.GameController.setGameTimer(de.java_chess.javaChess.timer.GameTimer)',0,'/**\r\n * Set a new game timer.\r\n *\r\n * @param timer\r\n * 		The new game timer.\r\n */\r\nfinal void setGameTimer(GameTimer timer) {\r\n    _gameTimer = timer;\r\n    timer.addActionListener(this);\r\n}'),(12,'Ply ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',23,'de.java_chess.javaChess.GameController.userPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * The user moved a piece.\r\n *\r\n * @param ply\r\n * 		The ply of the user.\r\n */\r\npublic final void userPly(Ply ply) {\r\n    // Before any user ply can be applied, we have to stop\r\n    // the permanent brain, so the engine is free to process\r\n    // the user ply.\r\n    getEngine().stopPermanentBrain();\r\n    // plyInterpretation\r\n    ply = convertUserPly(ply);\r\n    // Check if the user has the right to move a piece\r\n    // and made a valid move.\r\n    if ((_moveRight) != (_computerIsWhite)) {\r\n        if ((((_gameState) != (GameState.CHECKMATE)) && ((_gameState) != (GameState.DRAW))) && ((_gameState) != (GameState.TIMEOUT))) {\r\n            if (getEngine().validateUserPly(ply)) {\r\n                doPly(ply);// Ok => move the piece.\r\n\r\n            } else {\r\n                // The user had to right to move or made an invalid move.\r\n                signalUserInputError(\"invalid move\");\r\n            }\r\n        } else {\r\n            signalUserInputError(\"game is already over\");\r\n        }\r\n    } else {\r\n        signalUserInputError(\"user is not about to move\");\r\n    }\r\n}'),(13,'Ply ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(14,'de.java_chess.javaChess.ply.Ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(15,'Ply ply','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',5,'de.java_chess.javaChess.GameController.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to do.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    // If the game is over, stop here.\r\n    if ((_gameState) == (GameState.TIMEOUT)) {\r\n        return;\r\n    }\r\n    // Store the ply notation to set the check flags a bit later, since they are computed in the gameOver()\r\n    // call in the move right toggle.\r\n    PlyNotation plyNotation = new PlyNotationImpl(ply, getBoard().getPiece(ply.getSource()));\r\n    getGame().doPly(ply);\r\n    getBoard().doPly(ply);\r\n    getRenderer().doPly(ply);\r\n    // Now try to get some info on the current game state.\r\n    boolean gameOver = gameOver((!(_moveRight)));\r\n    // Set check info for this ply.\r\n    if ((_gameState) == (GameState.CHECKMATE)) {\r\n        plyNotation.setCheckMate(true);\r\n    } else {\r\n        if ((_gameState) == (GameState.CHECK)) {\r\n            plyNotation.setCheck(true);\r\n        }\r\n    }\r\n    // Add the ply to the notation.\r\n    getGameNotation().addPly(plyNotation);\r\n    if (gameOver) {\r\n        getGameTimer().stop();// The game has ended.\r\n\r\n        if ((_gameState) == (GameState.DRAW)) {\r\n            signalGameOver(\"Draw! Use File -> Reset to play again!\");\r\n        } else {\r\n            signalGameOver(((_moveRight) == (_computerIsWhite) ? \"Checkmate! I win! :-)\" : \"Checkmate! I lose... :-(\"));\r\n        }\r\n    } else {\r\n        toggleMoveRight();\r\n    }\r\n}'),(16,'boolean white','boolean',0,1,'de.java_chess.javaChess.GameController',6,'de.java_chess.javaChess.GameController.gameOver(boolean)',0,'/**\r\n * Check if the game is over.\r\n *\r\n * @param white\r\n * 		True, if white is about to move.\r\n * @return true, if the game is over.\r\n */\r\nprivate final boolean gameOver(boolean white) {\r\n    _gameState = getEngine().getCurrentGameState(white);\r\n    return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW));\r\n}'),(17,'ActionEvent event','java.awt.event.ActionEvent',0,1,'de.java_chess.javaChess.GameController',2,'de.java_chess.javaChess.GameController.actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Process a event, that we are listening to.\r\n *\r\n * @param event\r\n * 		The event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    System.out.println((\"Got event \" + (event.getActionCommand())));\r\n    // If the timer fired the event, check for timeout.\r\n    if ((event.getSource()) == (getGameTimer())) {\r\n        String command = event.getActionCommand();\r\n        if (\"timeout white\".equals(command)) {\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for you! I win!\");\r\n        }\r\n        if (\"timeout black\".equals(command)) {\r\n            System.out.println(\"Black timeout!\");\r\n            _gameState = GameState.TIMEOUT;\r\n            signalGameOver(\"Timeout for me! You win!\");\r\n        }\r\n    }\r\n}'),(18,'String errorMessage','java.lang.String',0,1,'de.java_chess.javaChess.GameController',21,'de.java_chess.javaChess.GameController.signalUserInputError(java.lang.String)',0,'/**\r\n * Signal a input error to the user.\r\n *\r\n * @param errorMessage\r\n * 		More information on the error.\r\n */\r\npublic final void signalUserInputError(String errorMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, errorMessage, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n}'),(19,'String gameOverMessage','java.lang.String',0,1,'de.java_chess.javaChess.GameController',20,'de.java_chess.javaChess.GameController.signalGameOver(java.lang.String)',0,'/**\r\n * Signal the end if the game.\r\n *\r\n * @param gameOverMessage\r\n * 		Some info how and why the game has ended.\r\n */\r\npublic final void signalGameOver(String gameOverMessage) {\r\n    System.out.print(((char) (7)));\r\n    JOptionPane.showMessageDialog(null, gameOverMessage, \"Game over\", JOptionPane.INFORMATION_MESSAGE);\r\n}'),(20,'String[] args','java.lang.String[]',0,3,'de.java_chess.javaChess.JavaChess',31,'de.java_chess.javaChess.JavaChess.main(java.lang.String[])',0,'// Methods\r\n/**\r\n * The main method.\r\n *\r\n * @param args\r\n * 		The commandline arguments.\r\n */\r\npublic static void main(String[] args) {\r\n    JavaChess._instance = new JavaChess();\r\n}'),(21,'JavaChessAction action','de.java_chess.javaChess.action.JavaChessAction',6,3,'de.java_chess.javaChess.JavaChess',29,'de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)',0,'/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * 		The action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}'),(22,'Dimension screenSize','java.awt.Dimension',0,3,'de.java_chess.javaChess.JavaChess',33,'de.java_chess.javaChess.JavaChess.placeFrame(java.awt.Dimension,java.awt.Dimension)',0,'private void placeFrame(Dimension screenSize, Dimension frameSize) {\r\n    setLocation((((screenSize.width) - (frameSize.width)) / 2), (((screenSize.height) - (frameSize.height)) / 2));\r\n}'),(23,'Dimension frameSize','java.awt.Dimension',0,3,'de.java_chess.javaChess.JavaChess',33,'de.java_chess.javaChess.JavaChess.placeFrame(java.awt.Dimension,java.awt.Dimension)',0,'private void placeFrame(Dimension screenSize, Dimension frameSize) {\r\n    setLocation((((screenSize.width) - (frameSize.width)) / 2), (((screenSize.height) - (frameSize.height)) / 2));\r\n}'),(24,'Dimension screenSize','java.awt.Dimension',0,3,'de.java_chess.javaChess.JavaChess',36,'de.java_chess.javaChess.JavaChess.setFrameSize(java.awt.Dimension,java.awt.Dimension)',0,'private void setFrameSize(Dimension screenSize, Dimension frameSize) {\r\n    if ((frameSize.height) > (screenSize.height)) {\r\n        frameSize.height = screenSize.height;\r\n    }\r\n    if ((frameSize.width) > (screenSize.width)) {\r\n        frameSize.width = screenSize.width;\r\n    }\r\n}'),(25,'Dimension frameSize','java.awt.Dimension',0,3,'de.java_chess.javaChess.JavaChess',36,'de.java_chess.javaChess.JavaChess.setFrameSize(java.awt.Dimension,java.awt.Dimension)',0,'private void setFrameSize(Dimension screenSize, Dimension frameSize) {\r\n    if ((frameSize.height) > (screenSize.height)) {\r\n        frameSize.height = screenSize.height;\r\n    }\r\n    if ((frameSize.width) > (screenSize.width)) {\r\n        frameSize.width = screenSize.width;\r\n    }\r\n}'),(26,'WindowEvent e','java.awt.event.WindowEvent',0,3,'de.java_chess.javaChess.JavaChess',37,'de.java_chess.javaChess.JavaChess.this_windowClosing(java.awt.event.WindowEvent)',0,'/**\r\n * If Java-Chess is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * 		The Window event\r\n */\r\nvoid this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}'),(27,'ChessEngineImpl engine','de.java_chess.javaChess.engine.ChessEngineImpl',24,3,'de.java_chess.javaChess.JavaChess',26,'de.java_chess.javaChess.JavaChess.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)',0,'public void engineStatusChanged(ChessEngineImpl engine) {\r\n    if ((this.jpStatus) != null) {\r\n        this.jpStatus.setActionText(engine.getStatusDisplayString());\r\n    }\r\n}'),(28,'ActionEvent event','java.awt.event.ActionEvent',0,4,'de.java_chess.javaChess.action.AboutAction',39,'de.java_chess.javaChess.action.AboutAction.actionPerformed(java.awt.event.ActionEvent)',0,'// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    DialogAbout dialog = DialogAbout.getInstance();\r\n    if (dialog != null) {\r\n        Tools.setDialogToCenter(dialog);\r\n        dialog.show();\r\n    }\r\n}'),(29,'ActionEvent event','java.awt.event.ActionEvent',0,5,'de.java_chess.javaChess.action.HelpAction',41,'de.java_chess.javaChess.action.HelpAction.actionPerformed(java.awt.event.ActionEvent)',0,'// Methods\r\n/**\r\n * The action action.\r\n *\r\n * @param event\r\n * 		The event, that triggered the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Just a dummy so far...\r\n}'),(30,'String name','java.lang.String',0,6,'de.java_chess.javaChess.action.JavaChessAction',42,'de.java_chess.javaChess.action.JavaChessAction.-init-(java.lang.String)',0,'// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new Java-Chess action.\r\n *\r\n * @param name\r\n * 		The name of the action.\r\n */\r\npublic JavaChessAction(String name) {\r\n    super(name);\r\n    putValue(Action.SHORT_DESCRIPTION, name);\r\n}'),(31,'ActionEvent event','java.awt.event.ActionEvent',0,7,'de.java_chess.javaChess.action.LoadGameAction',46,'de.java_chess.javaChess.action.LoadGameAction.actionPerformed(java.awt.event.ActionEvent)',0,'// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Missing: save current project?\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        try {\r\n            PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n            GameNotation notation = pgnFile.readGame();\r\n        } catch (FileNotFoundException fe) {\r\n            JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n        } catch (RecognitionException re) {\r\n        } catch (TokenStreamException te) {\r\n        }\r\n    }\r\n}'),(32,'ActionEvent event','java.awt.event.ActionEvent',0,8,'de.java_chess.javaChess.action.ResetGameAction',48,'de.java_chess.javaChess.action.ResetGameAction.actionPerformed(java.awt.event.ActionEvent)',0,'// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused the action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JavaChess.getInstance().reset();\r\n}'),(33,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,9,'de.java_chess.javaChess.action.SaveGameAction',49,'de.java_chess.javaChess.action.SaveGameAction.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * 		The game notation.\r\n */\r\npublic SaveGameAction(GameNotation gameNotation) {\r\n    super(\"Save game\");\r\n    _gameNotation = gameNotation;\r\n}'),(34,'String name','java.lang.String',0,9,'de.java_chess.javaChess.action.SaveGameAction',50,'de.java_chess.javaChess.action.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * 		The name of the action.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}'),(35,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,9,'de.java_chess.javaChess.action.SaveGameAction',50,'de.java_chess.javaChess.action.SaveGameAction.-init-(java.lang.String,de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Create a new action instance.\r\n *\r\n * @param name\r\n * 		The name of the action.\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\nSaveGameAction(String name, GameNotation gameNotation) {\r\n    super(\"Save Game as...\");\r\n    _gameNotation = gameNotation;\r\n}'),(36,'ActionEvent event','java.awt.event.ActionEvent',0,9,'de.java_chess.javaChess.action.SaveGameAction',51,'de.java_chess.javaChess.action.SaveGameAction.actionPerformed(java.awt.event.ActionEvent)',0,'// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n}'),(37,'File file','java.io.File',0,9,'de.java_chess.javaChess.action.SaveGameAction',52,'de.java_chess.javaChess.action.SaveGameAction.trySave(java.io.File)',0,'/**\r\n * Try to save the game into the given file.\r\n *\r\n * @param file\r\n * 		The file to write into.\r\n */\r\npublic void trySave(File file) {\r\n    try {\r\n        PGNOutputStream PGNOutput = new PGNOutputStream(file);\r\n        // Write the notation of the game.\r\n        PGNOutput.write(_gameNotation);\r\n    } catch (IOException exception) {\r\n        JOptionPane.showMessageDialog(null, (\"Error while writing file: \" + (file.getName())), \"Error\", JOptionPane.ERROR_MESSAGE);\r\n    }\r\n}'),(38,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,10,'de.java_chess.javaChess.action.SaveGameAsAction',53,'de.java_chess.javaChess.action.SaveGameAsAction.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\npublic SaveGameAsAction(GameNotation gameNotation) {\r\n    super(\"Save game as...\", gameNotation);\r\n    _gameNotation = gameNotation;\r\n}'),(39,'ActionEvent event','java.awt.event.ActionEvent',0,10,'de.java_chess.javaChess.action.SaveGameAsAction',54,'de.java_chess.javaChess.action.SaveGameAsAction.actionPerformed(java.awt.event.ActionEvent)',0,'// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Create a new filechooser\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Saving game as pgn file\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    int retval = chooser.showSaveDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        trySave(chooser.getSelectedFile());\r\n    }\r\n}'),(40,'int pieceTypeColor','int',0,11,'de.java_chess.javaChess.bitboard.BitBoard',59,'de.java_chess.javaChess.bitboard.BitBoard.getPositionOfPieces(int)',0,'// Methods\r\n/**\r\n * Get the position of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * 		The color and type of the pieces.\r\n * @return A bitmask with the positions of these pieces.\r\n */\r\nlong getPositionOfPieces(int pieceTypeColor);'),(41,'boolean white','boolean',0,11,'de.java_chess.javaChess.bitboard.BitBoard',56,'de.java_chess.javaChess.bitboard.BitBoard.getAllPiecesForColor(boolean)',0,'/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * 		true, if the white pieces are requested,\r\n * 		false for the black pieces.\r\n */\r\nlong getAllPiecesForColor(boolean white);'),(42,'Position position','de.java_chess.javaChess.position.Position',80,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',68,'de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}'),(43,'de.java_chess.javaChess.piece.Piece','de.java_chess.javaChess.piece.Piece',67,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',68,'de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}'),(44,'Piece piece','de.java_chess.javaChess.piece.Piece',67,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',71,'de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * 		The piece to set, or null to empty the square.\r\n * @param position\r\n * 		The position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}'),(45,'Position position','de.java_chess.javaChess.position.Position',80,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',71,'de.java_chess.javaChess.bitboard.BitBoardImpl.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given square.\r\n *\r\n * @param piece\r\n * 		The piece to set, or null to empty the square.\r\n * @param position\r\n * 		The position of the square.\r\n */\r\npublic final void setPiece(Piece piece, Position position) {\r\n    byte pieceCodeColor = (piece == null) ? 0 : piece.getTypeAndColor();\r\n    long bitmask = 1L << (position.getSquareIndex());\r\n    long bitFilter = ~bitmask;\r\n    for (int i = 0; i < 4; i++) {\r\n        if ((pieceCodeColor & 1) != 0) {\r\n            _boardLayer[i] |= bitmask;// Set this bit to 1.\r\n\r\n        } else {\r\n            _boardLayer[i] &= bitFilter;// Set this bit to 0.\r\n\r\n        }\r\n        pieceCodeColor >>= 1;\r\n    }\r\n}'),(46,'Ply ply','de.java_chess.javaChess.ply.Ply',75,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',62,'de.java_chess.javaChess.bitboard.BitBoardImpl.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    Piece movedPiece = getPiece(ply.getSource());\r\n    // Check, if it was a castling\r\n    if (ply instanceof CastlingPly) {\r\n        int offset = (movedPiece.isWhite()) ? 0 : 56;\r\n        if (((CastlingPly) (ply)).isLeftCastling()) {\r\n            setPiece(movedPiece, new PositionImpl((2 + offset)));\r\n            // Move the rook to the right\r\n            doPly(new PlyImpl(new PositionImpl((0 + offset)), new PositionImpl((3 + offset)), false));\r\n        } else {\r\n            setPiece(movedPiece, new PositionImpl((6 + offset)));\r\n            // Move the rook to the left\r\n            doPly(new PlyImpl(new PositionImpl((7 + offset)), new PositionImpl((5 + offset)), false));\r\n        }\r\n    } else {\r\n        // If a pawn has just reached the last row\r\n        if (ply instanceof TransformationPly) {\r\n            // Set a piece of the new type on the destination square.\r\n            setPiece(new PieceImpl(((TransformationPly) (ply)).getTypeAfterTransformation(), movedPiece.getColor()), ply.getDestination());\r\n        } else {\r\n            // Copy the piece from source square to destination square.\r\n            setPiece(movedPiece, ply.getDestination());\r\n            // If its a en passant ply, remove the attacked pawn.\r\n            if (ply instanceof EnPassantPly) {\r\n                setPiece(null, ((EnPassantPly) (ply)).getAttackedPosition());\r\n            }\r\n        }\r\n    }\r\n    // Empty the source square.\r\n    setPiece(null, ply.getSource());\r\n}'),(47,'Ply ply','de.java_chess.javaChess.ply.Ply',75,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',65,'de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}'),(48,'de.java_chess.javaChess.board.Board','de.java_chess.javaChess.board.Board',13,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',65,'de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}'),(49,'int pieceTypeColor','int',0,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',69,'de.java_chess.javaChess.bitboard.BitBoardImpl.getPositionOfPieces(int)',0,'/**\r\n * Get the positions of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * 		The color and type of the pieces.\r\n */\r\npublic final long getPositionOfPieces(int pieceTypeColor) {\r\n    return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]));\r\n}'),(50,'boolean white','boolean',0,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',64,'de.java_chess.javaChess.bitboard.BitBoardImpl.getAllPiecesForColor(boolean)',0,'/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * 		true, if the white pieces are requested,\r\n * 		false for the black pieces.\r\n */\r\npublic final long getAllPiecesForColor(boolean white) {\r\n    return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]));\r\n}'),(51,'Position position','de.java_chess.javaChess.position.Position',80,13,'de.java_chess.javaChess.board.Board',76,'de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);'),(52,'de.java_chess.javaChess.piece.Piece','de.java_chess.javaChess.piece.Piece',67,13,'de.java_chess.javaChess.board.Board',76,'de.java_chess.javaChess.board.Board.getPiece(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Get the piece of a given position.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece on that position, or null if the\r\nsquare is empty.\r\n */\r\nPiece getPiece(Position position);'),(53,'Piece piece','de.java_chess.javaChess.piece.Piece',67,13,'de.java_chess.javaChess.board.Board',78,'de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * 		The piece to set.\r\n * @param position\r\n * 		The position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);'),(54,'Position position','de.java_chess.javaChess.position.Position',80,13,'de.java_chess.javaChess.board.Board',78,'de.java_chess.javaChess.board.Board.setPiece(de.java_chess.javaChess.piece.Piece,de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set a piece on a given position.\r\n *\r\n * @param piece\r\n * 		The piece to set.\r\n * @param position\r\n * 		The position to set the piece on.\r\n */\r\nvoid setPiece(Piece piece, Position position);'),(55,'Ply ply','de.java_chess.javaChess.ply.Ply',75,13,'de.java_chess.javaChess.board.Board',73,'de.java_chess.javaChess.board.Board.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Move a piece from one square to another.\r\n *\r\n * @param ply\r\n * 		The move to perform.\r\n */\r\nvoid doPly(Ply ply);'),(56,'Ply ply','de.java_chess.javaChess.ply.Ply',75,13,'de.java_chess.javaChess.board.Board',75,'de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);'),(57,'de.java_chess.javaChess.board.Board','de.java_chess.javaChess.board.Board',13,13,'de.java_chess.javaChess.board.Board',75,'de.java_chess.javaChess.board.Board.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\nBoard getBoardAfterPly(Ply ply);'),(58,'ActionEvent event','java.awt.event.ActionEvent',0,14,'de.java_chess.javaChess.dialogs.DialogAbout',81,'de.java_chess.javaChess.dialogs.DialogAbout.actionPerformed(java.awt.event.ActionEvent)',0,'public void actionPerformed(ActionEvent event) {\r\n    this.setVisible(false);\r\n}'),(59,'KeyEvent e','java.awt.event.KeyEvent',0,14,'de.java_chess.javaChess.dialogs.DialogAbout',80,'de.java_chess.javaChess.dialogs.DialogAbout.CloseButton_keyReleased(java.awt.event.KeyEvent)',0,'void CloseButton_keyReleased(KeyEvent e) {\r\n    if ((e.getKeyCode()) == (KeyEvent.VK_ENTER))\r\n        this.hide();\r\n\r\n}'),(60,'JTextArea textArea','javax.swing.JTextArea',0,14,'de.java_chess.javaChess.dialogs.DialogAbout',85,'de.java_chess.javaChess.dialogs.DialogAbout.setRegister(javax.swing.JTextArea,java.io.Reader)',0,'void setRegister(JTextArea textArea, Reader in) {\r\n    try {\r\n        char[] buffer = new char[4096];\r\n        int len;\r\n        textArea.setText(\"\");\r\n        while ((len = in.read(buffer)) != (-1)) {\r\n            String s = new String(buffer, 0, len);\r\n            textArea.append(s);\r\n        } \r\n        textArea.setCaretPosition(0);\r\n    } catch (IOException e) {\r\n        textArea.setText((((e.getClass().getName()) + \": \") + (e.getMessage())));\r\n    }\r\n}'),(61,'Reader in','java.io.Reader',0,14,'de.java_chess.javaChess.dialogs.DialogAbout',85,'de.java_chess.javaChess.dialogs.DialogAbout.setRegister(javax.swing.JTextArea,java.io.Reader)',0,'void setRegister(JTextArea textArea, Reader in) {\r\n    try {\r\n        char[] buffer = new char[4096];\r\n        int len;\r\n        textArea.setText(\"\");\r\n        while ((len = in.read(buffer)) != (-1)) {\r\n            String s = new String(buffer, 0, len);\r\n            textArea.append(s);\r\n        } \r\n        textArea.setCaretPosition(0);\r\n    } catch (IOException e) {\r\n        textArea.setText((((e.getClass().getName()) + \": \") + (e.getMessage())));\r\n    }\r\n}'),(62,'String resourceName','java.lang.String',0,14,'de.java_chess.javaChess.dialogs.DialogAbout',82,'de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)',0,'/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * 		The name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}'),(63,'DialogAbout adaptee','de.java_chess.javaChess.dialogs.DialogAbout',14,15,'de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter',86,'de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.-init-(de.java_chess.javaChess.dialogs.DialogAbout)',0,'DialogAbout_CloseButton_keyAdapter(DialogAbout adaptee) {\r\n    this.adaptee = adaptee;\r\n}'),(64,'KeyEvent e','java.awt.event.KeyEvent',0,15,'de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter',87,'de.java_chess.javaChess.dialogs.DialogAbout_CloseButton_keyAdapter.keyReleased(java.awt.event.KeyEvent)',0,'public void keyReleased(KeyEvent e) {\r\n    adaptee.CloseButton_keyReleased(e);\r\n}'),(65,'SetupBoardDialog dialog','de.java_chess.javaChess.dialogs.SetupBoardDialog',18,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',96,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.setCallingDialog(de.java_chess.javaChess.dialogs.SetupBoardDialog)',0,'public void setCallingDialog(SetupBoardDialog dialog) {\r\n    this.setupBoardDialog = dialog;\r\n}'),(66,'ActionEvent e','java.awt.event.ActionEvent',0,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',89,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.actionPerformed(java.awt.event.ActionEvent)',0,'public void actionPerformed(ActionEvent e) {\r\n    for (byte col = 0; col <= 1; col++) {\r\n        for (byte type = 1; type <= 6; type++) {\r\n            if ((_pieceButton[col][type]) == (e.getSource())) {\r\n                this.setType(type);\r\n                this.setColor(col);\r\n                this.jlSelectedPieceImage.setIcon(_pieceIcon[col][type]);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}'),(67,'byte type','byte',0,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',98,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.setType(byte)',0,'/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * 		The type of this piece as defined as\r\n * 		constants in the Piece interface.\r\n */\r\npublic void setType(byte type) {\r\n    pieceColor &= ((byte) (1));\r\n    pieceColor |= type << 1;\r\n}'),(68,'byte color','byte',0,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',97,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.setColor(byte)',0,'/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * 		new color of this piece.\r\n */\r\npublic void setColor(byte color) {\r\n    pieceColor &= ((byte) (14));\r\n    pieceColor |= color;\r\n}'),(69,'int iWhiteBlack','int',0,17,'de.java_chess.javaChess.dialogs.PlayerDialog',100,'de.java_chess.javaChess.dialogs.PlayerDialog.-init-(int,java.lang.String)',0,'/**\r\n *\r\n *\r\n * @param iWhiteBlack\r\n * 		1 = edit white players name\r\n * @param currentString\r\n * 		The string which already is displayed above the notation panel\r\n */\r\npublic PlayerDialog(int iWhiteBlack, String currentString) {\r\n    this.iWhite = iWhiteBlack;\r\n    this.sCurrentString = currentString;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(70,'String currentString','java.lang.String',0,17,'de.java_chess.javaChess.dialogs.PlayerDialog',100,'de.java_chess.javaChess.dialogs.PlayerDialog.-init-(int,java.lang.String)',0,'/**\r\n *\r\n *\r\n * @param iWhiteBlack\r\n * 		1 = edit white players name\r\n * @param currentString\r\n * 		The string which already is displayed above the notation panel\r\n */\r\npublic PlayerDialog(int iWhiteBlack, String currentString) {\r\n    this.iWhite = iWhiteBlack;\r\n    this.sCurrentString = currentString;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(71,'ActionEvent e','java.awt.event.ActionEvent',0,17,'de.java_chess.javaChess.dialogs.PlayerDialog',101,'de.java_chess.javaChess.dialogs.PlayerDialog.actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Interface method; handles the mouse click on the OK-button\r\n *\r\n * @param e\r\n * 		The action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jbOK)) {\r\n        this.hide();\r\n    }\r\n}'),(72,'WindowEvent e','java.awt.event.WindowEvent',0,18,'de.java_chess.javaChess.dialogs.SetupBoardDialog',112,'de.java_chess.javaChess.dialogs.SetupBoardDialog.this_windowClosing(java.awt.event.WindowEvent)',0,'/**\r\n * If this dialog is closed over the X and not via File-Exit, a process\r\n * would be still running\r\n *\r\n * @param e\r\n * 		The Window event\r\n */\r\nprivate void this_windowClosing(WindowEvent e) {\r\n    System.exit(0);\r\n}'),(73,'ActionEvent e','java.awt.event.ActionEvent',0,18,'de.java_chess.javaChess.dialogs.SetupBoardDialog',105,'de.java_chess.javaChess.dialogs.SetupBoardDialog.jbCancel_actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Button Cancel pressed\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nprivate void jbCancel_actionPerformed(ActionEvent e) {\r\n    this.dispose();\r\n}'),(74,'ActionEvent e','java.awt.event.ActionEvent',0,18,'de.java_chess.javaChess.dialogs.SetupBoardDialog',108,'de.java_chess.javaChess.dialogs.SetupBoardDialog.jbOk_actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Button Ok pressed\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nprivate void jbOk_actionPerformed(ActionEvent e) {\r\n    this.hide();\r\n}'),(75,'MouseEvent e','java.awt.event.MouseEvent',0,18,'de.java_chess.javaChess.dialogs.SetupBoardDialog',110,'de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseEntered(java.awt.event.MouseEvent)',0,'/**\r\n * Mouse cursor entered the board: Use piece as mouse pointer over the board\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jpBoard_mouseEntered(MouseEvent e) {\r\n    Image imageCursor;\r\n    oldCursor = this.getCursor();\r\n    // byte typeAndColor = ((Piece)jpPieces).getTypeAndColor();\r\n    // URL url = getClass().getResource(\"BP.gif\");\r\n    // Image image = Toolkit.getDefaultToolkit().getImage( url );\r\n    // Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(((Piece)jpPieces).getSelectedPieceImage(), new Point(20, 20), \"Piece\");\r\n    imageCursor = ((PieceSelectionPanel) (jpPieces)).getSelectedPieceImage();\r\n    ((PieceSelectionPanel) (jpPieces)).initializeSelectedIconLabel();\r\n    if (imageCursor != null) {\r\n        Cursor myCursor = Toolkit.getDefaultToolkit().createCustomCursor(imageCursor, new Point(20, 20), \"Piece\");\r\n        jpBoard.setCursor(myCursor);\r\n    }\r\n}'),(76,'MouseEvent e','java.awt.event.MouseEvent',0,18,'de.java_chess.javaChess.dialogs.SetupBoardDialog',111,'de.java_chess.javaChess.dialogs.SetupBoardDialog.jpBoard_mouseExited(java.awt.event.MouseEvent)',0,'/**\r\n * Mouse cursor left the board: Use normal mouse pointer again\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jpBoard_mouseExited(MouseEvent e) {\r\n    jpBoard.setCursor(oldCursor);\r\n}'),(77,'ActionEvent e','java.awt.event.ActionEvent',0,18,'de.java_chess.javaChess.dialogs.SetupBoardDialog',106,'de.java_chess.javaChess.dialogs.SetupBoardDialog.jbClearBoard_actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Button Clear board pressed; self-explaining\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jbClearBoard_actionPerformed(ActionEvent e) {\r\n    this.boardRenderer.clearBoard();\r\n}'),(78,'ActionEvent e','java.awt.event.ActionEvent',0,18,'de.java_chess.javaChess.dialogs.SetupBoardDialog',109,'de.java_chess.javaChess.dialogs.SetupBoardDialog.jbStartPosition_actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Button Start position pressed; self-explaining\r\n *\r\n * @param e\r\n * 		The event\r\n */\r\nvoid jbStartPosition_actionPerformed(ActionEvent e) {\r\n    bitBoard.initialPosition();\r\n    this.boardRenderer.reset();\r\n    this.validate();\r\n}'),(79,'JFrame parent','javax.swing.JFrame',0,19,'de.java_chess.javaChess.dialogs.TransformationDialog',113,'de.java_chess.javaChess.dialogs.TransformationDialog.-init-(javax.swing.JFrame,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation dialog.\r\n *\r\n * @param parent\r\n * 		The parent frame.\r\n * @param modal\r\n * 		Flag, if the dialog is modal.\r\n */\r\nprivate TransformationDialog(JFrame parent, boolean modal) {\r\n    super(parent, modal);\r\n    _pieceType = Piece.QUEEN;// Set the piece type to the default value.\r\n\r\n    setTitle(\"Chose a piece type\");// Set the title of the dialog.\r\n\r\n    // Set a new layout with bigger gaps.\r\n    getContentPane().setLayout(new BorderLayout(16, 16));\r\n    // Add a panel with the options.\r\n    JPanel choserPanel = new JPanel();\r\n    choserPanel.setLayout(new GridLayout(4, 1));\r\n    // Create a group for the piece types to handle the selection\r\n    // of the radio buttons.\r\n    ButtonGroup buttonGroup = new ButtonGroup();\r\n    // Add the buttons for piece types\r\n    _queenButton = new JRadioButton(\"Queen\");\r\n    _queenButton.setSelected(true);\r\n    // Queen is the default choice.\r\n    buttonGroup.add(_queenButton);\r\n    _queenButton.addActionListener(this);\r\n    choserPanel.add(_queenButton);\r\n    _rookButton = new JRadioButton(\"Rook\");\r\n    buttonGroup.add(_rookButton);\r\n    _rookButton.addActionListener(this);\r\n    choserPanel.add(_rookButton);\r\n    _knightButton = new JRadioButton(\"Knight\");\r\n    buttonGroup.add(_knightButton);\r\n    _knightButton.addActionListener(this);\r\n    choserPanel.add(_knightButton);\r\n    _bishopButton = new JRadioButton(\"Bishop\");\r\n    buttonGroup.add(_bishopButton);\r\n    _bishopButton.addActionListener(this);\r\n    choserPanel.add(_bishopButton);\r\n    getContentPane().add(choserPanel, BorderLayout.CENTER);\r\n    // Add a button to hide the dialog.\r\n    _okButton = new JButton(\"Ok\");\r\n    _okButton.addActionListener(this);\r\n    getContentPane().add(_okButton, BorderLayout.SOUTH);\r\n    pack();\r\n    // Get the screen size and place the dialog in the middle of the screen.\r\n    Dimension size = getSize();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    setLocation((((screenSize.width) / 2) - ((size.width) / 2)), (((screenSize.height) / 2) - ((size.height) / 2)));\r\n}'),(80,'boolean modal','boolean',0,19,'de.java_chess.javaChess.dialogs.TransformationDialog',113,'de.java_chess.javaChess.dialogs.TransformationDialog.-init-(javax.swing.JFrame,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation dialog.\r\n *\r\n * @param parent\r\n * 		The parent frame.\r\n * @param modal\r\n * 		Flag, if the dialog is modal.\r\n */\r\nprivate TransformationDialog(JFrame parent, boolean modal) {\r\n    super(parent, modal);\r\n    _pieceType = Piece.QUEEN;// Set the piece type to the default value.\r\n\r\n    setTitle(\"Chose a piece type\");// Set the title of the dialog.\r\n\r\n    // Set a new layout with bigger gaps.\r\n    getContentPane().setLayout(new BorderLayout(16, 16));\r\n    // Add a panel with the options.\r\n    JPanel choserPanel = new JPanel();\r\n    choserPanel.setLayout(new GridLayout(4, 1));\r\n    // Create a group for the piece types to handle the selection\r\n    // of the radio buttons.\r\n    ButtonGroup buttonGroup = new ButtonGroup();\r\n    // Add the buttons for piece types\r\n    _queenButton = new JRadioButton(\"Queen\");\r\n    _queenButton.setSelected(true);\r\n    // Queen is the default choice.\r\n    buttonGroup.add(_queenButton);\r\n    _queenButton.addActionListener(this);\r\n    choserPanel.add(_queenButton);\r\n    _rookButton = new JRadioButton(\"Rook\");\r\n    buttonGroup.add(_rookButton);\r\n    _rookButton.addActionListener(this);\r\n    choserPanel.add(_rookButton);\r\n    _knightButton = new JRadioButton(\"Knight\");\r\n    buttonGroup.add(_knightButton);\r\n    _knightButton.addActionListener(this);\r\n    choserPanel.add(_knightButton);\r\n    _bishopButton = new JRadioButton(\"Bishop\");\r\n    buttonGroup.add(_bishopButton);\r\n    _bishopButton.addActionListener(this);\r\n    choserPanel.add(_bishopButton);\r\n    getContentPane().add(choserPanel, BorderLayout.CENTER);\r\n    // Add a button to hide the dialog.\r\n    _okButton = new JButton(\"Ok\");\r\n    _okButton.addActionListener(this);\r\n    getContentPane().add(_okButton, BorderLayout.SOUTH);\r\n    pack();\r\n    // Get the screen size and place the dialog in the middle of the screen.\r\n    Dimension size = getSize();\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    setLocation((((screenSize.width) / 2) - ((size.width) / 2)), (((screenSize.height) / 2) - ((size.height) / 2)));\r\n}'),(81,'ActionEvent event','java.awt.event.ActionEvent',0,19,'de.java_chess.javaChess.dialogs.TransformationDialog',114,'de.java_chess.javaChess.dialogs.TransformationDialog.actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * A method to handle action events coming from the dialog.\r\n *\r\n * @param event\r\n * 		The event that triggered this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    // Get the source of the event.\r\n    Object eventSource = event.getSource();\r\n    // If the user closed the dialog.\r\n    if (eventSource == (_okButton)) {\r\n        setVisible(false);\r\n        return;\r\n    }\r\n    // Check for the radio buttons.\r\n    if (eventSource == (_queenButton)) {\r\n        _pieceType = Piece.QUEEN;\r\n    } else\r\n        if (eventSource == (_rookButton)) {\r\n            _pieceType = Piece.ROOK;\r\n        } else\r\n            if (eventSource == (_knightButton)) {\r\n                _pieceType = Piece.KNIGHT;\r\n            } else\r\n                if (eventSource == (_bishopButton)) {\r\n                    _pieceType = Piece.BISHOP;\r\n                }\r\n\r\n\r\n\r\n}'),(82,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',122,'de.java_chess.javaChess.engine.BitBoardAnalyzer.setBoard(de.java_chess.javaChess.bitboard.BitBoard)',0,'/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(BitBoard board);'),(83,'boolean white','boolean',0,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',123,'de.java_chess.javaChess.engine.BitBoardAnalyzer.setMoveRight(boolean)',0,'/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white has the\r\n * 		next move.\r\n */\r\nvoid setMoveRight(boolean white);'),(84,'boolean white','boolean',0,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',120,'de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(boolean)',0,'/**\r\n * Test if a king is in check.\r\n *\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(boolean white);'),(85,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',121,'de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);'),(86,'boolean white','boolean',0,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',121,'de.java_chess.javaChess.engine.BitBoardAnalyzer.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\nboolean isInCheck(BitBoard board, boolean white);'),(87,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',118,'de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);'),(88,'boolean white','boolean',0,20,'de.java_chess.javaChess.engine.BitBoardAnalyzer',118,'de.java_chess.javaChess.engine.BitBoardAnalyzer.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\nshort analyze(BitBoard board, boolean white);'),(89,'Game game','de.java_chess.javaChess.game.Game',50,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',124,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)',0,'// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * 		A PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}'),(90,'PlyGenerator plyGenerator','de.java_chess.javaChess.engine.PlyGenerator',25,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',124,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.PlyGenerator)',0,'// Constructors\r\n/**\r\n * Create a new bitboard analyzer.\r\n *\r\n * @param plyGenerator\r\n * 		A PlyGenerator instance to simulate moves.\r\n */\r\npublic BitBoardAnalyzerImpl(Game game, PlyGenerator plyGenerator) {\r\n    setGame(game);\r\n    setPlyGenerator(plyGenerator);\r\n}'),(91,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',132,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setBoard(de.java_chess.javaChess.bitboard.BitBoard)',0,'/**\r\n * Set a new board to be analyzed.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(BitBoard board) {\r\n    _board = board;\r\n}'),(92,'Game game','de.java_chess.javaChess.game.Game',50,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',133,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(93,'boolean white','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',134,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setMoveRight(boolean)',0,'/**\r\n * Set the flag, if white is about to move.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white has the\r\n * 		next move.\r\n */\r\npublic final void setMoveRight(boolean white) {\r\n    _whiteMoves = white;\r\n}'),(94,'PlyGenerator plyGenerator','de.java_chess.javaChess.engine.PlyGenerator',25,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',135,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.setPlyGenerator(de.java_chess.javaChess.engine.PlyGenerator)',0,'/**\r\n * Set a new PlyGenerator instance.\r\n *\r\n * @param plyGenerator\r\n * 		The new PlyGenerator instance.\r\n */\r\nprivate final void setPlyGenerator(PlyGenerator plyGenerator) {\r\n    _plyGenerator = plyGenerator;\r\n}'),(95,'boolean white','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',0,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(96,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',131,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}'),(97,'boolean white','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',131,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}'),(98,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',126,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}'),(99,'boolean white','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',126,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}'),(100,'long bitmask','long',0,22,'de.java_chess.javaChess.engine.BitUtils',138,'de.java_chess.javaChess.engine.BitUtils.getHighestBit(long)',0,'/**\r\n * Find the index of highest set bit in a long bitmask.\r\n *\r\n * @param bitmask\r\n * 		The bitmask to operate on.\r\n * @return The index of the highest set bit or 0, if no bits are set.\r\n */\r\npublic static final int getHighestBit(long bitmask) {\r\n    int highestBit = 0;\r\n    // The following 3 statements split the 64 bit word down to\r\n    // a byte.\r\n    int dwordPart = ((int) (bitmask >>> 32));\r\n    if (dwordPart != 0) {\r\n        highestBit += 32;\r\n    } else {\r\n        dwordPart = ((int) (bitmask));\r\n    }\r\n    int wordPart = (dwordPart >>> 16) & 65535;\r\n    if (wordPart != 0) {\r\n        highestBit += 16;\r\n    } else {\r\n        wordPart = dwordPart & 65535;\r\n    }\r\n    int bytePart = (wordPart >>> 8) & 255;\r\n    if (bytePart != 0) {\r\n        highestBit += 8;\r\n    } else {\r\n        bytePart = wordPart & 255;\r\n    }\r\n    // Use the byte as a index for a precomputed array\r\n    // of bit indexes.\r\n    return highestBit + (BitUtils._highestBit[bytePart]);\r\n}'),(101,'Game game','de.java_chess.javaChess.game.Game',50,23,'de.java_chess.javaChess.engine.ChessEngine',148,'de.java_chess.javaChess.engine.ChessEngine.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\nvoid setGame(Game game);'),(102,'Board board','de.java_chess.javaChess.board.Board',13,23,'de.java_chess.javaChess.engine.ChessEngine',147,'de.java_chess.javaChess.engine.ChessEngine.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(Board board);'),(103,'boolean white','boolean',0,23,'de.java_chess.javaChess.engine.ChessEngine',149,'de.java_chess.javaChess.engine.ChessEngine.setWhite(boolean)',0,'/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * 		flag to indicate if the engine operates on the white pieces.\r\n */\r\nvoid setWhite(boolean white);'),(104,'Ply ply','de.java_chess.javaChess.ply.Ply',75,23,'de.java_chess.javaChess.engine.ChessEngine',152,'de.java_chess.javaChess.engine.ChessEngine.validateUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\nboolean validateUserPly(Ply ply);'),(105,'boolean white','boolean',0,23,'de.java_chess.javaChess.engine.ChessEngine',141,'de.java_chess.javaChess.engine.ChessEngine.getCurrentGameState(boolean)',0,'/**\r\n * Get the current game state for a given color.\r\n *\r\n * @param white\r\n * 		True, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\nbyte getCurrentGameState(boolean white);'),(106,'Game game','de.java_chess.javaChess.game.Game',50,24,'de.java_chess.javaChess.engine.ChessEngineImpl',153,'de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)',0,'// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(107,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,24,'de.java_chess.javaChess.engine.ChessEngineImpl',153,'de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)',0,'// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(108,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',153,'de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)',0,'// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(109,'boolean white','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',153,'de.java_chess.javaChess.engine.ChessEngineImpl.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.notation.GameNotation,de.java_chess.javaChess.board.Board,boolean)',0,'// Constructors\r\n/**\r\n * Create a new engine instance with a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param notation\r\n * 		The current notation.\r\n * @param board\r\n * 		The new board.\r\n * @param white\r\n * 		Flag, to indicate if the engine operates on the white pieces.\r\n */\r\npublic ChessEngineImpl(Game game, GameNotation notation, Board board, boolean white) {\r\n    listeners = new ArrayList();\r\n    this.createLogFile();\r\n    setGame(game);\r\n    setBoard(board);\r\n    setWhite(white);\r\n    _hashtable = new PlyHashtableImpl(10000);\r\n    _plyGenerator = new PlyGenerator(getGame(), _hashtable);\r\n    _analyzer = new BitBoardAnalyzerImpl(getGame(), _plyGenerator);\r\n    _plyGenerator.setAnalyzer(_analyzer);\r\n    setPermanentBrain(new PermanentBrain(this));\r\n    startPermanentBrain();\r\n    setOpeningBook(new OpeningBookImpl(notation));\r\n    setInOpeningBook(true);\r\n}'),(110,'Game game','de.java_chess.javaChess.game.Game',50,24,'de.java_chess.javaChess.engine.ChessEngineImpl',188,'de.java_chess.javaChess.engine.ChessEngineImpl.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(111,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',186,'de.java_chess.javaChess.engine.ChessEngineImpl.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set the board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic void setBoard(Board board) {\r\n    _board = board;\r\n}'),(112,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,24,'de.java_chess.javaChess.engine.ChessEngineImpl',189,'de.java_chess.javaChess.engine.ChessEngineImpl.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * 		The new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}'),(113,'PermanentBrain permanentBrain','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',34,24,'de.java_chess.javaChess.engine.ChessEngineImpl',193,'de.java_chess.javaChess.engine.ChessEngineImpl.setPermanentBrain(de.java_chess.javaChess.engine.permanent_brain.PermanentBrain)',0,'/**\r\n * Set a new permanent brain.\r\n *\r\n * @param permanentBrain\r\n * 		The new permanent brain.\r\n */\r\nprivate final void setPermanentBrain(PermanentBrain permanentBrain) {\r\n    _permanentBrain = permanentBrain;\r\n}'),(114,'boolean active','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',155,'de.java_chess.javaChess.engine.ChessEngineImpl.activatePermanentBrain(boolean)',0,'/**\r\n * (De-)activate the permanent brain function.\r\n *\r\n * @param active\r\n * 		Flag to indicate, if the permanent brain function should be used.\r\n */\r\nprivate final void activatePermanentBrain(boolean active) {\r\n    _usePermanentBrain = active;\r\n    // Since the permanent brain is eventually active already, stop it now.\r\n    if (!(usePermanentBrain())) {\r\n        stopPermanentBrain();\r\n    }\r\n    // If the permanent brain is activated, it will be use for the next(!) move.\r\n}'),(115,'int time','int',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',191,'de.java_chess.javaChess.engine.ChessEngineImpl.setMaximumSearchTime(int)',0,'/**\r\n * Set the maximum search time.\r\n *\r\n * @param depth\r\n * 		The new search time.\r\n */\r\npublic final void setMaximumSearchTime(int time) {\r\n    _maxSearchTime = time;\r\n}'),(116,'boolean white','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',197,'de.java_chess.javaChess.engine.ChessEngineImpl.setWhite(boolean)',0,'/**\r\n * Set the color of the engine.\r\n *\r\n * @param white\r\n * 		flag to indicate if the engine operates on the white pieces.\r\n */\r\npublic void setWhite(boolean white) {\r\n    _white = white;\r\n}'),(117,'OpeningBook book','de.java_chess.javaChess.engine.opening_book.OpeningBook',31,24,'de.java_chess.javaChess.engine.ChessEngineImpl',192,'de.java_chess.javaChess.engine.ChessEngineImpl.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)',0,'/**\r\n * Set a new opening book.\r\n *\r\n * @param book\r\n * 		The new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}'),(118,'boolean inBook','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',190,'de.java_chess.javaChess.engine.ChessEngineImpl.setInOpeningBook(boolean)',0,'/**\r\n * Set the flag to indicate, if we are still in the opening book.\r\n *\r\n * @param inBook\r\n * 		true, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final void setInOpeningBook(boolean inBook) {\r\n    _inOpeningBook = inBook;\r\n}'),(119,'boolean white','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',199,'de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)',0,'/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}'),(120,'de.java_chess.javaChess.ply.AnalyzedPly','de.java_chess.javaChess.ply.AnalyzedPly',69,24,'de.java_chess.javaChess.engine.ChessEngineImpl',199,'de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)',1,'/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}'),(121,'Ply lastPly','de.java_chess.javaChess.ply.Ply',75,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(122,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(123,'boolean white','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(124,'int searchLevel','int',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(125,'short alpha','short',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(126,'short beta','short',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',0,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(127,'Board board','de.java_chess.javaChess.board.Board',13,24,'de.java_chess.javaChess.engine.ChessEngineImpl',158,'de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}'),(128,'Ply ply','de.java_chess.javaChess.ply.Ply',75,24,'de.java_chess.javaChess.engine.ChessEngineImpl',203,'de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}'),(129,'boolean stopFlag','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',195,'de.java_chess.javaChess.engine.ChessEngineImpl.setSearchStop(boolean)',0,'/**\r\n * Set the the stop flag for the search.\r\n *\r\n * @param stopFlag\r\n * 		The flag to stop the search engine.\r\n */\r\npublic final void setSearchStop(boolean stopFlag) {\r\n    _stopSearch = stopFlag;\r\n}'),(130,'long analyzedBoards','long',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',185,'de.java_chess.javaChess.engine.ChessEngineImpl.setAnalyzedBoards(long)',0,'/**\r\n * Set the number of analyzed boards.\r\n *\r\n * @param analyzedBoards\r\n * 		The new number of analyzed boards.\r\n */\r\npublic final void setAnalyzedBoards(long analyzedBoards) {\r\n    _analyzedBoards = analyzedBoards;\r\n}'),(131,'int searchDepth','int',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',194,'de.java_chess.javaChess.engine.ChessEngineImpl.setSearchDepth(int)',0,'/**\r\n * Set a new search depth.\r\n *\r\n * @param searchDepth\r\n * 		The new search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}'),(132,'ActionEvent actionEvent','java.awt.event.ActionEvent',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',154,'de.java_chess.javaChess.engine.ChessEngineImpl.actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Perform a action (could be a menu related action).\r\n *\r\n * @param actionEvent\r\n * 		The event.\r\n */\r\npublic final void actionPerformed(ActionEvent actionEvent) {\r\n    // Check, if the user (de-)activated the permanent brain.\r\n    if (actionEvent.getSource().equals(_permanentBrainMenuItem)) {\r\n        activatePermanentBrain(_permanentBrainMenuItem.isSelected());\r\n        this.notifyListeners();\r\n        return;\r\n    }\r\n    // Check if the user has requested a new search time\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        if (actionEvent.getSource().equals(_avSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = false;\r\n        }\r\n        if (actionEvent.getSource().equals(_fixSearchTimeMenuItem[st])) {\r\n            setMaximumSearchTime(((_searchTime[st]) * 1000));\r\n            this.bFixedTime = true;\r\n        }\r\n    }\r\n    // Check, if the user has requested a different hashtable size.\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        if (actionEvent.getSource().equals(_hashtableSizeMenuItem[hts])) {\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n    }\r\n    this.notifyListeners();\r\n}'),(133,'EnginePanel panel','de.java_chess.javaChess.renderer2d.EnginePanel',89,24,'de.java_chess.javaChess.engine.ChessEngineImpl',187,'de.java_chess.javaChess.engine.ChessEngineImpl.setEnginePanel(de.java_chess.javaChess.renderer2d.EnginePanel)',0,'/**\r\n * Sets the EnginePanel to be able to output in the panel and not only with\r\n * System.out.println(...)\r\n *\r\n * @param panel\r\n * 		The EnginePanel to set\r\n */\r\npublic void setEnginePanel(EnginePanel panel) {\r\n    this._enginePanel = panel;\r\n}'),(134,'boolean white','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',164,'de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)',0,'/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * 		True, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}'),(135,'StatusPanel myPanel','de.java_chess.javaChess.renderer2d.StatusPanel',96,24,'de.java_chess.javaChess.engine.ChessEngineImpl',196,'de.java_chess.javaChess.engine.ChessEngineImpl.setStatusPanel(de.java_chess.javaChess.renderer2d.StatusPanel)',0,'public void setStatusPanel(StatusPanel myPanel) {\r\n    if ((this._statusPanel) != myPanel)\r\n        this._statusPanel = myPanel;\r\n\r\n}'),(136,'String text','java.lang.String',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',157,'de.java_chess.javaChess.engine.ChessEngineImpl.addLogEntry(java.lang.String)',0,'/**\r\n * Ads a log entry into the JavaChess logfile\r\n *\r\n * @param text\r\n * 		The text to append\r\n */\r\nprivate void addLogEntry(String text) {\r\n    if ((f) != null) {\r\n        try {\r\n            // First read the existing lines into vBuffer\r\n            BufferedReader bfrIniFile = new BufferedReader(new FileReader(f));\r\n            String strOrgLine = bfrIniFile.readLine();\r\n            vBuffer = new Vector();\r\n            String strLine;\r\n            while (strOrgLine != null) {\r\n                strLine = strOrgLine.trim();\r\n                this.vBuffer.addElement(strLine);\r\n                strOrgLine = bfrIniFile.readLine();\r\n            } \r\n            // now create file new but with same filename\r\n            FileWriter fileWriter = new FileWriter(f);\r\n            PrintWriter printWriter = new PrintWriter(fileWriter);\r\n            // insert former existing text:\r\n            String[] strWrite = new String[vBuffer.size()];\r\n            vBuffer.copyInto(strWrite);\r\n            for (int i = 0; i < (vBuffer.size()); i++) {\r\n                printWriter.println(strWrite[i]);\r\n            }\r\n            // add the new text now:\r\n            printWriter.println(text);\r\n            printWriter.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}'),(137,'EngineStatusListener listener','de.java_chess.javaChess.listener.EngineStatusListener',53,24,'de.java_chess.javaChess.engine.ChessEngineImpl',156,'de.java_chess.javaChess.engine.ChessEngineImpl.addEngineStatusListener(de.java_chess.javaChess.listener.EngineStatusListener)',0,'/**\r\n * Registers an object for notification.\r\n *\r\n * @param listener\r\n * 		The object to be registered.\r\n */\r\npublic void addEngineStatusListener(EngineStatusListener listener) {\r\n    listeners.add(listener);\r\n}'),(138,'Game game','de.java_chess.javaChess.game.Game',50,25,'de.java_chess.javaChess.engine.PlyGenerator',204,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}'),(139,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,25,'de.java_chess.javaChess.engine.PlyGenerator',204,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'// Constructors\r\n/**\r\n * Create a new instance of a ply generator.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, PlyHashtable hashtable) {\r\n    setGame(game);\r\n    setHashtable(hashtable);\r\n    precomputeKnightPlies();\r\n    precomputeKingPlies();\r\n}'),(140,'Game game','de.java_chess.javaChess.game.Game',50,25,'de.java_chess.javaChess.engine.PlyGenerator',205,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param board\r\n * 		The board to operate on.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}'),(141,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,25,'de.java_chess.javaChess.engine.PlyGenerator',205,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param board\r\n * 		The board to operate on.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}'),(142,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,25,'de.java_chess.javaChess.engine.PlyGenerator',205,'de.java_chess.javaChess.engine.PlyGenerator.-init-(de.java_chess.javaChess.game.Game,de.java_chess.javaChess.bitboard.BitBoard,de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Create a new instance of a ply generator\r\n * from a given board.\r\n *\r\n * @param game\r\n * 		The current game.\r\n * @param board\r\n * 		The board to operate on.\r\n * @param hashtable\r\n * 		A hashtable to store the best plies so far.\r\n */\r\npublic PlyGenerator(Game game, BitBoard board, PlyHashtable hashtable) {\r\n    this(game, hashtable);\r\n    setBoard(board);\r\n}'),(143,'Game game','de.java_chess.javaChess.game.Game',50,25,'de.java_chess.javaChess.engine.PlyGenerator',237,'de.java_chess.javaChess.engine.PlyGenerator.setGame(de.java_chess.javaChess.game.Game)',0,'/**\r\n * Set the current game.\r\n *\r\n * @param The\r\n * 		current game.\r\n */\r\npublic final void setGame(Game game) {\r\n    _game = game;\r\n}'),(144,'PlyHashtable hashtable','de.java_chess.javaChess.engine.hashtable.PlyHashtable',26,25,'de.java_chess.javaChess.engine.PlyGenerator',238,'de.java_chess.javaChess.engine.PlyGenerator.setHashtable(de.java_chess.javaChess.engine.hashtable.PlyHashtable)',0,'/**\r\n * Set a new hashtable for this ply generator.\r\n *\r\n * @param hashtable\r\n * 		The new hashtable for this ply generator.\r\n */\r\npublic final void setHashtable(PlyHashtable hashtable) {\r\n    _hashtable = hashtable;\r\n}'),(145,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,25,'de.java_chess.javaChess.engine.PlyGenerator',229,'de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * 		The ply, that lead to the given board.\r\n * @param board\r\n * 		The board with the game position.\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}'),(146,'boolean white','boolean',0,25,'de.java_chess.javaChess.engine.PlyGenerator',229,'de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * 		The ply, that lead to the given board.\r\n * @param board\r\n * 		The board with the game position.\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}'),(147,'boolean white','boolean',0,25,'de.java_chess.javaChess.engine.PlyGenerator',228,'de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(boolean)',0,'/**\r\n * Get the plies for a given game position and color.\r\n *\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(boolean white) {\r\n    resetPlies();\r\n    _white = white;// Store the color of the current player.\r\n\r\n    // Compute some bitmasks, so we dont have to compute them again for each piece type.\r\n    _emptySquares = getBoard().getEmptySquares();// Get the positions of the empty squares.\r\n\r\n    _attackablePieces = (getBoard().getAllPiecesForColor((!(_white)))) & (~(getBoard().getPositionOfPieces((((Piece.KING) << 1) | (_white ? 0 : 1)))));\r\n    // Add the possible plies for all piece types.\r\n    // I tried to sort this list according to the probality for a check, so\r\n    // the analyzer has a better chance to find it early.\r\n    addPliesForKnights();\r\n    addPliesForBishops();\r\n    addPliesForRooks();\r\n    addPliesForQueens();\r\n    addPliesForPawns();\r\n    addPliesForKing();\r\n    // Check, if theres a good ply for this board in the hash table.\r\n    Ply hashtablePly = getHashtable().getPly(getBoard(), _white);\r\n    if (hashtablePly != null) {\r\n        // If so, increase the score of this ply.\r\n        for (int index = 0; index < (_plyCounter); index++) {\r\n            if (_currentPlies[index].getPly().equals(hashtablePly)) {\r\n                _currentPlies[index].setScore(HASHTABLE_PLY);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // Presort the plies\r\n    presortPlies();\r\n    // Convert the plies to a array of the correct size\r\n    Ply[] plies = new Ply[_plyCounter];\r\n    int destIndex = 0;\r\n    for (int sourceIndex = (_plyCounter) - 1; sourceIndex >= 0;) {\r\n        plies[(destIndex++)] = _currentPlies[(sourceIndex--)].getPly();\r\n    }\r\n    return plies;\r\n}'),(148,'int square','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',208,'de.java_chess.javaChess.engine.PlyGenerator.addPliesForBishopPos(int)',0,'/**\r\n * Add the plies for a bishop position.\r\n *\r\n * @param square\r\n * 		The square index of the bishop pos.\r\n */\r\nprivate final void addPliesForBishopPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    int squareRow = square >> 3;\r\n    int squareLine = square & 7;\r\n    long bitmask;\r\n    if (squareRow > 0) {\r\n        // If we are not on row 1\r\n        if (squareLine < 7) {\r\n            // Compute plies to the lower right.\r\n            square -= 7;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 7;\r\n                bitmask >>>= 7;\r\n            } \r\n        }\r\n        if (squareLine > 0) {\r\n            // Compute plies to the lower left.\r\n            square = orgPos - 9;\r\n            bitmask = 1L << square;\r\n            while ((square >= 0) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square -= 9;\r\n                bitmask >>>= 9;\r\n            } \r\n        }\r\n    }\r\n    if (squareRow < 7) {\r\n        if (squareLine > 0) {\r\n            // Compute plies to the upper left.\r\n            square = orgPos + 7;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) != 7)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 7;\r\n                bitmask <<= 7;\r\n            } \r\n        }\r\n        if (squareLine < 7) {\r\n            // Compute plies to the upper right.\r\n            square = orgPos + 9;\r\n            bitmask = 1L << square;\r\n            while ((square < 64) && ((square & 7) > 0)) {\r\n                if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0L) {\r\n                    boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n                    addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n                    // If we attacked a piece, we cannot move further\r\n                    if (capture) {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    break;\r\n                }\r\n                square += 9;\r\n                bitmask <<= 9;\r\n            } \r\n        }\r\n    }\r\n}'),(149,'int square','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',215,'de.java_chess.javaChess.engine.PlyGenerator.addPliesForRookPos(int)',0,'/**\r\n * Add the plies for one rook position.\r\n *\r\n * @param square\r\n * 		The square index of the rook pos.\r\n */\r\nprivate final void addPliesForRookPos(int square) {\r\n    int orgPos = square;// Save the original position.\r\n\r\n    long bitmask;\r\n    // Compute plies to the left.\r\n    bitmask = 1L << square;\r\n    while ((square & 7) > 0) {\r\n        square -= 1;\r\n        bitmask >>>= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies downwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square > 8) {\r\n        square -= 8;\r\n        bitmask >>>= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies to the right.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while ((square & 7) < 7) {\r\n        square += 1;\r\n        bitmask <<= 1;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n    // Compute plies upwards.\r\n    square = orgPos;\r\n    bitmask = 1L << square;\r\n    while (square < 56) {\r\n        square += 8;\r\n        bitmask <<= 8;\r\n        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // If we attacked a piece, we cannot move further\r\n            if (capture) {\r\n                break;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    } \r\n}'),(150,'int square','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',213,'de.java_chess.javaChess.engine.PlyGenerator.addPliesForQueenPos(int)',0,'/**\r\n * Add the plies for one queen position.\r\n *\r\n * @param square\r\n * 		The square index of the queen position.\r\n */\r\nprivate final void addPliesForQueenPos(int square) {\r\n    // Since a queen can move like a bishop or rook,\r\n    // I simply add the plies of both for this position.\r\n    addPliesForBishopPos(square);\r\n    addPliesForRookPos(square);\r\n}'),(151,'long destinationPos','long',0,25,'de.java_chess.javaChess.engine.PlyGenerator',220,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(152,'int startBit','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',220,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(153,'int endBit','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',220,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(154,'int offset','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',220,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesUpward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n * We pass the destination fields here along with a offset to compute the source square.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {\r\n    // Compute a bitmask to mask the bits in the destination bitfield.\r\n    long bitmask = 1L << startBit;\r\n    // End the loop also if the bitmask is 0, so there are no more destination fields\r\n    // in the bitmask (so we dont have to check the entire chessboard for plies).\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        // If the bit of the destination square is set, its the destination for a ply.\r\n        if ((destinationPos & bitmask) != 0) {\r\n            // Add the ply to the buffer.\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            // Remove the bit, so we can check if there are more plies to find.\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(155,'long destinationPos','long',0,25,'de.java_chess.javaChess.engine.PlyGenerator',219,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}'),(156,'int startBit','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',219,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}'),(157,'int endBit','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',219,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}'),(158,'int offset','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',219,'de.java_chess.javaChess.engine.PlyGenerator.addRelativePliesDownward(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of relative plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int offset The offset for each ply.\r\n */\r\nprivate final void addRelativePliesDownward(long destinationPos, int startBit, int endBit, int offset) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit >= endBit) && (destinationPos != 0); currentBit--) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask >>>= 1;\r\n    }\r\n}'),(159,'long destinationPos','long',0,25,'de.java_chess.javaChess.engine.PlyGenerator',206,'de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(160,'int startBit','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',206,'de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(161,'int endBit','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',206,'de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(162,'int pos','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',206,'de.java_chess.javaChess.engine.PlyGenerator.addAbsolutePlies(long,int,int,int)',0,'/**\r\n * Convert a bitmask to a series of absolute plies.\r\n *\r\n * @param destinationPos\r\n * 		The destination positions for all the plies.\r\n * @param int\r\n * 		startBit The bit to start scanning from.\r\n * @param int\r\n * 		endBit The bit to end the scanning at.\r\n * 		int pos The source for each ply.\r\n */\r\nprivate final void addAbsolutePlies(long destinationPos, int startBit, int endBit, int pos) {\r\n    long bitmask = 1L << startBit;\r\n    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {\r\n        if ((destinationPos & bitmask) != 0) {\r\n            boolean capture = (bitmask & (_attackablePieces)) != 0L;\r\n            addRegularPly(pos, currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));\r\n            destinationPos &= ~bitmask;\r\n        }\r\n        bitmask <<= 1;\r\n    }\r\n}'),(163,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,25,'de.java_chess.javaChess.engine.PlyGenerator',236,'de.java_chess.javaChess.engine.PlyGenerator.setBoard(de.java_chess.javaChess.bitboard.BitBoard)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nfinal void setBoard(BitBoard board) {\r\n    _board = board;\r\n}'),(164,'BitBoardAnalyzer analyzer','de.java_chess.javaChess.engine.BitBoardAnalyzer',20,25,'de.java_chess.javaChess.engine.PlyGenerator',235,'de.java_chess.javaChess.engine.PlyGenerator.setAnalyzer(de.java_chess.javaChess.engine.BitBoardAnalyzer)',0,'/**\r\n * Set the last ply.\r\n *\r\n * @param lastPly\r\n * 		The last ply.\r\n */\r\n/* final void setLastPly( Ply lastPly) {\n// _lastPly = lastPly;\n}\n */\r\n/**\r\n * Set a analyzer for check tests.\r\n *\r\n * @param analyzer\r\n * 		The new analyzer to set.\r\n */\r\npublic final void setAnalyzer(BitBoardAnalyzer analyzer) {\r\n    _analyzer = analyzer;\r\n}'),(165,'Ply ply','de.java_chess.javaChess.ply.Ply',75,25,'de.java_chess.javaChess.engine.PlyGenerator',217,'de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)',0,'/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * 		The ply to add.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}'),(166,'short score','short',0,25,'de.java_chess.javaChess.engine.PlyGenerator',217,'de.java_chess.javaChess.engine.PlyGenerator.addPly(de.java_chess.javaChess.ply.Ply,short)',0,'/**\r\n * Add a ply to the buffer, if the own king is not in check after the ply.\r\n *\r\n * @param ply\r\n * 		The ply to add.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addPly(Ply ply, short score) {\r\n    // Test if the own king is in check, before adding the ply\r\n    if (!(getAnalyzer().isInCheck(((BitBoard) (getBoard().getBoardAfterPly(ply))), _white))) {\r\n        _currentPlies[((_plyCounter)++)] = new AnalyzedPlyImpl(ply, score);\r\n    }\r\n}'),(167,'int source','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',218,'de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)',0,'/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}'),(168,'int destination','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',218,'de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)',0,'/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}'),(169,'boolean capture','boolean',0,25,'de.java_chess.javaChess.engine.PlyGenerator',218,'de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)',0,'/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}'),(170,'short score','short',0,25,'de.java_chess.javaChess.engine.PlyGenerator',218,'de.java_chess.javaChess.engine.PlyGenerator.addRegularPly(int,int,boolean,short)',0,'/**\r\n * Add a regular ply.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addRegularPly(int source, int destination, boolean capture, short score) {\r\n    addPly(new PlyImpl(new PositionImpl(source), new PositionImpl(destination), capture), score);\r\n}'),(171,'int source','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',207,'de.java_chess.javaChess.engine.PlyGenerator.addCastlingPly(int,boolean)',0,'/**\r\n * Add a castling ply.\r\n *\r\n * @param source\r\n * 		The position square of the king.\r\n * @param goesLeft\r\n * 		The flag that indicates if the castling goes to the left.\r\n */\r\nprivate final void addCastlingPly(int source, boolean goesLeft) {\r\n    addPly(new CastlingPlyImpl(new PositionImpl(source), goesLeft), REGULAR_PLY);\r\n}'),(172,'boolean goesLeft','boolean',0,25,'de.java_chess.javaChess.engine.PlyGenerator',207,'de.java_chess.javaChess.engine.PlyGenerator.addCastlingPly(int,boolean)',0,'/**\r\n * Add a castling ply.\r\n *\r\n * @param source\r\n * 		The position square of the king.\r\n * @param goesLeft\r\n * 		The flag that indicates if the castling goes to the left.\r\n */\r\nprivate final void addCastlingPly(int source, boolean goesLeft) {\r\n    addPly(new CastlingPlyImpl(new PositionImpl(source), goesLeft), REGULAR_PLY);\r\n}'),(173,'int source','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',221,'de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)',0,'/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * 		The source square of the old piece.\r\n * @param destination\r\n * 		The destination square of the piece.\r\n * @param pieceType\r\n * 		The new piece type after the ply.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}'),(174,'int destination','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',221,'de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)',0,'/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * 		The source square of the old piece.\r\n * @param destination\r\n * 		The destination square of the piece.\r\n * @param pieceType\r\n * 		The new piece type after the ply.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}'),(175,'byte pieceType','byte',0,25,'de.java_chess.javaChess.engine.PlyGenerator',221,'de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)',0,'/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * 		The source square of the old piece.\r\n * @param destination\r\n * 		The destination square of the piece.\r\n * @param pieceType\r\n * 		The new piece type after the ply.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}'),(176,'boolean capture','boolean',0,25,'de.java_chess.javaChess.engine.PlyGenerator',221,'de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)',0,'/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * 		The source square of the old piece.\r\n * @param destination\r\n * 		The destination square of the piece.\r\n * @param pieceType\r\n * 		The new piece type after the ply.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}'),(177,'short score','short',0,25,'de.java_chess.javaChess.engine.PlyGenerator',221,'de.java_chess.javaChess.engine.PlyGenerator.addTransformationPly(int,int,byte,boolean,short)',0,'/**\r\n * Add a transformation ply.\r\n *\r\n * @param source\r\n * 		The source square of the old piece.\r\n * @param destination\r\n * 		The destination square of the piece.\r\n * @param pieceType\r\n * 		The new piece type after the ply.\r\n * @param capture\r\n * 		Flag to indicate if another piece is captured.\r\n * @param score\r\n * 		The presort score of this ply.\r\n */\r\nprivate final void addTransformationPly(int source, int destination, byte pieceType, boolean capture, short score) {\r\n    addPly(new TransformationPlyImpl(new PositionImpl(source), new PositionImpl(destination), pieceType, capture), score);\r\n}'),(178,'int square','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',226,'de.java_chess.javaChess.engine.PlyGenerator.getKnightPlies(int)',0,'/**\r\n * Get the knight plies for a given knight square.\r\n *\r\n * @param square\r\n * 		The square, where the knight is located.\r\n * @return All the knight plies as a 64 bit bitmask.\r\n */\r\npublic final long getKnightPlies(int square) {\r\n    return _knightMask[square];\r\n}'),(179,'int l','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',233,'de.java_chess.javaChess.engine.PlyGenerator.quickersort(int,int)',0,'/**\r\n * Perform a combined quick-/shakersort on a ply partition.\r\n *\r\n * @param l\r\n * 		The left bound of the array partition.\r\n * @param r\r\n * 		The right bound of the array partition.\r\n */\r\nprivate final void quickersort(int l, int r) {\r\n    int i = l;\r\n    int j = r;\r\n    AnalyzedPly x = _currentPlies[((l + r) / 2)];\r\n    do {\r\n        while ((_currentPlies[i].getScore()) > (x.getScore())) {\r\n            i++;\r\n        } \r\n        while ((x.getScore()) > (_currentPlies[j].getScore())) {\r\n            j--;\r\n        } \r\n        if (i <= j) {\r\n            AnalyzedPly w = _currentPlies[i];\r\n            _currentPlies[(i++)] = _currentPlies[j];\r\n            _currentPlies[(j--)] = w;\r\n        }\r\n    } while (i <= j );\r\n    if (l < j) {\r\n        if ((l - j) > 7) {\r\n            quickersort(l, j);\r\n        } else {\r\n            shakersort(l, j);\r\n        }\r\n    }\r\n    if (i < r) {\r\n        if ((r - i) > 7) {\r\n            quickersort(i, r);\r\n        } else {\r\n            shakersort(i, r);\r\n        }\r\n    }\r\n}'),(180,'int r','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',233,'de.java_chess.javaChess.engine.PlyGenerator.quickersort(int,int)',0,'/**\r\n * Perform a combined quick-/shakersort on a ply partition.\r\n *\r\n * @param l\r\n * 		The left bound of the array partition.\r\n * @param r\r\n * 		The right bound of the array partition.\r\n */\r\nprivate final void quickersort(int l, int r) {\r\n    int i = l;\r\n    int j = r;\r\n    AnalyzedPly x = _currentPlies[((l + r) / 2)];\r\n    do {\r\n        while ((_currentPlies[i].getScore()) > (x.getScore())) {\r\n            i++;\r\n        } \r\n        while ((x.getScore()) > (_currentPlies[j].getScore())) {\r\n            j--;\r\n        } \r\n        if (i <= j) {\r\n            AnalyzedPly w = _currentPlies[i];\r\n            _currentPlies[(i++)] = _currentPlies[j];\r\n            _currentPlies[(j--)] = w;\r\n        }\r\n    } while (i <= j );\r\n    if (l < j) {\r\n        if ((l - j) > 7) {\r\n            quickersort(l, j);\r\n        } else {\r\n            shakersort(l, j);\r\n        }\r\n    }\r\n    if (i < r) {\r\n        if ((r - i) > 7) {\r\n            quickersort(i, r);\r\n        } else {\r\n            shakersort(i, r);\r\n        }\r\n    }\r\n}'),(181,'int l','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',239,'de.java_chess.javaChess.engine.PlyGenerator.shakersort(int,int)',0,'/**\r\n * Perform a shakersort on a ply partition.\r\n *\r\n * @param l\r\n * 		The left bound of the ply partition.\r\n * @param r\r\n * 		The right bound of the ply partition.\r\n */\r\nprivate final void shakersort(int l, int r) {\r\n    int i = l + 1;\r\n    int j = r;\r\n    int k = r;\r\n    do {\r\n        for (int h = j; h >= i; h--) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        i = k + 1;\r\n        for (int h = i; h <= j; h++) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        j = k - 1;\r\n    } while (i <= j );\r\n}'),(182,'int r','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',239,'de.java_chess.javaChess.engine.PlyGenerator.shakersort(int,int)',0,'/**\r\n * Perform a shakersort on a ply partition.\r\n *\r\n * @param l\r\n * 		The left bound of the ply partition.\r\n * @param r\r\n * 		The right bound of the ply partition.\r\n */\r\nprivate final void shakersort(int l, int r) {\r\n    int i = l + 1;\r\n    int j = r;\r\n    int k = r;\r\n    do {\r\n        for (int h = j; h >= i; h--) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        i = k + 1;\r\n        for (int h = i; h <= j; h++) {\r\n            if ((_currentPlies[(h - 1)].getScore()) < (_currentPlies[h].getScore())) {\r\n                AnalyzedPly w = _currentPlies[(h - 1)];\r\n                _currentPlies[(h - 1)] = _currentPlies[h];\r\n                _currentPlies[h] = w;\r\n                k = h;\r\n            }\r\n        }\r\n        j = k - 1;\r\n    } while (i <= j );\r\n}'),(183,'int maximumEntries','int',0,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',246,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.setMaximumSize(int)',0,'/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * 		The new maximum number of entries.\r\n */\r\nvoid setMaximumSize(int maximumEntries);'),(184,'PlyHashtableEntry ply','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry',27,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',243,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)',0,'/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * 		The new entry, that the hashtable might store.\r\n */\r\nvoid pushEntry(PlyHashtableEntry ply);'),(185,'Board board','de.java_chess.javaChess.board.Board',13,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',241,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The board before the move.\r\n * @param white\r\n * 		Flag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);'),(186,'de.java_chess.javaChess.ply.Ply','de.java_chess.javaChess.ply.Ply',75,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',241,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)',1,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The board before the move.\r\n * @param white\r\n * 		Flag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);'),(187,'boolean white','boolean',0,26,'de.java_chess.javaChess.engine.hashtable.PlyHashtable',241,'de.java_chess.javaChess.engine.hashtable.PlyHashtable.getPly(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The board before the move.\r\n * @param white\r\n * 		Flag to indicate, if we want a move with the white pieces.\r\n */\r\nPly getPly(Board board, boolean white);'),(188,'Board board','de.java_chess.javaChess.board.Board',13,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',252,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)',0,'// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * 		The board before the ply.\r\n * @param ply\r\n * 		The ply to store.\r\n * @param searchDepth\r\n * 		The search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(189,'Ply ply','de.java_chess.javaChess.ply.Ply',75,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',252,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)',0,'// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * 		The board before the ply.\r\n * @param ply\r\n * 		The ply to store.\r\n * @param searchDepth\r\n * 		The search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(190,'int searchDepth','int',0,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',252,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.-init-(de.java_chess.javaChess.board.Board,de.java_chess.javaChess.ply.Ply,int)',0,'// Constructors\r\n/**\r\n * Create a new hashtable entry.\r\n *\r\n * @param board\r\n * 		The board before the ply.\r\n * @param ply\r\n * 		The ply to store.\r\n * @param searchDepth\r\n * 		The search depth, that was used to compute the ply.\r\n */\r\npublic PlyHashtableEntryImpl(Board board, Ply ply, int searchDepth) {\r\n    setBoard(board);\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(191,'Board board','de.java_chess.javaChess.board.Board',13,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',259,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board for this entry.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}'),(192,'Ply ply','de.java_chess.javaChess.ply.Ply',75,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',260,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply.\r\n *\r\n * @param ply\r\n * 		The ply to set.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(193,'int searchDepth','int',0,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',261,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.setSearchDepth(int)',0,'/**\r\n * Set the search depth for the computed ply.\r\n *\r\n * @param searchDepth\r\n * 		The search depth.\r\n */\r\npublic final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}'),(194,'Board board','de.java_chess.javaChess.board.Board',13,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',257,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}'),(195,'boolean white','boolean',0,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',257,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}'),(196,'int maxSize','int',0,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',262,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.-init-(int)',0,'// Constructors\r\n/**\r\n * Create a new hashtable instance with a given maximum size.\r\n *\r\n * @param maxSize\r\n * 		The maximum number of entries.\r\n */\r\npublic PlyHashtableImpl(int maxSize) {\r\n    _hashtable = new Hashtable();\r\n    _orderedList = new LinkedList();\r\n    setMaximumSize(maxSize);\r\n}'),(197,'int maximumEntries','int',0,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',269,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.setMaximumSize(int)',0,'/**\r\n * Set the maximum number of entries in the hashtable.\r\n *\r\n * @param maximumEntries\r\n * 		The new maximum number of entries.\r\n */\r\npublic final void setMaximumSize(int maximumEntries) {\r\n    _maxSize = maximumEntries;\r\n    // Remove the oldest entries, if the current size\r\n    // is bigger than the new maximum size.\r\n    while ((getSize()) > (getMaximumSize())) {\r\n        removeOldestEntry();\r\n    } \r\n}'),(198,'PlyHashtableEntry ply','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry',27,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',266,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.pushEntry(de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry)',0,'/**\r\n * Try to push a new entry into the hashtable.\r\n *\r\n * @param entry\r\n * 		The new entry, that the hashtable might store.\r\n */\r\npublic final void pushEntry(PlyHashtableEntry ply) {\r\n    // Compute and store the key for this ply.\r\n    Long hashKey = new Long(ply.hashKey());\r\n    // Check if this ply is not already in the hashtable\r\n    PlyHashtableEntry oldEntry = ((PlyHashtableEntry) (_hashtable.get(hashKey)));\r\n    if (oldEntry != null) {\r\n        // There is a entry with the same key\r\n        if ((oldEntry.getSearchDepth()) >= (ply.getSearchDepth())) {\r\n            return;// This entry shouldnt be replaced.\r\n\r\n        }\r\n    } else {\r\n        // Now we actually add a new entry to the table.\r\n        // Check, if the hashtable has not exceeded its maximum capacity\r\n        // and remove older entries, if necessary.\r\n        while ((getSize()) >= (getMaximumSize())) {\r\n            removeOldestEntry();\r\n        } \r\n    }\r\n    // Put the new ply into the hashtable\r\n    _hashtable.put(hashKey, ply);\r\n    // Append the new ply at the end of the list of plies.\r\n    // ATTENTION: this will only work, if theres only _one_\r\n    // ply for each key!\r\n    _orderedList.add(hashKey);\r\n}'),(199,'Board board','de.java_chess.javaChess.board.Board',13,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',264,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(200,'de.java_chess.javaChess.ply.Ply','de.java_chess.javaChess.ply.Ply',75,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',264,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)',1,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(201,'boolean white','boolean',0,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',264,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)',0,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(202,'BitBoard board','de.java_chess.javaChess.bitboard.BitBoard',11,30,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl',271,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		Flag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}'),(203,'boolean white','boolean',0,30,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl',271,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)',0,'/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		Flag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}'),(204,'Ply ply','de.java_chess.javaChess.ply.Ply',75,31,'de.java_chess.javaChess.engine.opening_book.OpeningBook',274,'de.java_chess.javaChess.engine.opening_book.OpeningBook.doUserPly(de.java_chess.javaChess.ply.Ply)',0,'// Methods\r\n/**\r\n * Advance the game by one user ply.\r\n *\r\n * @param ply\r\n * 		The ply from the user.\r\n */\r\nvoid doUserPly(Ply ply);'),(205,'File file','java.io.File',0,31,'de.java_chess.javaChess.engine.opening_book.OpeningBook',273,'de.java_chess.javaChess.engine.opening_book.OpeningBook.addPGNopening(java.io.File)',0,'/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * 		The File to add to the opening book.\r\n */\r\nvoid addPGNopening(File file);'),(206,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',277,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'// Constructors\r\n/**\r\n * Create a new instance of this class.\r\n *\r\n * @param notation\r\n * 		The notation of the current game.\r\n */\r\npublic OpeningBookImpl(GameNotation notation) {\r\n    setNotation(notation);\r\n    // Create a new dynamic array for the openings.\r\n    _openings = new ArrayList();\r\n    // Reset the opening book.\r\n    reset();\r\n}'),(207,'Ply ply','de.java_chess.javaChess.ply.Ply',75,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',279,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.doUserPly(de.java_chess.javaChess.ply.Ply)',0,'// Methods\r\n/**\r\n * The user just did a ply.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n */\r\npublic final void doUserPly(Ply ply) {\r\n    // If we are already in a opening, check if the current user\r\n    // move doesnt lead us out of the opening line.\r\n    if ((_currentOpening) != (-1)) {\r\n        if (!(isInOpening(_currentOpening))) {\r\n            _currentOpening = -1;\r\n        }\r\n    }\r\n}'),(208,'File file','java.io.File',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',278,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.addPGNopening(java.io.File)',0,'/**\r\n * Add a opening in PGN format to the opening book and return\r\n * the error status.\r\n *\r\n * @param file\r\n * 		The File to add to the opening book.\r\n */\r\npublic final void addPGNopening(File file) {\r\n    try {\r\n        PGNFile pgnFile = new PGNFile(new BufferedReader(new FileReader(file)));\r\n        GameNotation notation = pgnFile.readGame();\r\n        _openings.add(notation);\r\n        // System.out.println( \"DEBUG: added opening \n\" + notation.toString());\r\n    } catch (FileNotFoundException fe) {\r\n        JOptionPane.showMessageDialog(null, ((\"File \" + (file.getName())) + \" not found!\"), \"File not found\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (IOException ioe) {\r\n        JOptionPane.showMessageDialog(null, ((\"IO error while parsing file \" + (file.getName())) + \"!\"), \"IO error\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (RecognitionException re) {\r\n        JOptionPane.showMessageDialog(null, ((\"Error while parsing file \" + (file.getName())) + \"!\"), \"Error in PGN file\", JOptionPane.ERROR_MESSAGE);\r\n    } catch (TokenStreamException te) {\r\n        System.err.print(\"Tokenstream exception\");\r\n    }\r\n}'),(209,'int openingIndex','int',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',283,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)',0,'/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * 		The index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}'),(210,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',285,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.setNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set the notation of the current game.\r\n *\r\n * @param notation\r\n * 		The notation of the current game.\r\n */\r\nprivate final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}'),(211,'OpeningBook book','de.java_chess.javaChess.engine.opening_book.OpeningBook',31,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',286,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.-init-(de.java_chess.javaChess.engine.opening_book.OpeningBook)',0,'// Constructors\r\n/**\r\n * Create a new action instance.\r\n *\r\n * @param book\r\n * 		The opening book, we are operating on.\r\n */\r\npublic LoadOpeningsAction(OpeningBook book) {\r\n    super(\"Load openings from PGN...\");\r\n    setOpeningBook(book);\r\n}'),(212,'ActionEvent event','java.awt.event.ActionEvent',0,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',287,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.actionPerformed(java.awt.event.ActionEvent)',0,'// Methods\r\n/**\r\n * The actual action.\r\n *\r\n * @param event\r\n * 		The event, that caused this action.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    JFileChooser chooser = new JFileChooser();\r\n    chooser.setDialogTitle(\"Load opening from pgn files\");\r\n    chooser.setFileFilter(SaveGameAsAction.getPGNFileFilter());\r\n    // Allow the user to select directories.\r\n    chooser.setFileSelectionMode(JFileChooser.FILES_AND_DIRECTORIES);\r\n    int retval = chooser.showOpenDialog(null);\r\n    if (retval == (JFileChooser.APPROVE_OPTION)) {\r\n        File file = chooser.getSelectedFile();\r\n        processFileOrDirectory(file);\r\n    }\r\n}'),(213,'File file','java.io.File',0,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',289,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processFileOrDirectory(java.io.File)',0,'/**\r\n * Process a file or directory.\r\n *\r\n * @param file\r\n * 		The file to process.\r\n */\r\nprivate final void processFileOrDirectory(File file) {\r\n    // If this file is a directory, read all the files in it.\r\n    if (file.isDirectory()) {\r\n        String[] files = file.list();// Get the content of the directory\r\n\r\n        // Now create an absolute file from each name and process it.\r\n        for (int i = 0; i < (files.length); i++) {\r\n            processFileOrDirectory(new File(file, files[i]));\r\n        }\r\n    } else {\r\n        // This is a single file, so\r\n        // check, if it might be a PGN file.\r\n        if (SaveGameAsAction.getPGNFileFilter().accept(file)) {\r\n            processPGNfile(file);\r\n        }\r\n    }\r\n}'),(214,'File file','java.io.File',0,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',290,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.processPGNfile(java.io.File)',0,'/**\r\n * Process a single PGN file.\r\n *\r\n * @param file\r\n * 		The PGN file to process.\r\n */\r\nprivate final void processPGNfile(File file) {\r\n    getOpeningBook().addPGNopening(file);\r\n}'),(215,'OpeningBook book','de.java_chess.javaChess.engine.opening_book.OpeningBook',31,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',291,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.setOpeningBook(de.java_chess.javaChess.engine.opening_book.OpeningBook)',0,'/**\r\n * Set the opening book, we are operating on.\r\n *\r\n * @param book\r\n * 		The new opening book.\r\n */\r\nprivate final void setOpeningBook(OpeningBook book) {\r\n    _openingBook = book;\r\n}'),(216,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',292,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.-init-(de.java_chess.javaChess.engine.ChessEngine)',0,'// Constructors\r\n/**\r\n * Create a new PermanentBrain instance.\r\n *\r\n * @param engine\r\n * 		The used chess engine.\r\n */\r\npublic PermanentBrain(ChessEngine engine) {\r\n    setEngine(engine);\r\n}'),(217,'ChessEngine engine','de.java_chess.javaChess.engine.ChessEngine',23,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',298,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.setEngine(de.java_chess.javaChess.engine.ChessEngine)',0,'/**\r\n * Set a new chess engine.\r\n *\r\n * @param engine\r\n * 		The new chess engine.\r\n */\r\nprivate final void setEngine(ChessEngine engine) {\r\n    _engine = engine;\r\n}'),(218,'Ply ply','de.java_chess.javaChess.ply.Ply',75,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',294,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * 		The ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}'),(219,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPly','de.java_chess.javaChess.engine.permanent_brain.PreComputedPly',35,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',294,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * 		The ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}'),(220,'AnalyzedPly ply','de.java_chess.javaChess.ply.AnalyzedPly',69,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',303,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)',0,'// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * 		The computed ply.\r\n * @param searchDepth\r\n * 		The used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(221,'int searchDepth','int',0,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',303,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.-init-(de.java_chess.javaChess.ply.AnalyzedPly,int)',0,'// Constructors\r\n/**\r\n * Create a new instance of a computed ply.\r\n *\r\n * @param ply\r\n * 		The computed ply.\r\n * @param searchDepth\r\n * 		The used search depth.\r\n */\r\npublic PreComputedPlyImpl(AnalyzedPly ply, int searchDepth) {\r\n    setPly(ply);\r\n    setSearchDepth(searchDepth);\r\n}'),(222,'AnalyzedPly ply','de.java_chess.javaChess.ply.AnalyzedPly',69,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',306,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setPly(de.java_chess.javaChess.ply.AnalyzedPly)',0,'/**\r\n * Set the computed ply.\r\n *\r\n * @param ply\r\n * 		The computed ply.\r\n */\r\nprivate final void setPly(AnalyzedPly ply) {\r\n    _ply = ply;\r\n}'),(223,'int searchDepth','int',0,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',307,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.setSearchDepth(int)',0,'/**\r\n * Set the used search depth.\r\n *\r\n * @param searchDepth\r\n * 		The used search depth.\r\n */\r\nprivate final void setSearchDepth(int searchDepth) {\r\n    _searchDepth = searchDepth;\r\n}'),(224,'Ply ply','de.java_chess.javaChess.ply.Ply',75,38,'de.java_chess.javaChess.engine.test.AnalyzerTest2',314,'de.java_chess.javaChess.engine.test.AnalyzerTest2.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(225,'Ply ply','de.java_chess.javaChess.ply.Ply',75,39,'de.java_chess.javaChess.engine.test.BoardConsistencyTest1',321,'de.java_chess.javaChess.engine.test.BoardConsistencyTest1.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(226,'Ply ply','de.java_chess.javaChess.ply.Ply',75,42,'de.java_chess.javaChess.engine.test.MinimaxTest1',331,'de.java_chess.javaChess.engine.test.MinimaxTest1.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(227,'Ply ply','de.java_chess.javaChess.ply.Ply',75,43,'de.java_chess.javaChess.engine.test.MinimaxTest2',336,'de.java_chess.javaChess.engine.test.MinimaxTest2.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(228,'Ply ply','de.java_chess.javaChess.ply.Ply',75,44,'de.java_chess.javaChess.engine.test.PlyGeneratorTest1',341,'de.java_chess.javaChess.engine.test.PlyGeneratorTest1.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(229,'Ply ply','de.java_chess.javaChess.ply.Ply',75,45,'de.java_chess.javaChess.engine.test.PlyGeneratorTest2',346,'de.java_chess.javaChess.engine.test.PlyGeneratorTest2.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(230,'Ply ply','de.java_chess.javaChess.ply.Ply',75,46,'de.java_chess.javaChess.engine.test.PlyGeneratorTest3',351,'de.java_chess.javaChess.engine.test.PlyGeneratorTest3.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(231,'Ply ply','de.java_chess.javaChess.ply.Ply',75,47,'de.java_chess.javaChess.engine.test.PlyGeneratorTest4',356,'de.java_chess.javaChess.engine.test.PlyGeneratorTest4.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(232,'Ply ply','de.java_chess.javaChess.ply.Ply',75,48,'de.java_chess.javaChess.engine.test.PlyGeneratorTest5',361,'de.java_chess.javaChess.engine.test.PlyGeneratorTest5.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(233,'Ply ply','de.java_chess.javaChess.ply.Ply',75,49,'de.java_chess.javaChess.engine.test.PlyGeneratorTest6',366,'de.java_chess.javaChess.engine.test.PlyGeneratorTest6.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n */\r\nprivate void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n}'),(234,'Ply ply','de.java_chess.javaChess.ply.Ply',75,50,'de.java_chess.javaChess.game.Game',370,'de.java_chess.javaChess.game.Game.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Add a new ply to the game.\r\n *\r\n * @unknown The new ply.\r\n */\r\nvoid doPly(Ply ply);'),(235,'Position position','de.java_chess.javaChess.position.Position',80,50,'de.java_chess.javaChess.game.Game',373,'de.java_chess.javaChess.game.Game.hasBeenMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * 		The position to check.\r\n */\r\nboolean hasBeenMoved(Position position);'),(236,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',388,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,long)',0,'// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * 		The ply for this game status.\r\n * @param bitmask\r\n * 		The moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}'),(237,'long bitmask','long',0,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',388,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,long)',0,'// Constructors\r\n/**\r\n * Create a game status from a ply and a moved pieces bitmask.\r\n *\r\n * @param ply\r\n * 		The ply for this game status.\r\n * @param bitmask\r\n * 		The moved pieces _before_ this ply.\r\n */\r\nGameStatus(Ply ply, long bitmask) {\r\n    // Store the ply in an instance variable.\r\n    setPly(ply);\r\n    // Store the moved pieces of the previous game status.\r\n    setMovedPieces(bitmask);\r\n    // And store the moved piece of the current ply.\r\n    setMoved(ply.getSource());\r\n}'),(238,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',389,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Create a first game status.\r\n *\r\n * @param ply\r\n * 		The first ply of this game.\r\n */\r\nGameStatus(Ply ply) {\r\n    // Construct a new instance from this ply and all\r\n    // pieces on their initial positions.\r\n    this(ply, 0L);\r\n}'),(239,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',390,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)',0,'/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * 		The previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}'),(240,'GameImpl.GameStatus previousStatus','de.java_chess.javaChess.game.GameImpl$GameStatus',51,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',390,'de.java_chess.javaChess.game.GameImpl$GameStatus.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.game.GameImpl$GameStatus)',0,'/**\r\n * Create a new game status from a preceeding status and a ply.\r\n *\r\n * @param status\r\n * 		The previous game status.\r\n */\r\nGameStatus(Ply ply, GameImpl.GameStatus previousStatus) {\r\n    // Create a new instance from this ply and the\r\n    // previous game status.\r\n    this(ply, previousStatus.getMovedPieces());\r\n}'),(241,'Ply ply','de.java_chess.javaChess.ply.Ply',75,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',396,'de.java_chess.javaChess.game.GameImpl$GameStatus.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply, that lead to this game status.\r\n *\r\n * @param ply\r\n * 		The ply, that lead to this game status.\r\n */\r\nfinal void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(242,'Position position','de.java_chess.javaChess.position.Position',80,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',394,'de.java_chess.javaChess.game.GameImpl$GameStatus.setMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Mark a piece moved from its initial position.\r\n *\r\n * @param position\r\n * 		The position of the moved piece.\r\n */\r\nprivate final void setMoved(Position position) {\r\n    _movedPieces |= 1L << (position.getSquareIndex());\r\n}'),(243,'long bitmask','long',0,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',395,'de.java_chess.javaChess.game.GameImpl$GameStatus.setMovedPieces(long)',0,'/**\r\n * Set the bitmask for the moved pieces.\r\n *\r\n * @param bitmask\r\n * 		The new bitmask for the moved pieces.\r\n */\r\nprivate final void setMovedPieces(long bitmask) {\r\n    _movedPieces = bitmask;\r\n}'),(244,'Position position','de.java_chess.javaChess.position.Position',80,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',393,'de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}'),(245,'Ply ply','de.java_chess.javaChess.ply.Ply',75,52,'de.java_chess.javaChess.game.GameImpl',380,'de.java_chess.javaChess.game.GameImpl.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Do a new ply in this game.\r\n *\r\n * @param ply\r\n * 		The next ply.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    // Add a new game status, that derives from the previous status.\r\n    _gameStatus.push(((getLastGameStatus()) == null ? new GameImpl.GameStatus(ply) : new GameImpl.GameStatus(ply, getLastGameStatus())));\r\n}'),(246,'Position position','de.java_chess.javaChess.position.Position',80,52,'de.java_chess.javaChess.game.GameImpl',384,'de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * 		The position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}'),(247,'ChessEngineImpl engine','de.java_chess.javaChess.engine.ChessEngineImpl',24,53,'de.java_chess.javaChess.listener.EngineStatusListener',397,'de.java_chess.javaChess.listener.EngineStatusListener.engineStatusChanged(de.java_chess.javaChess.engine.ChessEngineImpl)',0,'public void engineStatusChanged(ChessEngineImpl engine);'),(248,'ActionEvent e','java.awt.event.ActionEvent',0,54,'de.java_chess.javaChess.menu.EditMenu',399,'de.java_chess.javaChess.menu.EditMenu.actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Interface method. Currently displays input dialogs to edit white and black player\r\n * names\r\n *\r\n * @param e\r\n * 		The action event\r\n */\r\npublic void actionPerformed(ActionEvent e) {\r\n    if (e.getSource().equals(jmiEditPosition)) {\r\n        SetupBoardDialog setupBoardDialog = new SetupBoardDialog();\r\n        Tools.setDialogToCenter(setupBoardDialog);\r\n        setupBoardDialog.setModal(true);\r\n        setupBoardDialog.show();\r\n    } else {\r\n        if ((notationPanel) != null) {\r\n            PlayerDialog playerDialog = null;\r\n            boolean bWhiteOrBlack = true;\r\n            if (e.getSource().equals(jmiWhitePlayerName)) {\r\n                playerDialog = new PlayerDialog(1, notationPanel.getWhitePlayerName());\r\n                bWhiteOrBlack = true;\r\n            } else\r\n                if (e.getSource().equals(jmiBlackPlayerName)) {\r\n                    playerDialog = new PlayerDialog(2, notationPanel.getBlackPlayerName());\r\n                    bWhiteOrBlack = false;\r\n                }\r\n\r\n            if (playerDialog != null) {\r\n                Tools.setDialogToCenter(playerDialog);\r\n                playerDialog.show();\r\n                String sNewName = playerDialog.getNewName();\r\n                if (bWhiteOrBlack == true) {\r\n                    notationPanel.setWhitePlayerName(sNewName);\r\n                } else {\r\n                    notationPanel.setBlackPlayerName(sNewName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}'),(249,'NotationPanel panel','de.java_chess.javaChess.renderer2d.NotationPanel',92,54,'de.java_chess.javaChess.menu.EditMenu',401,'de.java_chess.javaChess.menu.EditMenu.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)',0,'/**\r\n * Sets the NotationPanel to be able to perform some actions there\r\n *\r\n * @param panel\r\n * 		The NotationPanel object\r\n */\r\npublic final void setNotationPanel(NotationPanel panel) {\r\n    this.notationPanel = panel;\r\n}'),(250,'int moveIndex','int',0,55,'de.java_chess.javaChess.notation.GameNotation',403,'de.java_chess.javaChess.notation.GameNotation.getMove(int,boolean)',0,'/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * 		The index of the move.\r\n * @param boolean\r\n * 		white Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\nString getMove(int moveIndex, boolean white);'),(251,'boolean white','boolean',0,55,'de.java_chess.javaChess.notation.GameNotation',403,'de.java_chess.javaChess.notation.GameNotation.getMove(int,boolean)',0,'/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * 		The index of the move.\r\n * @param boolean\r\n * 		white Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\nString getMove(int moveIndex, boolean white);'),(252,'PlyNotation plyNotation','de.java_chess.javaChess.notation.PlyNotation',57,55,'de.java_chess.javaChess.notation.GameNotation',402,'de.java_chess.javaChess.notation.GameNotation.addPly(de.java_chess.javaChess.notation.PlyNotation)',0,'/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * 		The notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation);'),(253,'int index','int',0,55,'de.java_chess.javaChess.notation.GameNotation',407,'de.java_chess.javaChess.notation.GameNotation.getPlyNotation(int)',0,'/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * 		The index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index);'),(254,'de.java_chess.javaChess.notation.PlyNotation','de.java_chess.javaChess.notation.PlyNotation',57,55,'de.java_chess.javaChess.notation.GameNotation',407,'de.java_chess.javaChess.notation.GameNotation.getPlyNotation(int)',1,'/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * 		The index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index);'),(255,'boolean white','boolean',0,55,'de.java_chess.javaChess.notation.GameNotation',406,'de.java_chess.javaChess.notation.GameNotation.getPlayerInfo(boolean)',0,'/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\nString getPlayerInfo(boolean white);'),(256,'String playerInfo','java.lang.String',0,55,'de.java_chess.javaChess.notation.GameNotation',410,'de.java_chess.javaChess.notation.GameNotation.setPlayerInfo(java.lang.String,boolean)',0,'/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * 		The player info.\r\n * @param white\r\n * 		Flag to indicate, if its the player\r\n * 		with the white pieces.\r\n */\r\nvoid setPlayerInfo(String playerInfo, boolean white);'),(257,'boolean white','boolean',0,55,'de.java_chess.javaChess.notation.GameNotation',410,'de.java_chess.javaChess.notation.GameNotation.setPlayerInfo(java.lang.String,boolean)',0,'/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * 		The player info.\r\n * @param white\r\n * 		Flag to indicate, if its the player\r\n * 		with the white pieces.\r\n */\r\nvoid setPlayerInfo(String playerInfo, boolean white);'),(258,'String name','java.lang.String',0,55,'de.java_chess.javaChess.notation.GameNotation',409,'de.java_chess.javaChess.notation.GameNotation.setOpeningInfo(java.lang.String)',0,'/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * 		The name of the opening.\r\n */\r\nvoid setOpeningInfo(String name);'),(259,'int moveIndex','int',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',415,'de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)',0,'/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * 		The index of the move.\r\n * @param boolean\r\n * 		white Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}'),(260,'boolean white','boolean',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',415,'de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)',0,'/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * 		The index of the move.\r\n * @param boolean\r\n * 		white Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}'),(261,'int plyIndex','int',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',420,'de.java_chess.javaChess.notation.GameNotationImpl.getPly(int)',0,'/**\r\n * Get the ply with the given index.\r\n *\r\n * @param plyIndex\r\n * 		The index of the ply.\r\n * @return The notation for the ply as a string.\r\n */\r\nprivate final String getPly(int plyIndex) {\r\n    return _plies.get(plyIndex).toString();\r\n}'),(262,'PlyNotation plyNotation','de.java_chess.javaChess.notation.PlyNotation',57,56,'de.java_chess.javaChess.notation.GameNotationImpl',414,'de.java_chess.javaChess.notation.GameNotationImpl.addPly(de.java_chess.javaChess.notation.PlyNotation)',0,'/**\r\n * Add a new ply with its notation.\r\n *\r\n * @param plyNotation\r\n * 		The notation of the new ply.\r\n */\r\npublic void addPly(PlyNotation plyNotation) {\r\n    _plies.add(plyNotation);\r\n    int nPlies = _plies.size();// Get the number of plies.\r\n\r\n    if ((nPlies & 1) != 0) {\r\n        if (nPlies > 1) {\r\n            // Start a new line\r\n            _notation.append(\"\n\");\r\n        }\r\n        _notation.append(((\"\" + ((nPlies >> 1) + 1)) + \". \"));\r\n    } else {\r\n        _notation.append(\" \");\r\n    }\r\n    _notation.append(plyNotation.toString());\r\n    // If theres a panel, display the current notation.\r\n    if (null != (getNotationPanel())) {\r\n        getNotationPanel().setText(toString());\r\n    }\r\n}'),(263,'int index','int',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',421,'de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)',0,'/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * 		The index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}'),(264,'de.java_chess.javaChess.notation.PlyNotation','de.java_chess.javaChess.notation.PlyNotation',57,56,'de.java_chess.javaChess.notation.GameNotationImpl',421,'de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)',1,'/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * 		The index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}'),(265,'boolean white','boolean',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',419,'de.java_chess.javaChess.notation.GameNotationImpl.getPlayerInfo(boolean)',0,'/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\npublic final String getPlayerInfo(boolean white) {\r\n    return _playerInfo[(white ? 1 : 0)];\r\n}'),(266,'String playerInfo','java.lang.String',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',425,'de.java_chess.javaChess.notation.GameNotationImpl.setPlayerInfo(java.lang.String,boolean)',0,'/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * 		The player info.\r\n * @param white\r\n * 		Flag to indicate, if its the player\r\n * 		with the white pieces.\r\n */\r\npublic final void setPlayerInfo(String playerInfo, boolean white) {\r\n    _playerInfo[(white ? 1 : 0)] = playerInfo;\r\n}'),(267,'boolean white','boolean',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',425,'de.java_chess.javaChess.notation.GameNotationImpl.setPlayerInfo(java.lang.String,boolean)',0,'/**\r\n * Set the info on a player.\r\n *\r\n * @param playerInfo\r\n * 		The player info.\r\n * @param white\r\n * 		Flag to indicate, if its the player\r\n * 		with the white pieces.\r\n */\r\npublic final void setPlayerInfo(String playerInfo, boolean white) {\r\n    _playerInfo[(white ? 1 : 0)] = playerInfo;\r\n}'),(268,'String name','java.lang.String',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',424,'de.java_chess.javaChess.notation.GameNotationImpl.setOpeningInfo(java.lang.String)',0,'/**\r\n * Set the info on the used opening.\r\n *\r\n * @param name\r\n * 		The name of the opening.\r\n */\r\npublic final void setOpeningInfo(String name) {\r\n    _openingName = name;\r\n}'),(269,'NotationPanel notationPanel','de.java_chess.javaChess.renderer2d.NotationPanel',92,56,'de.java_chess.javaChess.notation.GameNotationImpl',423,'de.java_chess.javaChess.notation.GameNotationImpl.setNotationPanel(de.java_chess.javaChess.renderer2d.NotationPanel)',0,'/**\r\n * Set the panel for the notation output.\r\n *\r\n * @param notationPanel\r\n * 		The panel for the output.\r\n */\r\npublic final void setNotationPanel(NotationPanel notationPanel) {\r\n    _notationPanel = notationPanel;\r\n}'),(270,'Piece piece','de.java_chess.javaChess.piece.Piece',67,57,'de.java_chess.javaChess.notation.PlyNotation',436,'de.java_chess.javaChess.notation.PlyNotation.setPiece(de.java_chess.javaChess.piece.Piece)',0,'/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * 		The moved ply.\r\n */\r\nvoid setPiece(Piece piece);'),(271,'Ply ply','de.java_chess.javaChess.ply.Ply',75,57,'de.java_chess.javaChess.notation.PlyNotation',437,'de.java_chess.javaChess.notation.PlyNotation.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * 		The ply for this notation.\r\n */\r\nvoid setPly(Ply ply);'),(272,'boolean check','boolean',0,57,'de.java_chess.javaChess.notation.PlyNotation',434,'de.java_chess.javaChess.notation.PlyNotation.setCheck(boolean)',0,'/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is in check.\r\n */\r\nvoid setCheck(boolean check);'),(273,'boolean checkMate','boolean',0,57,'de.java_chess.javaChess.notation.PlyNotation',435,'de.java_chess.javaChess.notation.PlyNotation.setCheckMate(boolean)',0,'/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is checkmate.\r\n */\r\nvoid setCheckMate(boolean checkMate);'),(274,'byte pieceType','byte',0,57,'de.java_chess.javaChess.notation.PlyNotation',429,'de.java_chess.javaChess.notation.PlyNotation.getPieceTypeNotation(byte)',0,'/**\r\n * Get the notation for a piece type.\r\n *\r\n * @param pieceType\r\n * 		The piece type.\r\n * @return The notation for a piece type.\r\n */\r\nString getPieceTypeNotation(byte pieceType);'),(275,'Ply ply','de.java_chess.javaChess.ply.Ply',75,58,'de.java_chess.javaChess.notation.PlyNotationImpl',439,'de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)',0,'// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n * @param piece\r\n * 		The moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}'),(276,'Piece piece','de.java_chess.javaChess.piece.Piece',67,58,'de.java_chess.javaChess.notation.PlyNotationImpl',439,'de.java_chess.javaChess.notation.PlyNotationImpl.-init-(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.piece.Piece)',0,'// Constructors\r\n/**\r\n * Create a new ply notation instance.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n * @param piece\r\n * 		The moved piece.\r\n */\r\npublic PlyNotationImpl(Ply ply, Piece piece) {\r\n    setPly(ply);\r\n    setPiece(piece);\r\n    // Render the string representation only once and not during\r\n    // the toString() call.\r\n    computeStringRepresentation();\r\n}'),(277,'Piece piece','de.java_chess.javaChess.piece.Piece',67,58,'de.java_chess.javaChess.notation.PlyNotationImpl',449,'de.java_chess.javaChess.notation.PlyNotationImpl.setPiece(de.java_chess.javaChess.piece.Piece)',0,'/**\r\n * Set the piece, that is moved with this ply.\r\n *\r\n * @param ply\r\n * 		The moved ply.\r\n */\r\npublic final void setPiece(Piece piece) {\r\n    _piece = piece;\r\n}'),(278,'Ply ply','de.java_chess.javaChess.ply.Ply',75,58,'de.java_chess.javaChess.notation.PlyNotationImpl',450,'de.java_chess.javaChess.notation.PlyNotationImpl.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set the ply for this notation.\r\n *\r\n * @param ply\r\n * 		The ply for this notation.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(279,'boolean check','boolean',0,58,'de.java_chess.javaChess.notation.PlyNotationImpl',447,'de.java_chess.javaChess.notation.PlyNotationImpl.setCheck(boolean)',0,'/**\r\n * Set the flag for a check.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is in check.\r\n */\r\npublic final void setCheck(boolean check) {\r\n    _check = check;\r\n    // If we are not in check, we are also no checkmate.\r\n    if (check == false) {\r\n        setCheckMate(false);\r\n    }\r\n    // Recompute the string representation to make sure, that\r\n    // it is still correct.\r\n    computeStringRepresentation();\r\n}'),(280,'boolean checkMate','boolean',0,58,'de.java_chess.javaChess.notation.PlyNotationImpl',448,'de.java_chess.javaChess.notation.PlyNotationImpl.setCheckMate(boolean)',0,'/**\r\n * Set the flag for a checkmate.\r\n *\r\n * @param check,\r\n * 		true if the oppenent is checkmate.\r\n */\r\npublic final void setCheckMate(boolean checkMate) {\r\n    _checkMate = checkMate;\r\n    // If the opponent is checkmate, he is also in check.\r\n    if (checkMate == true) {\r\n        setCheck(true);\r\n    }\r\n}'),(281,'byte pieceType','byte',0,58,'de.java_chess.javaChess.notation.PlyNotationImpl',442,'de.java_chess.javaChess.notation.PlyNotationImpl.getPieceTypeNotation(byte)',0,'/**\r\n * Get the notation for a piece type.\r\n *\r\n * @return The notation for a piece type.\r\n */\r\npublic final String getPieceTypeNotation(byte pieceType) {\r\n    String notation = \"\";// The result;\r\n\r\n    // Convert the piece type to a string.\r\n    switch (pieceType) {\r\n        case Piece.PAWN :\r\n            notation = \"P\";\r\n            break;\r\n        case Piece.KNIGHT :\r\n            notation = \"N\";\r\n            break;\r\n        case Piece.BISHOP :\r\n            notation = \"B\";\r\n            break;\r\n        case Piece.ROOK :\r\n            notation = \"R\";\r\n            break;\r\n        case Piece.QUEEN :\r\n            notation = \"Q\";\r\n            break;\r\n        case Piece.KING :\r\n            notation = \"K\";\r\n            break;\r\n    }\r\n    return notation;\r\n}'),(282,'PGNPlyFragment plyFragment','de.java_chess.javaChess.pgn.PGNPlyFragment',65,59,'de.java_chess.javaChess.pgn.GameLoader',453,'de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)',0,'// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * 		The info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}'),(283,'de.java_chess.javaChess.notation.PlyNotation','de.java_chess.javaChess.notation.PlyNotation',57,59,'de.java_chess.javaChess.pgn.GameLoader',453,'de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)',1,'// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * 		The info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}'),(284,'Ply ply','de.java_chess.javaChess.ply.Ply',75,59,'de.java_chess.javaChess.pgn.GameLoader',454,'de.java_chess.javaChess.pgn.GameLoader.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Perform a ply, when it is completely loaded.\r\n *\r\n * param ply The ply to perform.\r\n */\r\nprivate final void doPly(Ply ply) {\r\n    _game.doPly(ply);\r\n    _board.doPly(ply);\r\n    // The other color is about to move now.\r\n    _whiteMoves = !(_whiteMoves);\r\n}'),(285,'Reader reader','java.io.Reader',0,60,'de.java_chess.javaChess.pgn.PGNFile',455,'de.java_chess.javaChess.pgn.PGNFile.-init-(java.io.Reader)',0,'// Constructors\r\n/**\r\n * Create a new instance.\r\n *\r\n * @param reader\r\n * 		The reader for the file.\r\n */\r\npublic PGNFile(Reader reader) {\r\n    setReader(reader);\r\n}'),(286,'Reader reader','java.io.Reader',0,60,'de.java_chess.javaChess.pgn.PGNFile',460,'de.java_chess.javaChess.pgn.PGNFile.setReader(java.io.Reader)',0,'/**\r\n * Set a new reader for a file.\r\n *\r\n * @param reader\r\n * 		The new reader.\r\n */\r\nprivate final void setReader(Reader reader) {\r\n    _reader = reader;\r\n}'),(287,'PGNParser parser','de.java_chess.javaChess.pgn.PGNParser',64,60,'de.java_chess.javaChess.pgn.PGNFile',459,'de.java_chess.javaChess.pgn.PGNFile.setPGNParser(de.java_chess.javaChess.pgn.PGNParser)',0,'/**\r\n * Set the current parser.\r\n *\r\n * @param parser\r\n * 		The new PGN parser.\r\n */\r\nprivate final void setPGNParser(PGNParser parser) {\r\n    _parser = parser;\r\n}'),(288,'File file','java.io.File',0,61,'de.java_chess.javaChess.pgn.PGNFileFilter',462,'de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)',0,'// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * 		The file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}'),(289,'InputStream in','java.io.InputStream',0,62,'de.java_chess.javaChess.pgn.PGNLexer',464,'de.java_chess.javaChess.pgn.PGNLexer.-init-(java.io.InputStream)',0,'public PGNLexer(InputStream in) {\r\n    this(new ByteBuffer(in));\r\n}'),(290,'Reader in','java.io.Reader',0,62,'de.java_chess.javaChess.pgn.PGNLexer',465,'de.java_chess.javaChess.pgn.PGNLexer.-init-(java.io.Reader)',0,'public PGNLexer(Reader in) {\r\n    this(new CharBuffer(in));\r\n}'),(291,'InputBuffer ib','antlr.InputBuffer',0,62,'de.java_chess.javaChess.pgn.PGNLexer',466,'de.java_chess.javaChess.pgn.PGNLexer.-init-(antlr.InputBuffer)',0,'public PGNLexer(InputBuffer ib) {\r\n    this(new antlr.LexerSharedInputState(ib));\r\n}'),(292,'LexerSharedInputState state','antlr.LexerSharedInputState',0,62,'de.java_chess.javaChess.pgn.PGNLexer',467,'de.java_chess.javaChess.pgn.PGNLexer.-init-(antlr.LexerSharedInputState)',0,'public PGNLexer(LexerSharedInputState state) {\r\n    super(state);\r\n    literals = new Hashtable();\r\n    caseSensitiveLiterals = true;\r\n    setCaseSensitive(true);\r\n}'),(293,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',489,'de.java_chess.javaChess.pgn.PGNLexer.mWS(boolean)',0,'public final void mWS(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.WS;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case   :\r\n                {\r\n                    match( );\r\n                    break;\r\n                }\r\n            case 	 :\r\n                {\r\n                    match(	);\r\n                    break;\r\n                }\r\n            case f :\r\n                {\r\n                    match(f);\r\n                    break;\r\n                }\r\n            case \n :\r\n            case \r :\r\n                {\r\n                    {\r\n                        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n                            match(\"\r\n\");\r\n                        } else\r\n                            if (((LA(1)) == \r) && true) {\r\n                                match(\r);\r\n                            } else\r\n                                if ((LA(1)) == \n) {\r\n                                    match(\n);\r\n                                } else {\r\n                                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                                }\r\n\r\n\r\n                    }\r\n                    newline();\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    /* $setType(Token.SKIP); */\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(294,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',468,'de.java_chess.javaChess.pgn.PGNLexer.mDOT(boolean)',0,'public final void mDOT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.DOT;\r\n    int _saveIndex;\r\n    match(.);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(295,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',471,'de.java_chess.javaChess.pgn.PGNLexer.mLBRACK(boolean)',0,'public final void mLBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.LBRACK;\r\n    int _saveIndex;\r\n    match([);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(296,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',476,'de.java_chess.javaChess.pgn.PGNLexer.mRBRACK(boolean)',0,'public final void mRBRACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RBRACK;\r\n    int _saveIndex;\r\n    match(]);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(297,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',478,'de.java_chess.javaChess.pgn.PGNLexer.mSL_COMMENT(boolean)',0,'public final void mSL_COMMENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SL_COMMENT;\r\n    int _saveIndex;\r\n    match(\";\");\r\n    {\r\n        _loop39 : do {\r\n            if (PGNLexer._tokenSet_2.member(LA(1))) {\r\n                {\r\n                    match(PGNLexer._tokenSet_2);\r\n                }\r\n            } else {\r\n                break _loop39;\r\n            }\r\n        } while (true );\r\n    }\r\n    {\r\n        if (((LA(1)) == \r) && ((LA(2)) == \n)) {\r\n            match(\"\r\n\");\r\n        } else\r\n            if ((LA(1)) == \n) {\r\n                match(\"\n\");\r\n            } else\r\n                if (((LA(1)) == \r) && true) {\r\n                    match(\"\r\");\r\n                } else {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n\r\n\r\n    }\r\n    _ttype = Token.SKIP;\r\n    newline();\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(298,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',480,'de.java_chess.javaChess.pgn.PGNLexer.mSTRING_LITERAL(boolean)',0,'public final void mSTRING_LITERAL(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.STRING_LITERAL;\r\n    int _saveIndex;\r\n    {\r\n        match(\");\r\n        {\r\n            _loop45 : do {\r\n                if (PGNLexer._tokenSet_3.member(LA(1))) {\r\n                    {\r\n                        match(PGNLexer._tokenSet_3);\r\n                    }\r\n                } else {\r\n                    break _loop45;\r\n                }\r\n            } while (true );\r\n        }\r\n        match(\");\r\n    }\r\n    // Remove the leadind and trailing quote.\r\n    String literal = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    literal = ((literal.length()) == 2) ? \"\" : literal.substring(1, ((literal.length()) - 2));\r\n    text.setLength(_begin);\r\n    text.append(literal);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(299,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',479,'de.java_chess.javaChess.pgn.PGNLexer.mSQUARE_NAME(boolean)',0,'public final void mSQUARE_NAME(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.SQUARE_NAME;\r\n    int _saveIndex;\r\n    matchRange(a, h);\r\n    matchRange(1, 8);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(300,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',475,'de.java_chess.javaChess.pgn.PGNLexer.mPIECE_MOVE(boolean)',0,'public final void mPIECE_MOVE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_MOVE;\r\n    int _saveIndex;\r\n    match(-);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(301,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',474,'de.java_chess.javaChess.pgn.PGNLexer.mPIECE_CAPTURE(boolean)',0,'public final void mPIECE_CAPTURE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PIECE_CAPTURE;\r\n    int _saveIndex;\r\n    match(x);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(302,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',473,'de.java_chess.javaChess.pgn.PGNLexer.mPAWN_PROMOTION(boolean)',0,'public final void mPAWN_PROMOTION(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.PAWN_PROMOTION;\r\n    int _saveIndex;\r\n    match(=);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(303,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',469,'de.java_chess.javaChess.pgn.PGNLexer.mFIGURINE_LETTER_CODE(boolean)',0,'public final void mFIGURINE_LETTER_CODE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.FIGURINE_LETTER_CODE;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case P :\r\n                {\r\n                    match(P);\r\n                    break;\r\n                }\r\n            case N :\r\n                {\r\n                    match(N);\r\n                    break;\r\n                }\r\n            case B :\r\n                {\r\n                    match(B);\r\n                    break;\r\n                }\r\n            case R :\r\n                {\r\n                    match(R);\r\n                    break;\r\n                }\r\n            case Q :\r\n                {\r\n                    match(Q);\r\n                    break;\r\n                }\r\n            case K :\r\n                {\r\n                    match(K);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                }\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(304,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',477,'de.java_chess.javaChess.pgn.PGNLexer.mRIGHT_CASTLING(boolean)',0,'public final void mRIGHT_CASTLING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.RIGHT_CASTLING;\r\n    int _saveIndex;\r\n    match(\"O-O\");\r\n    {\r\n        if ((LA(1)) == -) {\r\n            match(\"-O\");\r\n            _ttype = PGNTokenTypes.LEFT_CASTLING;\r\n        } else {\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(305,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',472,'de.java_chess.javaChess.pgn.PGNLexer.mMOVE_INDEX(boolean)',0,'public final void mMOVE_INDEX(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.MOVE_INDEX;\r\n    int _saveIndex;\r\n    {\r\n        matchRange(1, 9);\r\n        {\r\n            _loop57 : do {\r\n                if (((LA(1)) >= 0) && ((LA(1)) <= 9)) {\r\n                    matchRange(0, 9);\r\n                } else {\r\n                    break _loop57;\r\n                }\r\n            } while (true );\r\n        }\r\n        mDOT(false);\r\n    }\r\n    // Remove the trailing dot.\r\n    String index = new String(text.getBuffer(), _begin, ((text.length()) - _begin));\r\n    index = index.substring(0, ((index.length()) - 1));\r\n    text.setLength(_begin);\r\n    text.append(index);\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(306,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',488,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_WHITE(boolean)',0,'public final void mTAG_WHITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_WHITE;\r\n    int _saveIndex;\r\n    match(\"White\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(307,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',481,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_BLACK(boolean)',0,'public final void mTAG_BLACK(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_BLACK;\r\n    int _saveIndex;\r\n    match(\"Black\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(308,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',482,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_DATE(boolean)',0,'public final void mTAG_DATE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_DATE;\r\n    int _saveIndex;\r\n    match(\"Date\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(309,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',483,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_EVENT(boolean)',0,'public final void mTAG_EVENT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_EVENT;\r\n    int _saveIndex;\r\n    match(\"Event\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(310,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',487,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_SITE(boolean)',0,'public final void mTAG_SITE(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_SITE;\r\n    int _saveIndex;\r\n    match(\"Site\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(311,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',486,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_ROUND(boolean)',0,'public final void mTAG_ROUND(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_ROUND;\r\n    int _saveIndex;\r\n    match(\"Round\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(312,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',485,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_RESULT(boolean)',0,'public final void mTAG_RESULT(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_RESULT;\r\n    int _saveIndex;\r\n    match(\"Result\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(313,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',484,'de.java_chess.javaChess.pgn.PGNLexer.mTAG_OPENING(boolean)',0,'public final void mTAG_OPENING(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.TAG_OPENING;\r\n    int _saveIndex;\r\n    match(\"Opening\");\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(314,'boolean _createToken','boolean',0,62,'de.java_chess.javaChess.pgn.PGNLexer',470,'de.java_chess.javaChess.pgn.PGNLexer.mGAME_TERMINATOR(boolean)',0,'public final void mGAME_TERMINATOR(boolean _createToken) throws CharStreamException, RecognitionException, TokenStreamException {\r\n    int _ttype;\r\n    Token _token = null;\r\n    int _begin = text.length();\r\n    _ttype = PGNTokenTypes.GAME_TERMINATOR;\r\n    int _saveIndex;\r\n    {\r\n        switch (LA(1)) {\r\n            case * :\r\n                {\r\n                    match(\"*\");\r\n                    break;\r\n                }\r\n            case 0 :\r\n                {\r\n                    match(\"0-1\");\r\n                    break;\r\n                }\r\n            default :\r\n                if (((LA(1)) == 1) && ((LA(2)) == -)) {\r\n                    match(\"1-0\");\r\n                } else\r\n                    if (((LA(1)) == 1) && ((LA(2)) == /)) {\r\n                        match(\"1/2-1/2\");\r\n                    } else {\r\n                        throw new antlr.NoViableAltForCharException(((char) (LA(1))), getFilename(), getLine());\r\n                    }\r\n\r\n        }\r\n    }\r\n    if ((_createToken && (_token == null)) && (_ttype != (Token.SKIP))) {\r\n        _token = makeToken(_ttype);\r\n        _token.setText(new String(text.getBuffer(), _begin, ((text.length()) - _begin)));\r\n    }\r\n    _returnToken = _token;\r\n}'),(315,'File file','java.io.File',0,63,'de.java_chess.javaChess.pgn.PGNOutputStream',491,'de.java_chess.javaChess.pgn.PGNOutputStream.-init-(java.io.File)',0,'// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new PGNOutputStream instance.\r\n *\r\n * @param file\r\n * 		The file to write into.\r\n */\r\npublic PGNOutputStream(File file) throws IOException {\r\n    super(file);\r\n}'),(316,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,63,'de.java_chess.javaChess.pgn.PGNOutputStream',492,'de.java_chess.javaChess.pgn.PGNOutputStream.write(de.java_chess.javaChess.notation.GameNotation)',0,'// Methods\r\n/**\r\n * Write the notation of a game.\r\n *\r\n * @param gameNotation\r\n * 		The notation of the game.\r\n */\r\npublic final void write(GameNotation gameNotation) throws IOException {\r\n    // Check, if there is some header available.\r\n    String header = gameNotation.getPGNheader();\r\n    if (!(\"\".equals(header))) {\r\n        header += \"\n\";\r\n        write(header.getBytes());\r\n    }\r\n    write(gameNotation.toString().getBytes());\r\n}'),(317,'TokenBuffer tokenBuf','antlr.TokenBuffer',0,64,'de.java_chess.javaChess.pgn.PGNParser',493,'de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer,int)',0,'protected PGNParser(TokenBuffer tokenBuf, int k) {\r\n    super(tokenBuf, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(318,'int k','int',0,64,'de.java_chess.javaChess.pgn.PGNParser',493,'de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer,int)',0,'protected PGNParser(TokenBuffer tokenBuf, int k) {\r\n    super(tokenBuf, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(319,'TokenBuffer tokenBuf','antlr.TokenBuffer',0,64,'de.java_chess.javaChess.pgn.PGNParser',494,'de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenBuffer)',0,'public PGNParser(TokenBuffer tokenBuf) {\r\n    this(tokenBuf, 2);\r\n}'),(320,'TokenStream lexer','antlr.TokenStream',0,64,'de.java_chess.javaChess.pgn.PGNParser',495,'de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream,int)',0,'protected PGNParser(TokenStream lexer, int k) {\r\n    super(lexer, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(321,'int k','int',0,64,'de.java_chess.javaChess.pgn.PGNParser',495,'de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream,int)',0,'protected PGNParser(TokenStream lexer, int k) {\r\n    super(lexer, k);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(322,'TokenStream lexer','antlr.TokenStream',0,64,'de.java_chess.javaChess.pgn.PGNParser',496,'de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.TokenStream)',0,'public PGNParser(TokenStream lexer) {\r\n    this(lexer, 2);\r\n}'),(323,'ParserSharedInputState state','antlr.ParserSharedInputState',0,64,'de.java_chess.javaChess.pgn.PGNParser',497,'de.java_chess.javaChess.pgn.PGNParser.-init-(antlr.ParserSharedInputState)',0,'public PGNParser(ParserSharedInputState state) {\r\n    super(state, 2);\r\n    tokenNames = PGNParser._tokenNames;\r\n}'),(324,'GameNotation notation','de.java_chess.javaChess.notation.GameNotation',55,64,'de.java_chess.javaChess.pgn.PGNParser',511,'de.java_chess.javaChess.pgn.PGNParser.setNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set a new buffer for the game notation.\r\n *\r\n * @param notation\r\n * 		The new notation buffer.\r\n */\r\npublic final void setNotation(GameNotation notation) {\r\n    _notation = notation;\r\n}'),(325,'GameLoader loader','de.java_chess.javaChess.pgn.GameLoader',59,64,'de.java_chess.javaChess.pgn.PGNParser',510,'de.java_chess.javaChess.pgn.PGNParser.setGameLoader(de.java_chess.javaChess.pgn.GameLoader)',0,'/**\r\n * Set a new game loader.\r\n *\r\n * @param loader\r\n * 		The new game loader.\r\n */\r\nprivate final void setGameLoader(GameLoader loader) {\r\n    _gameLoader = loader;\r\n}'),(326,'GameNotation notationBuffer','de.java_chess.javaChess.notation.GameNotation',55,64,'de.java_chess.javaChess.pgn.PGNParser',506,'de.java_chess.javaChess.pgn.PGNParser.pgnGame(de.java_chess.javaChess.notation.GameNotation)',0,'public final void pgnGame(GameNotation notationBuffer) throws RecognitionException, TokenStreamException {\r\n    setNotation(notationBuffer);\r\n    setGameLoader(new GameLoader());\r\n    whiteSpaces();\r\n    tagPairSection();\r\n    moveTextSection();\r\n}'),(327,'char letter','char',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',534,'de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceTypeFromLetter(char)',0,'// Constructors\r\n// Methods\r\n/**\r\n * Set the piece type from a figurine letter code.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n */\r\npublic final void setPieceTypeFromLetter(char letter) {\r\n    setPieceType(getPieceTypeFromLetter(letter));\r\n}'),(328,'String squareName','java.lang.String',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',531,'de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(java.lang.String)',0,'/**\r\n * Set the name of the origin square.\r\n *\r\n * @param squareName\r\n * 		The name of the origin square.\r\n */\r\npublic final void setOrigin(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _origin = new PositionImpl(squareName);\r\n}'),(329,'Position position','de.java_chess.javaChess.position.Position',80,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',530,'de.java_chess.javaChess.pgn.PGNPlyFragment.setOrigin(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the name of the origin square.\r\n *\r\n * @param position\r\n * 		The position of the origin square.\r\n */\r\npublic final void setOrigin(Position position) {\r\n    // Store the position.\r\n    _origin = position;\r\n}'),(330,'String squareName','java.lang.String',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',529,'de.java_chess.javaChess.pgn.PGNPlyFragment.setDestination(java.lang.String)',0,'/**\r\n * Set the name of the destination square.\r\n *\r\n * @param squareName\r\n * 		The name of the destination square.\r\n */\r\npublic final void setDestination(String squareName) {\r\n    // Create a new position implementation from the name and store it.\r\n    _destination = new PositionImpl(squareName);\r\n}'),(331,'boolean capture','boolean',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',527,'de.java_chess.javaChess.pgn.PGNPlyFragment.setCapture(boolean)',0,'/**\r\n * Set the flag, if this move captures a piece.\r\n *\r\n * @param capture\r\n * 		true, if this move capures a piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}'),(332,'char newPieceTypeLetter','char',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',532,'de.java_chess.javaChess.pgn.PGNPlyFragment.setPawnPromotion(char)',0,'/**\r\n * Make this ply a pawn promotion and set the piece type after the promotion.\r\n *\r\n * @param newPieceTypeLetter\r\n * 		The piece type after the pawn promotion as a figurine letter code.\r\n */\r\npublic final void setPawnPromotion(char newPieceTypeLetter) {\r\n    _pawnPromotion = true;\r\n    _newPieceType = getPieceTypeFromLetter(newPieceTypeLetter);\r\n}'),(333,'boolean left','boolean',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',528,'de.java_chess.javaChess.pgn.PGNPlyFragment.setCastling(boolean)',0,'/**\r\n * Set this ply as a castling.\r\n *\r\n * @param goesLeft\r\n * 		true, if the castling goes to the left.\r\n */\r\npublic final void setCastling(boolean left) {\r\n    _castling = true;\r\n    _leftCastling = left;\r\n}'),(334,'byte type','byte',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',533,'de.java_chess.javaChess.pgn.PGNPlyFragment.setPieceType(byte)',0,'/**\r\n * Set the type of the moved piece.\r\n *\r\n * @param type\r\n * 		The type of the moved piece.\r\n */\r\nprivate final void setPieceType(byte type) {\r\n    _pieceType = type;\r\n}'),(335,'char letter','char',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',0,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(336,'byte type','byte',0,67,'de.java_chess.javaChess.piece.Piece',540,'de.java_chess.javaChess.piece.Piece.setType(byte)',0,'/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * 		The new type of this piece.\r\n */\r\npublic void setType(byte type);'),(337,'byte color','byte',0,67,'de.java_chess.javaChess.piece.Piece',539,'de.java_chess.javaChess.piece.Piece.setColor(byte)',0,'/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * 		new color of this piece.\r\n */\r\npublic void setColor(byte color);'),(338,'byte typeColor','byte',0,68,'de.java_chess.javaChess.piece.PieceImpl',541,'de.java_chess.javaChess.piece.PieceImpl.-init-(byte)',0,'// Constructors\r\n/**\r\n * Create a new piece instance.\r\n *\r\n * @param typeColor\r\n * 		The color and type of piece, with color in bit 0\r\n * 		and the type color in bit 1-3.\r\n */\r\npublic PieceImpl(byte typeColor) {\r\n    _typeColor = typeColor;\r\n}'),(339,'byte type','byte',0,68,'de.java_chess.javaChess.piece.PieceImpl',542,'de.java_chess.javaChess.piece.PieceImpl.-init-(byte,byte)',0,'/**\r\n * Create a new Piece instance from type and color.\r\n *\r\n * @param type\r\n * 		The type of the piece.\r\n * @param color\r\n * 		The color of the piece.\r\n */\r\npublic PieceImpl(byte type, byte color) {\r\n    this(((byte) ((type << 1) + color)));\r\n}'),(340,'byte color','byte',0,68,'de.java_chess.javaChess.piece.PieceImpl',542,'de.java_chess.javaChess.piece.PieceImpl.-init-(byte,byte)',0,'/**\r\n * Create a new Piece instance from type and color.\r\n *\r\n * @param type\r\n * 		The type of the piece.\r\n * @param color\r\n * 		The color of the piece.\r\n */\r\npublic PieceImpl(byte type, byte color) {\r\n    this(((byte) ((type << 1) + color)));\r\n}'),(341,'byte type','byte',0,68,'de.java_chess.javaChess.piece.PieceImpl',548,'de.java_chess.javaChess.piece.PieceImpl.setType(byte)',0,'/**\r\n * Set the type of this piece.\r\n *\r\n * @param type\r\n * 		The type of this piece as defined as\r\n * 		constants in the Piece interface.\r\n */\r\npublic final void setType(byte type) {\r\n    _typeColor &= ((byte) (1));\r\n    _typeColor |= type << 1;\r\n}'),(342,'byte color','byte',0,68,'de.java_chess.javaChess.piece.PieceImpl',547,'de.java_chess.javaChess.piece.PieceImpl.setColor(byte)',0,'/**\r\n * Set the color of this piece.\r\n *\r\n * @param The\r\n * 		new color of this piece.\r\n */\r\npublic final void setColor(byte color) {\r\n    _typeColor &= ((byte) (14));\r\n    _typeColor |= color;\r\n}'),(343,'Ply ply','de.java_chess.javaChess.ply.Ply',75,69,'de.java_chess.javaChess.ply.AnalyzedPly',552,'de.java_chess.javaChess.ply.AnalyzedPly.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * 		The new ply.\r\n */\r\nvoid setPly(Ply ply);'),(344,'short score','short',0,69,'de.java_chess.javaChess.ply.AnalyzedPly',553,'de.java_chess.javaChess.ply.AnalyzedPly.setScore(short)',0,'/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * 		The new score for this ply.\r\n */\r\nvoid setScore(short score);'),(345,'Ply ply','de.java_chess.javaChess.ply.Ply',75,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',554,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)',0,'// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}'),(346,'short score','short',0,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',554,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.-init-(de.java_chess.javaChess.ply.Ply,short)',0,'// Constructors\r\n/**\r\n * Create a new AnalyzedPly instance.\r\n */\r\npublic AnalyzedPlyImpl(Ply ply, short score) {\r\n    setPly(ply);\r\n    setScore(score);\r\n}'),(347,'Ply ply','de.java_chess.javaChess.ply.Ply',75,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',558,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.setPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Set a new ply.\r\n *\r\n * @param ply\r\n * 		The new ply.\r\n */\r\npublic final void setPly(Ply ply) {\r\n    _ply = ply;\r\n}'),(348,'short score','short',0,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',559,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.setScore(short)',0,'/**\r\n * Set a new scrore for this ply.\r\n *\r\n * @param score\r\n * 		The new score for this ply.\r\n */\r\npublic final void setScore(short score) {\r\n    _score = score;\r\n}'),(349,'boolean goesLeft','boolean',0,71,'de.java_chess.javaChess.ply.CastlingPly',561,'de.java_chess.javaChess.ply.CastlingPly.setLeftCastling(boolean)',0,'/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\nvoid setLeftCastling(boolean goesLeft);'),(350,'Position source','de.java_chess.javaChess.position.Position',80,72,'de.java_chess.javaChess.ply.CastlingPlyImpl',562,'de.java_chess.javaChess.ply.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}'),(351,'boolean goesLeft','boolean',0,72,'de.java_chess.javaChess.ply.CastlingPlyImpl',562,'de.java_chess.javaChess.ply.CastlingPlyImpl.-init-(de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new castling ply from a source and a destination\r\n * and the direction.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\npublic CastlingPlyImpl(Position source, boolean goesLeft) {\r\n    super(source, new PositionImpl((-1)), false);\r\n    setLeftCastling(goesLeft);\r\n}'),(352,'boolean goesLeft','boolean',0,72,'de.java_chess.javaChess.ply.CastlingPlyImpl',564,'de.java_chess.javaChess.ply.CastlingPlyImpl.setLeftCastling(boolean)',0,'/**\r\n * Set the flag, if the castling goes left.\r\n *\r\n * @param goesLeft\r\n * 		Flag to indicate if the castling goes left.\r\n */\r\npublic final void setLeftCastling(boolean goesLeft) {\r\n    _goesLeft = goesLeft;\r\n}'),(353,'Position attackedPosition','de.java_chess.javaChess.position.Position',80,73,'de.java_chess.javaChess.ply.EnPassantPly',567,'de.java_chess.javaChess.ply.EnPassantPly.setAttackedPosition(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * 		The position of the attacked pawn.\r\n */\r\nvoid setAttackedPosition(Position attackedPosition);'),(354,'Position source','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',568,'de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)',0,'// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * 		The source square of the attacking pawn.\r\n * @param destination\r\n * 		The destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * 		The position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}'),(355,'Position destination','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',568,'de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)',0,'// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * 		The source square of the attacking pawn.\r\n * @param destination\r\n * 		The destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * 		The position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}'),(356,'Position attackedPosition','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',568,'de.java_chess.javaChess.ply.EnPassantPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position)',0,'// Constructors\r\n/**\r\n * Create a new en passant ply instance.\r\n *\r\n * @param source\r\n * 		The source square of the attacking pawn.\r\n * @param destination\r\n * 		The destination square of the attacking pawn.\r\n * @param attackedPosition\r\n * 		The position of the attacked pawn.\r\n */\r\npublic EnPassantPlyImpl(Position source, Position destination, Position attackedPosition) {\r\n    super(source, destination, true);\r\n    setAttackedPosition(attackedPosition);\r\n}'),(357,'Position attackedPosition','de.java_chess.javaChess.position.Position',80,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',570,'de.java_chess.javaChess.ply.EnPassantPlyImpl.setAttackedPosition(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the position of the attacked pawn.\r\n *\r\n * @param position\r\n * 		The position of the attacked pawn.\r\n */\r\npublic final void setAttackedPosition(Position attackedPosition) {\r\n    _attackedPosition = attackedPosition;\r\n}'),(358,'Position source','de.java_chess.javaChess.position.Position',80,75,'de.java_chess.javaChess.ply.Ply',576,'de.java_chess.javaChess.ply.Ply.setSource(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the source of the ply.\r\n *\r\n * @param source\r\n * 		The new source square for this ply.\r\n */\r\nvoid setSource(Position source);'),(359,'Position destination','de.java_chess.javaChess.position.Position',80,75,'de.java_chess.javaChess.ply.Ply',575,'de.java_chess.javaChess.ply.Ply.setDestination(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * 		The new destination square of this ply.\r\n */\r\nvoid setDestination(Position destination);'),(360,'Ply ply','de.java_chess.javaChess.ply.Ply',75,75,'de.java_chess.javaChess.ply.Ply',571,'de.java_chess.javaChess.ply.Ply.equals(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * 		The other ply.\r\n * @return true, if the 2 plies are equal. False otherwise.\r\n */\r\nboolean equals(Ply ply);'),(361,'Position source','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',577,'de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param capture\r\n * 		Flag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}'),(362,'Position destination','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',577,'de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param capture\r\n * 		Flag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}'),(363,'boolean capture','boolean',0,76,'de.java_chess.javaChess.ply.PlyImpl',577,'de.java_chess.javaChess.ply.PlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,boolean)',0,'// Constructors\r\n/**\r\n * Construct a new ply from a source and a destination.\r\n *\r\n * @param source\r\n * 		The source of the ply.\r\n * @param destination\r\n * 		The destination of the ply.\r\n * @param capture\r\n * 		Flag to indicate, if this ply captures another piece.\r\n */\r\npublic PlyImpl(Position source, Position destination, boolean capture) {\r\n    setSource(source);\r\n    setDestination(destination);\r\n    setCapture(capture);\r\n}'),(364,'Position source','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',584,'de.java_chess.javaChess.ply.PlyImpl.setSource(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the source of the ply.\r\n *\r\n * @param The\r\n * 		new source of the piece.\r\n */\r\npublic final void setSource(Position source) {\r\n    _source = source;\r\n}'),(365,'Position destination','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',583,'de.java_chess.javaChess.ply.PlyImpl.setDestination(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Set the destination of the piece.\r\n *\r\n * @param destination\r\n * 		The new destination of the piece.\r\n */\r\npublic final void setDestination(Position destination) {\r\n    _destination = destination;\r\n}'),(366,'boolean capture','boolean',0,76,'de.java_chess.javaChess.ply.PlyImpl',582,'de.java_chess.javaChess.ply.PlyImpl.setCapture(boolean)',0,'/**\r\n * Set a flag, if this ply captures another piece.\r\n *\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic final void setCapture(boolean capture) {\r\n    _capture = capture;\r\n}'),(367,'Ply ply','de.java_chess.javaChess.ply.Ply',75,76,'de.java_chess.javaChess.ply.PlyImpl',578,'de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * 		The other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}'),(368,'byte pieceType','byte',0,77,'de.java_chess.javaChess.ply.TransformationPly',587,'de.java_chess.javaChess.ply.TransformationPly.setTypeAfterTransformation(byte)',0,'/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * 		The new piece type after the transformation.\r\n */\r\nvoid setTypeAfterTransformation(byte pieceType);'),(369,'Position source','de.java_chess.javaChess.position.Position',80,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',588,'de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param pieceType\r\n * 		The piece type after the transformation.\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}'),(370,'Position destination','de.java_chess.javaChess.position.Position',80,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',588,'de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param pieceType\r\n * 		The piece type after the transformation.\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}'),(371,'byte pieceType','byte',0,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',588,'de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param pieceType\r\n * 		The piece type after the transformation.\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}'),(372,'boolean capture','boolean',0,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',588,'de.java_chess.javaChess.ply.TransformationPlyImpl.-init-(de.java_chess.javaChess.position.Position,de.java_chess.javaChess.position.Position,byte,boolean)',0,'// Constructors\r\n/**\r\n * Create a new transformation ply instance.\r\n *\r\n * @param source\r\n * 		The source square.\r\n * @param destination\r\n * 		The destination square.\r\n * @param pieceType\r\n * 		The piece type after the transformation.\r\n * @param capture\r\n * 		Flag to indicate if this ply captures another piece.\r\n */\r\npublic TransformationPlyImpl(Position source, Position destination, byte pieceType, boolean capture) {\r\n    super(source, destination, capture);\r\n    setTypeAfterTransformation(pieceType);\r\n}'),(373,'byte pieceType','byte',0,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',590,'de.java_chess.javaChess.ply.TransformationPlyImpl.setTypeAfterTransformation(byte)',0,'/**\r\n * Set the new piece type after the transformation.\r\n *\r\n * @param pieceType\r\n * 		The new piece type after the transformation.\r\n */\r\npublic final void setTypeAfterTransformation(byte pieceType) {\r\n    _newPieceType = pieceType;\r\n}'),(374,'int index','int',0,80,'de.java_chess.javaChess.position.Position',596,'de.java_chess.javaChess.position.Position.setSquareIndex(int)',0,'/**\r\n * The square index of this position instance.\r\n *\r\n * @param index\r\n * 		The square index of this position (0-63).\r\n */\r\nvoid setSquareIndex(int index);'),(375,'Position pos','de.java_chess.javaChess.position.Position',80,80,'de.java_chess.javaChess.position.Position',592,'de.java_chess.javaChess.position.Position.equals(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * 		position.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\nboolean equals(Position pos);'),(376,'int squareIndex','int',0,81,'de.java_chess.javaChess.position.PositionImpl',598,'de.java_chess.javaChess.position.PositionImpl.-init-(int)',0,'// Constructors\r\n/**\r\n * Create a position from a given square index.\r\n *\r\n * @param squareIndex\r\n * 		The index of the square (0..63).\r\n */\r\npublic PositionImpl(int squareIndex) {\r\n    setSquareIndex(squareIndex);\r\n}'),(377,'String squareName','java.lang.String',0,81,'de.java_chess.javaChess.position.PositionImpl',599,'de.java_chess.javaChess.position.PositionImpl.-init-(java.lang.String)',0,'/**\r\n * Create a position from a given square name (i.e. d4).\r\n *\r\n * @param squareName\r\n * 		The name of the square.\r\n * @throws IllegalPositionException\r\n * 		If the argument is not a valid square name.\r\n */\r\npublic PositionImpl(String squareName) throws IllegalPositionException {\r\n    // -1 indicates an error here.\r\n    int squareIndex = -1;\r\n    // Trim and convert the name to lower case.\r\n    squareName = squareName.trim().toLowerCase();\r\n    // Check if the name has no extra characters\r\n    if ((squareName.length()) != 2) {\r\n        throw new IllegalPositionException();\r\n    } else {\r\n        // Get the line.\r\n        char lineLetter = squareName.charAt(0);\r\n        if ((lineLetter < a) || (lineLetter > h)) {\r\n            throw new IllegalPositionException();\r\n        } else {\r\n            // Compute the index of the line.\r\n            int lineIndex = lineLetter - a;\r\n            // Get the name of the row.\r\n            char rowLetter = squareName.charAt(1);\r\n            if ((rowLetter < 1) || (rowLetter > 8)) {\r\n                throw new IllegalPositionException();\r\n            } else {\r\n                int rowIndex = rowLetter - 1;\r\n                // The square index is 8 * row + line.\r\n                squareIndex = (rowIndex << 3) + lineIndex;\r\n            }\r\n        }\r\n    }\r\n    // Set the computed square index.\r\n    setSquareIndex(squareIndex);\r\n}'),(378,'int squareIndex','int',0,81,'de.java_chess.javaChess.position.PositionImpl',604,'de.java_chess.javaChess.position.PositionImpl.setSquareIndex(int)',0,'/**\r\n * Set the square index of this position.\r\n *\r\n * @param squareIndex\r\n * 		The new square index of this position.\r\n */\r\npublic final void setSquareIndex(int squareIndex) {\r\n    _squareIndex = squareIndex;\r\n}'),(379,'Position pos','de.java_chess.javaChess.position.Position',80,81,'de.java_chess.javaChess.position.PositionImpl',600,'de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)',0,'/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * 		position.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}'),(380,'Board board','de.java_chess.javaChess.board.Board',13,82,'de.java_chess.javaChess.renderer.ChessBoardRenderer',610,'de.java_chess.javaChess.renderer.ChessBoardRenderer.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\nvoid setBoard(Board board);'),(381,'Ply ply','de.java_chess.javaChess.ply.Ply',75,82,'de.java_chess.javaChess.renderer.ChessBoardRenderer',606,'de.java_chess.javaChess.renderer.ChessBoardRenderer.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Render a piece move.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\nvoid doPly(Ply ply);'),(382,'PiecesLayer piecesLayer','de.java_chess.javaChess.renderer2d.PiecesLayer',94,83,'de.java_chess.javaChess.renderer2d.AnimationLayer',611,'de.java_chess.javaChess.renderer2d.AnimationLayer.-init-(de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'// Constructors\r\n/**\r\n * Create a new AnimationLayer instance.\r\n *\r\n * @param piecesLayer\r\n * 		The layer with the pieces.\r\n */\r\nAnimationLayer(PiecesLayer piecesLayer) {\r\n    setPiecesLayer(piecesLayer);\r\n}'),(383,'Ply ply','de.java_chess.javaChess.ply.Ply',75,83,'de.java_chess.javaChess.renderer2d.AnimationLayer',612,'de.java_chess.javaChess.renderer2d.AnimationLayer.animatePly(de.java_chess.javaChess.ply.Ply)',0,'// Methods\r\n/**\r\n * Animate the move of a piece.\r\n */\r\nvoid animatePly(Ply ply) {\r\n    _ply = ply;\r\n}'),(384,'PiecesLayer piecesLayer','de.java_chess.javaChess.renderer2d.PiecesLayer',94,83,'de.java_chess.javaChess.renderer2d.AnimationLayer',615,'de.java_chess.javaChess.renderer2d.AnimationLayer.setPiecesLayer(de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'/**\r\n * Set a new pieces layer.\r\n *\r\n * @param piecesLayer\r\n * 		The new pieces layer.\r\n */\r\nvoid setPiecesLayer(PiecesLayer piecesLayer) {\r\n    _piecesLayer = piecesLayer;\r\n}'),(385,'Graphics g','java.awt.Graphics',0,84,'de.java_chess.javaChess.renderer2d.BoardLayer',623,'de.java_chess.javaChess.renderer2d.BoardLayer.paintComponent(java.awt.Graphics)',0,'// Methods\r\npublic void paintComponent(Graphics g) {\r\n    // g.setColor( new Color( 190, 190, 140) );\r\n    // g.setColor( new Color( 229, 229, 225) );\r\n    g.setColor(new Color(247, 247, 245));\r\n    g.fillRect(0, 0, _boardSize, _boardSize);\r\n    // g.setColor( new Color( 122, 80, 44));\r\n    // g.setColor( new Color( 250, 105, 86));\r\n    // g.setColor( new Color( 235, 142, 9));\r\n    g.setColor(new Color(249, 134, 89));\r\n    for (int i = 0; i < 8; i++)\r\n        for (int j = 0; j < 8; j++)\r\n            if (((i % 2) != 0) && ((j % 2) == 0))\r\n                g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n            else\r\n                if (((i % 2) == 0) && ((j % 2) != 0))\r\n                    g.fillRect((i * (_squareSize)), (j * (_squareSize)), _squareSize, _squareSize);\r\n\r\n\r\n\r\n\r\n}'),(386,'GameController controller','de.java_chess.javaChess.GameController',1,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',624,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)',0,'// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * 		The game controller.\r\n * @param board\r\n * 		The current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}'),(387,'Board board','de.java_chess.javaChess.board.Board',13,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',624,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.board.Board)',0,'// Constructors\r\n/**\r\n * Create a new renderer instance.\r\n *\r\n * @param controller\r\n * 		The game controller.\r\n * @param board\r\n * 		The current board.\r\n */\r\npublic ChessBoardRenderer2D(GameController controller, Board board) {\r\n    setBoard(board);// Store the board in a class variable.\r\n\r\n    // Use a boarder layout for the entire component, since it holds\r\n    // more that the chessboard itself.\r\n    setLayout(new BorderLayout());\r\n    // Add the row numbers to the board.\r\n    JPanel rowNumbers = new JPanel();\r\n    rowNumbers.setLayout(new GridLayout(8, 1));\r\n    rowNumbers.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    for (int i = 8; i > 0; i--) {\r\n        rowNumbers.add(new JLabel((\"\" + i), JLabel.CENTER));\r\n    }\r\n    add(rowNumbers, BorderLayout.WEST);\r\n    // Add the board itself.\r\n    JLayeredPane boardPane = new JLayeredPane();\r\n    boardPane.setPreferredSize(new Dimension((8 * (ChessBoardRenderer2D._squareSize)), (8 * (ChessBoardRenderer2D._squareSize))));\r\n    boardPane.setOpaque(false);\r\n    // The squares of the board are drawn on the board layer.\r\n    boardPane.add(new BoardLayer(), JLayeredPane.DEFAULT_LAYER);\r\n    // The next layer holds the pieces.\r\n    boardPane.add((_piecesLayer = new PiecesLayer(getBoard())), JLayeredPane.PALETTE_LAYER);\r\n    // The next layer holds the control markers, when the user moves a piece.\r\n    if (controller != null)\r\n        boardPane.add((_controlLayer = new ControlLayer(controller, _piecesLayer)), JLayeredPane.MODAL_LAYER);\r\n\r\n    // The next layer shows the animated pieces.\r\n    boardPane.add(_piecesLayer.getAnimationLayer(), JLayeredPane.DRAG_LAYER);\r\n    add(boardPane);\r\n    // Add the line names to the board\r\n    JPanel lineNames = new JPanel();\r\n    lineNames.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));\r\n    lineNames.setPreferredSize(new Dimension(((8 * (ChessBoardRenderer2D._squareSize)) + ((ChessBoardRenderer2D._squareSize) / 2)), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    JLabel placeHolder = new JLabel();\r\n    placeHolder.setPreferredSize(new Dimension(((ChessBoardRenderer2D._squareSize) / 2), ((ChessBoardRenderer2D._squareSize) / 2)));\r\n    lineNames.add(placeHolder);\r\n    byte[] name = new byte[1];\r\n    for (int i = 0; i < 8; i++) {\r\n        name[0] = ((byte) (a + i));\r\n        JLabel nameLabel = new JLabel(new String(name), JLabel.CENTER);\r\n        nameLabel.setPreferredSize(new Dimension(ChessBoardRenderer2D._squareSize, ((ChessBoardRenderer2D._squareSize) / 2)));\r\n        lineNames.add(nameLabel);\r\n    }\r\n    add(lineNames, BorderLayout.SOUTH);\r\n}'),(388,'Ply ply','de.java_chess.javaChess.ply.Ply',75,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',626,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Render a ply (the move of a piece).\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    _piecesLayer.doPly(ply);\r\n    repaint();\r\n}'),(389,'Board board','de.java_chess.javaChess.board.Board',13,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',634,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.setBoard(de.java_chess.javaChess.board.Board)',0,'/**\r\n * Set a new board.\r\n *\r\n * @param board\r\n * 		The new board.\r\n */\r\npublic final void setBoard(Board board) {\r\n    _board = board;\r\n}'),(390,'Component c','java.awt.Component',0,86,'de.java_chess.javaChess.renderer2d.ChessSet',635,'de.java_chess.javaChess.renderer2d.ChessSet.-init-(java.awt.Component)',0,'// Instance variables\r\n// Constructors\r\n/**\r\n * Create a new chess set component.\r\n *\r\n * @param c\r\n * 		The parent component.\r\n */\r\npublic ChessSet(Component c) {\r\n    super(240, 80, BufferedImage.TYPE_INT_ARGB);\r\n    Image im = null;\r\n    // try {\r\n    // URL url = getClass().getResource(\"ChessPieces_neu.gif\");\r\n    // im = Toolkit.getDefaultToolkit().getImage( url );\r\n    // im = Toolkit.getDefaultToolkit().getImage( new URL( \"jar:file:javaChess.jar!/de/java_chess/javaChess/renderer2d/images/ChessPieces02.gif\"));\r\n    // +++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // original\r\n    // im = ResourceLoader.getInstance().loadImage( \"ChessPieces02.gif\");\r\n    // achraf\r\n    URL urlStart = getClass().getResource(\"images/ChessPieces02.gif\");\r\n    im = Toolkit.getDefaultToolkit().getImage(urlStart);\r\n    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // } catch( MalformedURLException ignored) {}\r\n    MediaTracker mT = new MediaTracker(c);\r\n    mT.addImage(im, 0);\r\n    try {\r\n        mT.waitForID(0);\r\n    } catch (InterruptedException ie) {\r\n    }\r\n    Graphics g = getGraphics();\r\n    g.drawImage(im, 0, 0, c);\r\n}'),(391,'GameController controller','de.java_chess.javaChess.GameController',1,87,'de.java_chess.javaChess.renderer2d.ControlLayer',636,'de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}'),(392,'PiecesLayer pl','de.java_chess.javaChess.renderer2d.PiecesLayer',94,87,'de.java_chess.javaChess.renderer2d.ControlLayer',636,'de.java_chess.javaChess.renderer2d.ControlLayer.-init-(de.java_chess.javaChess.GameController,de.java_chess.javaChess.renderer2d.PiecesLayer)',0,'// Constructors\r\nControlLayer(GameController controller, PiecesLayer pl) {\r\n    setController(controller);\r\n    _squareSize = ChessBoardRenderer2D.getSquareSize();\r\n    _boardSize = 8 * (_squareSize);\r\n    setLayout(null);\r\n    setOpaque(false);\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    _piecesLayer = pl;\r\n    addMouseListener(new MouseAdapter() {\r\n        public void mouseClicked(MouseEvent e) {\r\n            if ((_sourceSquare) == (-1)) {\r\n                _sourceSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                repaint();\r\n            } else {\r\n                final int destSquare = (8 * (7 - ((e.getY()) / (_squareSize)))) + ((e.getX()) / (_squareSize));\r\n                new Thread(new Runnable() {\r\n                    public void run() {\r\n                        // The capture flag is added by the game controller(!).\r\n                        getController().userPly(new PlyImpl(new PositionImpl(_sourceSquare), new PositionImpl(destSquare), false));\r\n                        _sourceSquare = -1;\r\n                        repaint();\r\n                    }\r\n                }).start();\r\n                // getController().userPly( new PlyImpl( new PositionImpl( _sourceSquare), new PositionImpl( destSquare)));\r\n                // _sourceSquare = -1;\r\n                // repaint();\r\n            }\r\n        }\r\n    });\r\n}'),(393,'Graphics g','java.awt.Graphics',0,87,'de.java_chess.javaChess.renderer2d.ControlLayer',640,'de.java_chess.javaChess.renderer2d.ControlLayer.paintComponent(java.awt.Graphics)',0,'// Methods\r\n/**\r\n * Overridden  paintComponent method to draw the marker for\r\n * the source square.\r\n *\r\n * @param g\r\n * 		The graphics context.\r\n */\r\npublic void paintComponent(Graphics g) {\r\n    if ((_sourceSquare) != (-1)) {\r\n        // If a source square is selected,\r\n        markSquare(_sourceSquare, g);// mark it.\r\n\r\n    }\r\n}'),(394,'int square','int',0,87,'de.java_chess.javaChess.renderer2d.ControlLayer',639,'de.java_chess.javaChess.renderer2d.ControlLayer.markSquare(int,java.awt.Graphics)',0,'/**\r\n * Draw a marker at the given square.\r\n *\r\n * @param square\r\n * 		The square to mark.\r\n * @param g\r\n * 		The graphics context.\r\n */\r\nprivate final void markSquare(int square, Graphics g) {\r\n    int xpos = (square & 7) * (_squareSize);\r\n    // Compute the location of the\r\n    int ypos = (7 - (square >> 3)) * (_squareSize);// square\r\n\r\n    int rectSize = (_squareSize) - 1;\r\n    // and its size.\r\n    g.setColor(Color.blue);\r\n    // Simply draw a blue frame there.\r\n    for (int i = 0; i < 3; i++) {\r\n        g.drawRect((xpos++), (ypos++), rectSize, rectSize);\r\n        rectSize -= 2;\r\n    }\r\n}'),(395,'Graphics g','java.awt.Graphics',0,87,'de.java_chess.javaChess.renderer2d.ControlLayer',639,'de.java_chess.javaChess.renderer2d.ControlLayer.markSquare(int,java.awt.Graphics)',0,'/**\r\n * Draw a marker at the given square.\r\n *\r\n * @param square\r\n * 		The square to mark.\r\n * @param g\r\n * 		The graphics context.\r\n */\r\nprivate final void markSquare(int square, Graphics g) {\r\n    int xpos = (square & 7) * (_squareSize);\r\n    // Compute the location of the\r\n    int ypos = (7 - (square >> 3)) * (_squareSize);// square\r\n\r\n    int rectSize = (_squareSize) - 1;\r\n    // and its size.\r\n    g.setColor(Color.blue);\r\n    // Simply draw a blue frame there.\r\n    for (int i = 0; i < 3; i++) {\r\n        g.drawRect((xpos++), (ypos++), rectSize, rectSize);\r\n        rectSize -= 2;\r\n    }\r\n}'),(396,'GameController controller','de.java_chess.javaChess.GameController',1,87,'de.java_chess.javaChess.renderer2d.ControlLayer',641,'de.java_chess.javaChess.renderer2d.ControlLayer.setController(de.java_chess.javaChess.GameController)',0,'/**\r\n * Set a new game controller.\r\n *\r\n * @param The\r\n * 		new game controller.\r\n */\r\nprivate final void setController(GameController controller) {\r\n    _controller = controller;\r\n}'),(397,'ActionListener listener','java.awt.event.ActionListener',0,88,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel',643,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel.addActionListener(java.awt.event.ActionListener)',0,'// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}'),(398,'ActionEvent event','java.awt.event.ActionEvent',0,88,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel',647,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel.notifyListeners(java.awt.event.ActionEvent)',0,'/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * 		The action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}'),(399,'int time','int',0,88,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel',649,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel.setCountdown(int)',0,'/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * 		The length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    // _startTime = -1L;\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}'),(400,'long time','long',0,88,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel',645,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel.display(long)',0,'/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * 		The current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, CountdownTimerPanel._displayWidth, CountdownTimerPanel._displayHeight);\r\n}'),(401,'String newText','java.lang.String',0,89,'de.java_chess.javaChess.renderer2d.EnginePanel',655,'de.java_chess.javaChess.renderer2d.EnginePanel.modifyText(java.lang.String)',0,'/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * 		The text to add\r\n */\r\npublic final void modifyText(String newText) {\r\n    String sCurrentText = getText();\r\n    if (!(sCurrentText.equals(\"\"))) {\r\n        setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtEngine.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        setText(newText);\r\n    }\r\n}'),(402,'String newText','java.lang.String',0,89,'de.java_chess.javaChess.renderer2d.EnginePanel',656,'de.java_chess.javaChess.renderer2d.EnginePanel.setText(java.lang.String)',0,'/**\r\n * Set the current text of the engine panel.\r\n *\r\n * @param newText\r\n * 		The new text to set.\r\n */\r\npublic final void setText(String newText) {\r\n    this.jtEngine.setText(newText);\r\n}'),(403,'int maxTime','int',0,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',658,'de.java_chess.javaChess.renderer2d.GameTimerPanel.-init-(int)',0,'/**\r\n * Create a given game timer with a countdown time.\r\n *\r\n * @param maxTime\r\n * 		The remaining time.\r\n */\r\npublic GameTimerPanel(int maxTime) {\r\n    this();\r\n    setCountdown(maxTime);\r\n}'),(404,'int time','int',0,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',664,'de.java_chess.javaChess.renderer2d.GameTimerPanel.reset(int)',0,'// Methods\r\n/**\r\n * Reset to a given time.\r\n *\r\n * @param time\r\n * 		The time to reset to.\r\n */\r\npublic void reset(int time) {\r\n    stop();// Stop the timer.\r\n\r\n    setCountdown(time);\r\n    setNoClockRunning();\r\n}'),(405,'int time','int',0,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',666,'de.java_chess.javaChess.renderer2d.GameTimerPanel.setCountdown(int)',0,'/**\r\n * Set the remaining time for each timer.\r\n *\r\n * @param time\r\n * 		The remaining time for each time.\r\n */\r\npublic void setCountdown(int time) {\r\n    _white.setCountdown(time);\r\n    _black.setCountdown(time);\r\n}'),(406,'ActionEvent event','java.awt.event.ActionEvent',0,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',659,'de.java_chess.javaChess.renderer2d.GameTimerPanel.actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * Get a event from one of the timers.\r\n *\r\n * ActionEvent event The event.\r\n */\r\npublic void actionPerformed(ActionEvent event) {\r\n    if (!(\"interrupted\".equals(event.getActionCommand()))) {\r\n        // This event means, that the timer sending the event has stopped,\r\n        // so stop the entire timer for now.\r\n        stop();\r\n        notifyListeners(new ActionEvent(this, ActionEvent.ACTION_PERFORMED, ((event.getSource()) == (_white) ? \"timeout white\" : \"timeout black\")));\r\n    }\r\n}'),(407,'ActionListener listener','java.awt.event.ActionListener',0,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',660,'de.java_chess.javaChess.renderer2d.GameTimerPanel.addActionListener(java.awt.event.ActionListener)',0,'/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}'),(408,'ActionEvent event','java.awt.event.ActionEvent',0,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',663,'de.java_chess.javaChess.renderer2d.GameTimerPanel.notifyListeners(java.awt.event.ActionEvent)',0,'/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * 		The action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}'),(409,'boolean active','boolean',0,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',668,'de.java_chess.javaChess.renderer2d.GameTimerPanel.setRunning(boolean)',0,'/**\r\n * Set the new running state of the timer.\r\n *\r\n * @param active\r\n * 		The new state of the timer panel.\r\n */\r\npublic void setRunning(boolean active) {\r\n    _running = active;\r\n}'),(410,'ActionEvent ae','java.awt.event.ActionEvent',0,91,'de.java_chess.javaChess.renderer2d.NavigationPanel',674,'de.java_chess.javaChess.renderer2d.NavigationPanel.actionPerformed(java.awt.event.ActionEvent)',0,'/**\r\n * React on mouseclick\r\n */\r\npublic void actionPerformed(ActionEvent ae) {\r\n    if (ae.getSource().equals(jbStart))\r\n        moveToStart();\r\n\r\n    if (ae.getSource().equals(jbBack))\r\n        moveOnePlyBack();\r\n\r\n    if (ae.getSource().equals(jbForward))\r\n        moveOnePlyForward();\r\n\r\n    if (ae.getSource().equals(jbEnd))\r\n        moveToEnd();\r\n\r\n}'),(411,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,92,'de.java_chess.javaChess.renderer2d.NotationPanel',680,'de.java_chess.javaChess.renderer2d.NotationPanel.-init-(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Standardconstructor\r\n */\r\npublic NotationPanel(GameNotation gameNotation) {\r\n    super();\r\n    // Store the game notation in this instance.\r\n    setGameNotation(gameNotation);\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(412,'String newText','java.lang.String',0,92,'de.java_chess.javaChess.renderer2d.NotationPanel',685,'de.java_chess.javaChess.renderer2d.NotationPanel.modifyText(java.lang.String)',0,'/**\r\n * Adds the given text to the existing\r\n *\r\n * @param newText\r\n * 		The text to add\r\n */\r\npublic void modifyText(String newText) {\r\n    String sCurrentText = this.jtNotation.getText();\r\n    if ((sCurrentText.equals(\"\")) == false) {\r\n        this.jtNotation.setText(((sCurrentText + \"\n\") + newText));\r\n        Point point = new Point(0, ((int) (this.jtNotation.getSize().getHeight())));\r\n        this.jScrollPane.getViewport().setViewPosition(point);\r\n    } else {\r\n        this.jtNotation.setText(newText);\r\n    }\r\n}'),(413,'GameNotation gameNotation','de.java_chess.javaChess.notation.GameNotation',55,92,'de.java_chess.javaChess.renderer2d.NotationPanel',687,'de.java_chess.javaChess.renderer2d.NotationPanel.setGameNotation(de.java_chess.javaChess.notation.GameNotation)',0,'/**\r\n * Set a new notation object.\r\n *\r\n * @param gameNotation\r\n * 		The new game notation.\r\n */\r\npublic void setGameNotation(GameNotation gameNotation) {\r\n    _gameNotation = gameNotation;\r\n}'),(414,'String newNotation','java.lang.String',0,92,'de.java_chess.javaChess.renderer2d.NotationPanel',688,'de.java_chess.javaChess.renderer2d.NotationPanel.setText(java.lang.String)',0,'/**\r\n * Set a new notation.\r\n *\r\n * @param newNotation\r\n * 		The new notation.\r\n */\r\npublic void setText(String newNotation) {\r\n    this.jtNotation.setText(newNotation);\r\n}'),(415,'String newName','java.lang.String',0,92,'de.java_chess.javaChess.renderer2d.NotationPanel',689,'de.java_chess.javaChess.renderer2d.NotationPanel.setWhitePlayerName(java.lang.String)',0,'/**\r\n * Sets the white players name\r\n *\r\n * @param newName\r\n * 		The new string for the white player\r\n */\r\npublic void setWhitePlayerName(String newName) {\r\n    this.jbWhite.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, true);\r\n    }\r\n}'),(416,'String newName','java.lang.String',0,92,'de.java_chess.javaChess.renderer2d.NotationPanel',686,'de.java_chess.javaChess.renderer2d.NotationPanel.setBlackPlayerName(java.lang.String)',0,'/**\r\n * Sets the black players name\r\n *\r\n * @param newName\r\n * 		The new string for the black player\r\n */\r\npublic void setBlackPlayerName(String newName) {\r\n    this.jbBlack.setText(newName);\r\n    // If theres a notation object, pass the new name to it.\r\n    if ((_gameNotation) != null) {\r\n        _gameNotation.setPlayerInfo(newName, false);\r\n    }\r\n}'),(417,'ActionEvent e','java.awt.event.ActionEvent',0,92,'de.java_chess.javaChess.renderer2d.NotationPanel',681,'de.java_chess.javaChess.renderer2d.NotationPanel.actionPerformed(java.awt.event.ActionEvent)',0,'public void actionPerformed(ActionEvent e) {\r\n    boolean bWhiteOrBlack = true;\r\n    PlayerDialog playerDialog = null;\r\n    if (e.getSource().equals(jbWhite)) {\r\n        playerDialog = new PlayerDialog(1, getWhitePlayerName());\r\n        bWhiteOrBlack = true;\r\n    } else\r\n        if (e.getSource().equals(jbBlack)) {\r\n            playerDialog = new PlayerDialog(2, getBlackPlayerName());\r\n            bWhiteOrBlack = false;\r\n        }\r\n\r\n    if (playerDialog != null) {\r\n        Tools.setDialogToCenter(playerDialog);\r\n        playerDialog.show();\r\n        if (bWhiteOrBlack == true) {\r\n            jbWhite.setText(playerDialog.getNewName());\r\n        } else {\r\n            jbBlack.setText(playerDialog.getNewName());\r\n        }\r\n    }\r\n}'),(418,'byte color','byte',0,93,'de.java_chess.javaChess.renderer2d.PieceRenderer',690,'de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)',0,'// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * 		The color of the piece.\r\n * @param piece\r\n * 		The type of the piece.\r\n * @param set\r\n * 		The set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}'),(419,'byte piece','byte',0,93,'de.java_chess.javaChess.renderer2d.PieceRenderer',690,'de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)',0,'// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * 		The color of the piece.\r\n * @param piece\r\n * 		The type of the piece.\r\n * @param set\r\n * 		The set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}'),(420,'ChessSet set','de.java_chess.javaChess.renderer2d.ChessSet',86,93,'de.java_chess.javaChess.renderer2d.PieceRenderer',690,'de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)',0,'// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * 		The color of the piece.\r\n * @param piece\r\n * 		The type of the piece.\r\n * @param set\r\n * 		The set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}'),(421,'Component c','java.awt.Component',0,93,'de.java_chess.javaChess.renderer2d.PieceRenderer',690,'de.java_chess.javaChess.renderer2d.PieceRenderer.-init-(byte,byte,de.java_chess.javaChess.renderer2d.ChessSet,java.awt.Component)',0,'// Constructors\r\n/**\r\n * Create a new piece renderer instance.\r\n *\r\n * @param color\r\n * 		The color of the piece.\r\n * @param piece\r\n * 		The type of the piece.\r\n * @param set\r\n * 		The set of chess pieces.\r\n * @unknown The parent component.\r\n */\r\npublic PieceRenderer(byte color, byte piece, ChessSet set, Component c) {\r\n    super(40, 40, BufferedImage.TYPE_INT_ARGB);\r\n    _piece = piece;\r\n    _color = color;\r\n    PieceRenderer._set = set;\r\n    Graphics g = getGraphics();\r\n    g.drawImage(PieceRenderer._set.getSubimage((((_piece) - 1) * 40), ((_color) * 40), 40, 40), 0, 0, c);\r\n}'),(422,'Board board','de.java_chess.javaChess.board.Board',13,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',691,'de.java_chess.javaChess.renderer2d.PiecesLayer.-init-(de.java_chess.javaChess.board.Board)',0,'PiecesLayer(Board board) {\r\n    super(new GridLayout(8, 8));\r\n    _set = new ChessSet(this);\r\n    _animationLayer = new AnimationLayer(this);\r\n    _board = board;\r\n    int _boardSize = 8 * (ChessBoardRenderer2D.getSquareSize());\r\n    setPreferredSize(new Dimension(_boardSize, _boardSize));\r\n    setBounds(0, 0, _boardSize, _boardSize);\r\n    setOpaque(false);\r\n    repaintBoard();\r\n}'),(423,'Ply ply','de.java_chess.javaChess.ply.Ply',75,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',693,'de.java_chess.javaChess.renderer2d.PiecesLayer.doPly(de.java_chess.javaChess.ply.Ply)',0,'/**\r\n * Render a ply.\r\n *\r\n * @param ply\r\n * 		The ply to render.\r\n */\r\npublic final void doPly(Ply ply) {\r\n    if (_animatedMoves) {\r\n        getAnimationLayer().animatePly(ply);\r\n        getAnimationLayer().start();\r\n        repaint();\r\n    } else {\r\n        // Check, if it was a castling\r\n        if (ply instanceof CastlingPly) {\r\n            int source = ply.getSource().getSquareIndex();\r\n            if (((CastlingPly) (ply)).isLeftCastling()) {\r\n                _square[(source - 2)].getPieceFrom(_square[source]);\r\n                _square[(source - 1)].getPieceFrom(_square[(source - 4)]);// Move the rook to the right\r\n\r\n            } else {\r\n                _square[(source + 2)].getPieceFrom(_square[source]);\r\n                _square[(source + 1)].getPieceFrom(_square[(source + 3)]);// Move the rook to the left\r\n\r\n            }\r\n        } else {\r\n            // If a pawn has just reached the last row\r\n            if (ply instanceof TransformationPly) {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // Now change the rendering to the new piece type.\r\n                _square[ply.getDestination().getSquareIndex()].setIcon(new ImageIcon(new PieceRenderer(((ply.getDestination().getSquareIndex()) < 8 ? Piece.BLACK : Piece.WHITE), ((TransformationPly) (ply)).getTypeAfterTransformation(), _set, this)));\r\n            } else {\r\n                // Copy the piece from source square to destination square.\r\n                _square[ply.getDestination().getSquareIndex()].getPieceFrom(_square[ply.getSource().getSquareIndex()]);\r\n                // If its a en passant ply, remove the attacked pawn.\r\n                if (ply instanceof EnPassantPly) {\r\n                    _square[((EnPassantPly) (ply)).getAttackedPosition().getSquareIndex()].setIcon(null);\r\n                }\r\n            }\r\n        }\r\n        repaint();\r\n    }\r\n}'),(424,'int squareIndex','int',0,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',695,'de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)',0,'/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * 		The index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}'),(425,'de.java_chess.javaChess.renderer2d.PositionRenderer','de.java_chess.javaChess.renderer2d.PositionRenderer',95,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',695,'de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)',1,'/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * 		The index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}'),(426,'Image image','java.awt.Image',0,95,'de.java_chess.javaChess.renderer2d.PositionRenderer',698,'de.java_chess.javaChess.renderer2d.PositionRenderer.-init-(java.awt.Image)',0,'/**\r\n * Create a new position rendering with a given image of a piece.\r\n *\r\n * image The image for the rendering.\r\n */\r\nPositionRenderer(Image image) {\r\n    super(new ImageIcon(image));\r\n}'),(427,'PositionRenderer positionRenderer','de.java_chess.javaChess.renderer2d.PositionRenderer',95,95,'de.java_chess.javaChess.renderer2d.PositionRenderer',699,'de.java_chess.javaChess.renderer2d.PositionRenderer.getPieceFrom(de.java_chess.javaChess.renderer2d.PositionRenderer)',0,'// Methods\r\n/**\r\n * Move a piece from another position to this one.\r\n *\r\n * positionRenderer The position renderer for the source.\r\n */\r\nvoid getPieceFrom(PositionRenderer positionRenderer) {\r\n    setIcon(positionRenderer.getIcon());\r\n    positionRenderer.setIcon(null);\r\n}'),(428,'ImageIcon icon','javax.swing.ImageIcon',0,95,'de.java_chess.javaChess.renderer2d.PositionRenderer',700,'de.java_chess.javaChess.renderer2d.PositionRenderer.setIcon(javax.swing.ImageIcon)',0,'/**\r\n * Set a new icon and align it properly.\r\n *\r\n * @param icon\r\n * 		The new icon.\r\n */\r\npublic void setIcon(ImageIcon icon) {\r\n    super.setIcon(icon);\r\n    if (icon != null) {\r\n        invalidate();\r\n    } else {\r\n        revalidate();\r\n    }\r\n}'),(429,'String sVersionNumber','java.lang.String',0,96,'de.java_chess.javaChess.renderer2d.StatusPanel',702,'de.java_chess.javaChess.renderer2d.StatusPanel.-init-(java.lang.String)',0,'public StatusPanel(String sVersionNumber) {\r\n    this.sVersion = sVersionNumber;\r\n    try {\r\n        jbInit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}'),(430,'String newStatusText','java.lang.String',0,96,'de.java_chess.javaChess.renderer2d.StatusPanel',705,'de.java_chess.javaChess.renderer2d.StatusPanel.setStatusText(java.lang.String)',0,'public void setStatusText(String newStatusText) {\r\n    this.jlStatus.setText(newStatusText);\r\n}'),(431,'String newActionText','java.lang.String',0,96,'de.java_chess.javaChess.renderer2d.StatusPanel',704,'de.java_chess.javaChess.renderer2d.StatusPanel.setActionText(java.lang.String)',0,'public void setActionText(String newActionText) {\r\n    this.jlAction.setText(newActionText);\r\n}'),(432,'String newVersionText','java.lang.String',0,96,'de.java_chess.javaChess.renderer2d.StatusPanel',706,'de.java_chess.javaChess.renderer2d.StatusPanel.setVersionInfo(java.lang.String)',0,'public void setVersionInfo(String newVersionText) {\r\n    this.jlVersion.setText(newVersionText);\r\n}'),(433,'boolean countdown','boolean',0,97,'de.java_chess.javaChess.renderer2d.TimerPanel',707,'de.java_chess.javaChess.renderer2d.TimerPanel.-init-(boolean)',0,'// Constructors\r\n/**\r\n * Create a new timer panel.\r\n *\r\n * @param countdown\r\n * 		Flag to indicate, if we count downwards.\r\n */\r\npublic TimerPanel(boolean countdown) {\r\n    setCountingDirection(countdown);\r\n    _actionListeners = new ArrayList();\r\n    _display = new JLabel(\"0:00:00\", JLabel.RIGHT);\r\n    _display.setPreferredSize(new Dimension(TimerPanel._displayWidth, TimerPanel._displayHeight));\r\n    _display.setHorizontalTextPosition(SwingConstants.CENTER);\r\n    add(_display);\r\n}'),(434,'ActionListener listener','java.awt.event.ActionListener',0,97,'de.java_chess.javaChess.renderer2d.TimerPanel',708,'de.java_chess.javaChess.renderer2d.TimerPanel.addActionListener(java.awt.event.ActionListener)',0,'// Methods\r\n/**\r\n * Add a action listener to this timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\npublic void addActionListener(ActionListener listener) {\r\n    _actionListeners.add(listener);\r\n}'),(435,'ActionEvent event','java.awt.event.ActionEvent',0,97,'de.java_chess.javaChess.renderer2d.TimerPanel',713,'de.java_chess.javaChess.renderer2d.TimerPanel.notifyListeners(java.awt.event.ActionEvent)',0,'/**\r\n * Notify the waiting action listeners.\r\n *\r\n * @param event\r\n * 		The action event to send.\r\n */\r\nprivate void notifyListeners(ActionEvent event) {\r\n    // Iterate over all the listeners and send them the event.\r\n    for (Iterator iterator = _actionListeners.iterator(); iterator.hasNext();) {\r\n        ActionListener listener = ((ActionListener) (iterator.next()));\r\n        listener.actionPerformed(event);\r\n    }\r\n}'),(436,'int time','int',0,97,'de.java_chess.javaChess.renderer2d.TimerPanel',715,'de.java_chess.javaChess.renderer2d.TimerPanel.setCountdown(int)',0,'/**\r\n * Set the length of the countdown in seconds.\r\n *\r\n * @param time\r\n * 		The length of the countdown.\r\n */\r\npublic void setCountdown(int time) {\r\n    _remainingTime = _time = 1000L * ((long) (time));\r\n    display(_time);\r\n}'),(437,'long time','long',0,97,'de.java_chess.javaChess.renderer2d.TimerPanel',710,'de.java_chess.javaChess.renderer2d.TimerPanel.display(long)',0,'/**\r\n * Display the current time.\r\n *\r\n * @param time\r\n * 		The current time in milliseconds.\r\n */\r\nvoid display(long time) {\r\n    // Dont display negative time.\r\n    if (time < 0L) {\r\n        time = 0L;\r\n    }\r\n    if (!(isCountdown())) {\r\n        time = (_time) - time;\r\n    }\r\n    int timeSec = ((int) (time / 1000L));// Display accurate to  1 s.\r\n\r\n    StringBuffer timeString = new StringBuffer();\r\n    int hours = timeSec / 3600;\r\n    timeString.append((\"\" + hours));\r\n    int minutes = (timeSec / 60) % 60;\r\n    timeString.append(((minutes < 10 ? \":0\" : \":\") + minutes));\r\n    int seconds = timeSec % 60;\r\n    timeString.append(((seconds < 10 ? \":0\" : \":\") + seconds));\r\n    _display.setText(timeString.toString());\r\n    _display.paintImmediately(0, 0, TimerPanel._displayWidth, TimerPanel._displayHeight);\r\n}'),(438,'boolean countdown','boolean',0,97,'de.java_chess.javaChess.renderer2d.TimerPanel',716,'de.java_chess.javaChess.renderer2d.TimerPanel.setCountingDirection(boolean)',0,'/**\r\n * Set the counting direction.\r\n *\r\n * @param countdown\r\n * 		Flag to indicate, if we want a countdown.\r\n */\r\nprivate final void setCountingDirection(boolean countdown) {\r\n    _countdown = countdown;\r\n}'),(439,'ActionListener listener','java.awt.event.ActionListener',0,99,'de.java_chess.javaChess.timer.GameTimer',721,'de.java_chess.javaChess.timer.GameTimer.addActionListener(java.awt.event.ActionListener)',0,'/**\r\n * Add a action listener to the timer.\r\n *\r\n * @param listener\r\n * 		The action listener to add.\r\n */\r\nvoid addActionListener(ActionListener listener);'),(440,'Object[] items','java.lang.Object[]',0,100,'de.java_chess.javaChess.util.ArrayStackIterator',726,'de.java_chess.javaChess.util.ArrayStackIterator.-init-(java.lang.Object[],int)',0,'// Constructors\r\n/**\r\n * Create a new iterator instance.\r\n *\r\n * @param items\r\n * 		The array with the items.\r\n * @param nItems\r\n * 		The number of items (since the array is most likely longer).\r\n */\r\npublic ArrayStackIterator(Object[] items, int nItems) {\r\n    _items = items;\r\n    _nItems = nItems;\r\n    _curElement = 0;\r\n}'),(441,'int nItems','int',0,100,'de.java_chess.javaChess.util.ArrayStackIterator',726,'de.java_chess.javaChess.util.ArrayStackIterator.-init-(java.lang.Object[],int)',0,'// Constructors\r\n/**\r\n * Create a new iterator instance.\r\n *\r\n * @param items\r\n * 		The array with the items.\r\n * @param nItems\r\n * 		The number of items (since the array is most likely longer).\r\n */\r\npublic ArrayStackIterator(Object[] items, int nItems) {\r\n    _items = items;\r\n    _nItems = nItems;\r\n    _curElement = 0;\r\n}'),(442,'String location','java.lang.String',0,101,'de.java_chess.javaChess.util.ResourceLoader',731,'de.java_chess.javaChess.util.ResourceLoader.addLocation(java.lang.String)',0,'/**\r\n * Add a new location to load resources from.\r\n *\r\n * @param location\r\n * 		The location to use.\r\n */\r\npublic final void addLocation(String location) {\r\n    if (!(location.endsWith(\"/\"))) {\r\n        location += \"/\";\r\n    }\r\n    _locations.add(location);\r\n}'),(443,'String imageName','java.lang.String',0,101,'de.java_chess.javaChess.util.ResourceLoader',733,'de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)',0,'/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}'),(444,'int type','int',0,102,'de.java_chess.javaChess.util.StringTextDocument',734,'de.java_chess.javaChess.util.StringTextDocument.-init-(int,int)',0,'/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * 		The number of allowed character to enter in the JTextField\r\n */\r\npublic StringTextDocument(int type, int characterCount) {\r\n    super();\r\n    iCharacterCount = characterCount;\r\n    iType = type;\r\n}'),(445,'int characterCount','int',0,102,'de.java_chess.javaChess.util.StringTextDocument',734,'de.java_chess.javaChess.util.StringTextDocument.-init-(int,int)',0,'/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * 		The number of allowed character to enter in the JTextField\r\n */\r\npublic StringTextDocument(int type, int characterCount) {\r\n    super();\r\n    iCharacterCount = characterCount;\r\n    iType = type;\r\n}'),(446,'int offset','int',0,102,'de.java_chess.javaChess.util.StringTextDocument',736,'de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)',0,'/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * 		The number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * 		Flag whether the string to enter has to be parsed for\r\n * 		numbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}'),(447,'String s','java.lang.String',0,102,'de.java_chess.javaChess.util.StringTextDocument',736,'de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)',0,'/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * 		The number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * 		Flag whether the string to enter has to be parsed for\r\n * 		numbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}'),(448,'AttributeSet attributeSet','javax.swing.text.AttributeSet',0,102,'de.java_chess.javaChess.util.StringTextDocument',736,'de.java_chess.javaChess.util.StringTextDocument.insertString(int,java.lang.String,javax.swing.text.AttributeSet)',0,'/**\r\n * Constructor\r\n *\r\n * @param characterCount\r\n * 		The number of allowed character to enter in the JTextField\r\n * @param checkForNumbers\r\n * 		Flag whether the string to enter has to be parsed for\r\n * 		numbers >0 only\r\n */\r\n// public StringTextDocument(int characterCount, boolean checkForNumbers)\r\n// {\r\n// super();\r\n// this.iCharacterCount = characterCount;\r\n// this.bCheckForNumbers = checkForNumbers;\r\n// }\r\n/**\r\n * This method has to be overwritten for personal use. The code below is taken\r\n * from the source mentioned in the class description\r\n */\r\npublic void insertString(int offset, String s, AttributeSet attributeSet) throws BadLocationException {\r\n    if (s == null)\r\n        return;\r\n\r\n    String oldString = getText(0, getLength());\r\n    String newString = ((oldString.substring(0, offset)) + s) + (oldString.substring(offset));\r\n    if (canBecomeValid(newString))\r\n        super.insertString(offset, s, attributeSet);\r\n\r\n}'),(449,'String sNewString','java.lang.String',0,102,'de.java_chess.javaChess.util.StringTextDocument',737,'de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)',0,'/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * 		The string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}'),(450,'String s','java.lang.String',0,102,'de.java_chess.javaChess.util.StringTextDocument',735,'de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)',0,'/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * 		The string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}'),(451,'char charToCheck','char',0,102,'de.java_chess.javaChess.util.StringTextDocument',738,'de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)',0,'/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * 		The character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}'),(452,'String sString','java.lang.String',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',0,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(453,'boolean bEnPassantSquare','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',0,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(454,'JDialog dialog','javax.swing.JDialog',0,103,'de.java_chess.javaChess.util.Tools',741,'de.java_chess.javaChess.util.Tools.setDialogToCenter(javax.swing.JDialog)',0,'/**\r\n * Sets the Dialog to the center of the screen\r\n *\r\n * @param dialog\r\n * 		The dialog which is to be centered on the screen\r\n */\r\npublic static void setDialogToCenter(JDialog dialog) {\r\n    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();\r\n    Dimension dialogSize = dialog.getSize();\r\n    dialog.setLocation((((screenSize.width) - (dialogSize.width)) / 2), (((screenSize.height) - (dialogSize.height)) / 2));\r\n}'),(455,'int capacity','int',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',743,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.-init-(int)',0,'/**\r\n * Create a new stack instance with a given initial\r\n * capacity.\r\n *\r\n * @param capacity\r\n * 		The initial capacity.\r\n */\r\npublic UnsynchronizedArrayStack(int capacity) {\r\n    _nItems = 0;\r\n    _items = new Object[capacity];\r\n}'),(456,'Object item','java.lang.Object',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',750,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.push(java.lang.Object)',0,'/**\r\n * Push an item on the stack.\r\n *\r\n * @param item\r\n * 		The item to push on the stack.\r\n */\r\npublic final void push(Object item) {\r\n    try {\r\n        _items[_nItems] = item;\r\n        (_nItems)++;\r\n    } catch (ArrayIndexOutOfBoundsException ae) {\r\n        increaseCapacity();\r\n        push(item);\r\n    }\r\n}'),(457,'Object o','java.lang.Object',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',751,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)',0,'/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}'),(458,'return false','boolean',0,1,'de.java_chess.javaChess.GameController',3,'de.java_chess.javaChess.GameController.computerPly()',1,'/**\r\n * Let the computer make a move.\r\n */\r\npublic final boolean computerPly() {\r\n    Ply nextPly = getEngine().computeBestPly();\r\n    if (nextPly == null) {\r\n        System.out.println(\"No computer move returned\");\r\n        return false;\r\n    } else {\r\n        doPly(nextPly);\r\n        getEngine().startPermanentBrain();\r\n        return true;\r\n    }\r\n}'),(459,'return true','boolean',0,1,'de.java_chess.javaChess.GameController',3,'de.java_chess.javaChess.GameController.computerPly()',1,'/**\r\n * Let the computer make a move.\r\n */\r\npublic final boolean computerPly() {\r\n    Ply nextPly = getEngine().computeBestPly();\r\n    if (nextPly == null) {\r\n        System.out.println(\"No computer move returned\");\r\n        return false;\r\n    } else {\r\n        doPly(nextPly);\r\n        getEngine().startPermanentBrain();\r\n        return true;\r\n    }\r\n}'),(460,'return new CastlingPlyImpl(source, true)','boolean',0,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(461,'return new CastlingPlyImpl(source, false)','boolean',0,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(462,'// Create and return a new transformation ply.\r\nreturn new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null))','de.java_chess.javaChess.ply.TransformationPlyImpl',78,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(463,'return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)))','int',0,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(464,'return ply// Return the original ply\r\n','de.java_chess.javaChess.ply.Ply',75,1,'de.java_chess.javaChess.GameController',4,'de.java_chess.javaChess.GameController.convertUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Try to interpretate a user ply, if its a castling or so.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return The converted ply.\r\n */\r\nprivate final Ply convertUserPly(Ply ply) {\r\n    Position source = ply.getSource();\r\n    Position destination = ply.getDestination();\r\n    Piece piece = getBoard().getPiece(source);\r\n    if (piece != null) {\r\n        // Check, if the user wanted a castling.\r\n        if ((piece.getType()) == (Piece.KING)) {\r\n            int sourceLine = (source.getSquareIndex()) & 7;\r\n            int destinationLine = (destination.getSquareIndex()) & 7;\r\n            // If the castling goes to the left.\r\n            if ((sourceLine - 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, true);\r\n            }\r\n            // If the castling goes to the right.\r\n            if ((sourceLine + 2) == destinationLine) {\r\n                return new CastlingPlyImpl(source, false);\r\n            }\r\n        } else {\r\n            // Check if this is a transformation ply\r\n            if ((piece.getType()) == (Piece.PAWN)) {\r\n                int destinationRow = (destination.getSquareIndex()) >> 3;\r\n                // If the pawn reached the last row\r\n                if (destinationRow == 7) {\r\n                    TransformationDialog.getInstance().show();\r\n                    byte pieceType = TransformationDialog.getInstance().getPieceType();\r\n                    // Create and return a new transformation ply.\r\n                    return new TransformationPlyImpl(source, destination, pieceType, ((getBoard().getPiece(destination)) != null));\r\n                } else {\r\n                    int sourceLine = (source.getSquareIndex()) & 7;\r\n                    int sourceRow = (source.getSquareIndex()) >> 3;\r\n                    int destinationLine = (destination.getSquareIndex()) & 7;\r\n                    if (((sourceRow == 4) && (destinationRow == 5)) && (1 == (Math.abs((sourceLine - destinationLine))))) {\r\n                        Ply lastPly = _game.getLastPly();\r\n                        if ((((lastPly != null) && ((lastPly.getSource().getSquareIndex()) == ((destination.getSquareIndex()) + 8))) && ((lastPly.getDestination().getSquareIndex()) == ((destination.getSquareIndex()) - 8))) && ((getBoard().getPiece(lastPly.getDestination()).getType()) == (Piece.PAWN))) {\r\n                            return new EnPassantPlyImpl(source, destination, new PositionImpl(((destination.getSquareIndex()) - 8)));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // Set the capture flag properly.\r\n    ((PlyImpl) (ply)).setCapture(((getBoard().getPiece(destination)) != null));\r\n    return ply;// Return the original ply\r\n\r\n}'),(465,'return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW))','boolean',0,1,'de.java_chess.javaChess.GameController',6,'de.java_chess.javaChess.GameController.gameOver(boolean)',1,'/**\r\n * Check if the game is over.\r\n *\r\n * @param white\r\n * 		True, if white is about to move.\r\n * @return true, if the game is over.\r\n */\r\nprivate final boolean gameOver(boolean white) {\r\n    _gameState = getEngine().getCurrentGameState(white);\r\n    return ((_gameState) == (GameState.CHECKMATE)) || ((_gameState) == (GameState.DRAW));\r\n}'),(466,'return _board','de.java_chess.javaChess.GameController',1,1,'de.java_chess.javaChess.GameController',7,'de.java_chess.javaChess.GameController.getBoard()',1,'/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal Board getBoard() {\r\n    return _board;\r\n}'),(467,'return _engine','de.java_chess.javaChess.GameController',1,1,'de.java_chess.javaChess.GameController',8,'de.java_chess.javaChess.GameController.getEngine()',1,'/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nfinal ChessEngine getEngine() {\r\n    return _engine;\r\n}'),(468,'return _game','de.java_chess.javaChess.GameController',1,1,'de.java_chess.javaChess.GameController',9,'de.java_chess.javaChess.GameController.getGame()',1,'// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(469,'return _gameNotation','de.java_chess.javaChess.GameController',1,1,'de.java_chess.javaChess.GameController',10,'de.java_chess.javaChess.GameController.getGameNotation()',1,'/**\r\n * Get the current game notation.\r\n *\r\n * @return The current game notation.\r\n */\r\npublic final GameNotation getGameNotation() {\r\n    return _gameNotation;\r\n}'),(470,'return _gameTimer','de.java_chess.javaChess.GameController',1,1,'de.java_chess.javaChess.GameController',11,'de.java_chess.javaChess.GameController.getGameTimer()',1,'/**\r\n * Get the current game timer.\r\n *\r\n * @return The current game timer.\r\n */\r\nfinal GameTimer getGameTimer() {\r\n    return _gameTimer;\r\n}'),(471,'return _renderer','de.java_chess.javaChess.GameController',1,1,'de.java_chess.javaChess.GameController',12,'de.java_chess.javaChess.GameController.getRenderer()',1,'/**\r\n * Get the renderer.\r\n *\r\n * @return The current renderer.\r\n */\r\nfinal ChessBoardRenderer getRenderer() {\r\n    return _renderer;\r\n}'),(472,'return JavaChess._instance','de.java_chess.javaChess.JavaChess',3,3,'de.java_chess.javaChess.JavaChess',28,'de.java_chess.javaChess.JavaChess.getInstance()',1,'/**\r\n * Get the instance of this chess app.\r\n *\r\n * @return The instance of this chess app.\r\n */\r\npublic static final JavaChess getInstance() {\r\n    return JavaChess._instance;\r\n}'),(473,'return item','javax.swing.JMenuItem',0,3,'de.java_chess.javaChess.JavaChess',29,'de.java_chess.javaChess.JavaChess.getMenuItem(de.java_chess.javaChess.action.JavaChessAction)',1,'/**\r\n * Create a return a menu item for a given action.\r\n *\r\n * @param action\r\n * 		The action.\r\n * @return The menu item for this action.\r\n */\r\nprivate JMenuItem getMenuItem(JavaChessAction action) {\r\n    JMenuItem item = new JMenuItem(action.getName());\r\n    item.addActionListener(action);\r\n    return item;\r\n}'),(474,'return this.getSize()','de.java_chess.javaChess.JavaChess',3,3,'de.java_chess.javaChess.JavaChess',32,'de.java_chess.javaChess.JavaChess.packFrame()',1,'private Dimension packFrame() {\r\n    boolean packFrame = true;\r\n    if (packFrame) {\r\n        pack();\r\n    } else {\r\n        validate();\r\n    }\r\n    return this.getSize();\r\n}'),(475,'return getShortDescription()','de.java_chess.javaChess.action.JavaChessAction',6,6,'de.java_chess.javaChess.action.JavaChessAction',43,'de.java_chess.javaChess.action.JavaChessAction.getName()',1,'/**\r\n * Get the name of this action (which is currently the short description).\r\n *\r\n * @return The name of this action.\r\n */\r\npublic final String getName() {\r\n    return getShortDescription();\r\n}'),(476,'return ((String) (getValue(Action.SHORT_DESCRIPTION)))','javax.swing.Action',0,6,'de.java_chess.javaChess.action.JavaChessAction',44,'de.java_chess.javaChess.action.JavaChessAction.getShortDescription()',1,'// Methods\r\n/**\r\n * Get the short description (the name) of this action.\r\n *\r\n * @return The short description of this action.\r\n */\r\npublic String getShortDescription() {\r\n    return ((String) (getValue(Action.SHORT_DESCRIPTION)));\r\n}'),(477,'return SaveGameAsAction._pgnFileFilter','de.java_chess.javaChess.action.SaveGameAsAction',10,10,'de.java_chess.javaChess.action.SaveGameAsAction',55,'de.java_chess.javaChess.action.SaveGameAsAction.getPGNFileFilter()',1,'/**\r\n * Get a PGN file filter.\r\n *\r\n * @return A PGN file filter.\r\n */\r\npublic static PGNFileFilter getPGNFileFilter() {\r\n    // To avoid the instanciation of too many object at app startup,\r\n    // less important object are created as needed.\r\n    if (null == (SaveGameAsAction._pgnFileFilter)) {\r\n        SaveGameAsAction._pgnFileFilter = new PGNFileFilter();\r\n    }\r\n    return SaveGameAsAction._pgnFileFilter;\r\n}'),(478,'return clone','de.java_chess.javaChess.bitboard.BitBoardImpl',12,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',61,'de.java_chess.javaChess.bitboard.BitBoardImpl.clone()',1,'// Methods\r\n/**\r\n * Create a clone of this board.\r\n *\r\n * @return A clone of this board.\r\n */\r\npublic final Object clone() {\r\n    BitBoardImpl clone = new BitBoardImpl();\r\n    for (int i = 0; i < 4; i++) {\r\n        clone._boardLayer[i] = _boardLayer[i];\r\n    }\r\n    return clone;\r\n}'),(479,'return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]))','int',0,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',64,'de.java_chess.javaChess.bitboard.BitBoardImpl.getAllPiecesForColor(boolean)',1,'/**\r\n * Get all white or black pieces.\r\n *\r\n * @param white\r\n * 		true, if the white pieces are requested,\r\n * 		false for the black pieces.\r\n */\r\npublic final long getAllPiecesForColor(boolean white) {\r\n    return (((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3])) & (white ? _boardLayer[0] : ~(_boardLayer[0]));\r\n}'),(480,'return newBoard','de.java_chess.javaChess.bitboard.BitBoard',11,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',65,'de.java_chess.javaChess.bitboard.BitBoardImpl.getBoardAfterPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Return a new board, that results from a given ply.\r\n *\r\n * @param ply\r\n * 		The ply to perform.\r\n * @return A new board with the game position after the ply.\r\n */\r\npublic final Board getBoardAfterPly(Ply ply) {\r\n    BitBoard newBoard = ((BitBoard) (clone()));\r\n    newBoard.doPly(ply);\r\n    return newBoard;\r\n}'),(481,'return buffer// Return the buffer with the bytes.\r\n','byte',0,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',66,'de.java_chess.javaChess.bitboard.BitBoardImpl.getBytes()',1,'/**\r\n * Get the board as a byte stream.\r\n *\r\n * @return The board as a array of bytes.\r\n */\r\npublic final byte[] getBytes() {\r\n    // A buffer for the bytes.\r\n    byte[] buffer = new byte[32];\r\n    int bufferIndex = 0;\r\n    for (int layer = 0; layer < 4; layer++) {\r\n        // Get the current layer.\r\n        long currentLayer = _boardLayer[layer];\r\n        // Now shift the layer in the buffer.\r\n        for (int bytePos = 0; bytePos < 8; bytePos++) {\r\n            buffer[(bufferIndex++)] = ((byte) (((int) (currentLayer)) & 255));\r\n            currentLayer >>= 8;\r\n        }\r\n    }\r\n    return buffer;// Return the buffer with the bytes.\r\n\r\n}'),(482,'return ~(((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3]))','int',0,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',67,'de.java_chess.javaChess.bitboard.BitBoardImpl.getEmptySquares()',1,'/**\r\n * Get a bitmask with all the free squares.\r\n *\r\n * @return A bitmask with all the empty squares marked by a 1 bit.\r\n */\r\npublic final long getEmptySquares() {\r\n    return ~(((_boardLayer[1]) | (_boardLayer[2])) | (_boardLayer[3]));\r\n}'),(483,'return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))))','int',0,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',68,'de.java_chess.javaChess.bitboard.BitBoardImpl.getPiece(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Get the piece of a given position, or null of the square is empty.\r\n *\r\n * @param position\r\n * 		The position of the piece.\r\n * @return The piece of the square or null, of the square is empty.\r\n */\r\npublic final Piece getPiece(Position position) {\r\n    int bitpos = position.getSquareIndex();\r\n    int pieceType = ((((int) ((_boardLayer[1]) >> bitpos)) & 1) | ((((int) ((_boardLayer[2]) >> bitpos)) & 1) << 1)) | ((((int) ((_boardLayer[3]) >> bitpos)) & 1) << 2);\r\n    return pieceType == 0 ? null : new PieceImpl(((byte) ((pieceType << 1) | (((_boardLayer[0]) >> bitpos) & 1))));\r\n}'),(484,'return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]))','int',0,12,'de.java_chess.javaChess.bitboard.BitBoardImpl',69,'de.java_chess.javaChess.bitboard.BitBoardImpl.getPositionOfPieces(int)',1,'/**\r\n * Get the positions of some pieces as a long (64 bit wide) bitmask.\r\n *\r\n * @param pieceTypeColor\r\n * 		The color and type of the pieces.\r\n */\r\npublic final long getPositionOfPieces(int pieceTypeColor) {\r\n    return ((((pieceTypeColor & 1) != 0 ? _boardLayer[0] : ~(_boardLayer[0])) & ((pieceTypeColor & 2) != 0 ? _boardLayer[1] : ~(_boardLayer[1]))) & ((pieceTypeColor & 4) != 0 ? _boardLayer[2] : ~(_boardLayer[2]))) & ((pieceTypeColor & 8) != 0 ? _boardLayer[3] : ~(_boardLayer[3]));\r\n}'),(485,'return new BufferedReader(new InputStreamReader(resourceURL.openStream()))','java.net.URL',0,14,'de.java_chess.javaChess.dialogs.DialogAbout',82,'de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)',1,'/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * 		The name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}'),(486,'// Ugly! But the same behaviour than before...\r\nreturn new StringReader(ie.getMessage())','java.io.IOException',0,14,'de.java_chess.javaChess.dialogs.DialogAbout',82,'de.java_chess.javaChess.dialogs.DialogAbout.getDialogResource(java.lang.String)',1,'/**\r\n * Get a dialog resource as a reader.\r\n *\r\n * @param resourceName\r\n * 		The name of the resource.\r\n * @return A reader to read from.\r\n */\r\nprivate final Reader getDialogResource(String resourceName) {\r\n    try {\r\n        // Create a URL into the jar.\r\n        URL resourceURL = new URL((\"jar:file:javaChess.jar!/de/java_chess/javaChess/dialogs/resources/\" + resourceName));\r\n        return new BufferedReader(new InputStreamReader(resourceURL.openStream()));\r\n    } catch (IOException ie) {\r\n        // Ugly! But the same behaviour than before...\r\n        return new StringReader(ie.getMessage());\r\n    }\r\n}'),(487,'return DialogAbout._instance','de.java_chess.javaChess.dialogs.DialogAbout',14,14,'de.java_chess.javaChess.dialogs.DialogAbout',83,'de.java_chess.javaChess.dialogs.DialogAbout.getInstance()',1,'// //////////////////////////////////////////\r\n// ////////////// Methods //////////////////\r\n// /////////////////////////////////////////\r\n/**\r\n * Get the one and only instance of this class\r\n * (singleton pattern).\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static DialogAbout getInstance() {\r\n    // If theres no instance yet, create one.\r\n    if ((DialogAbout._instance) == null) {\r\n        DialogAbout._instance = new DialogAbout();\r\n    }\r\n    return DialogAbout._instance;\r\n}'),(488,'return ((byte) ((pieceColor) & ((byte) (1))))','int',0,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',90,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.getColor()',1,'/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic byte getColor() {\r\n    return ((byte) ((pieceColor) & ((byte) (1))));\r\n}'),(489,'// To avoid the instanciation of a image each time, just reuse\r\n// the images of the icons.\r\nreturn _pieceIcon[this.getColor()][type].getImage()','javax.swing.ImageIcon',0,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',91,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.getSelectedPieceImage()',1,'public Image getSelectedPieceImage() {\r\n    byte type = this.getType();\r\n    if (type == 0) {\r\n        type = Piece.KING;\r\n    }\r\n    // To avoid the instanciation of a image each time, just reuse\r\n    // the images of the icons.\r\n    return _pieceIcon[this.getColor()][type].getImage();\r\n}'),(490,'return ((byte) ((pieceColor) >> 1))','int',0,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',92,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.getType()',1,'// -----------------------------------------------------------------------\r\n// Interface methods:\r\n// -----------------------------------------------------------------------\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic byte getType() {\r\n    return ((byte) ((pieceColor) >> 1));\r\n}'),(491,'return this.pieceColor','de.java_chess.javaChess.dialogs.PieceSelectionPanel',16,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',93,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.getTypeAndColor()',1,'/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic byte getTypeAndColor() {\r\n    return this.pieceColor;\r\n}'),(492,'return ((this.pieceColor) & 1) != 0','int',0,16,'de.java_chess.javaChess.dialogs.PieceSelectionPanel',95,'de.java_chess.javaChess.dialogs.PieceSelectionPanel.isWhite()',1,'/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic boolean isWhite() {\r\n    return ((this.pieceColor) & 1) != 0;\r\n}'),(493,'return this.jtNewName.getText()','javax.swing.text.JTextComponent',0,17,'de.java_chess.javaChess.dialogs.PlayerDialog',102,'de.java_chess.javaChess.dialogs.PlayerDialog.getNewName()',1,'/**\r\n * Returns the name from within the JTextField\r\n *\r\n * @return The new name\r\n */\r\npublic String getNewName() {\r\n    return this.jtNewName.getText();\r\n}'),(494,'return TransformationDialog._instance','de.java_chess.javaChess.dialogs.TransformationDialog',19,19,'de.java_chess.javaChess.dialogs.TransformationDialog',115,'de.java_chess.javaChess.dialogs.TransformationDialog.getInstance()',1,'// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final TransformationDialog getInstance() {\r\n    if ((TransformationDialog._instance) == null) {\r\n        TransformationDialog._instance = new TransformationDialog(null, true);\r\n    }\r\n    return TransformationDialog._instance;\r\n}'),(495,'return _pieceType','de.java_chess.javaChess.dialogs.TransformationDialog',19,19,'de.java_chess.javaChess.dialogs.TransformationDialog',116,'de.java_chess.javaChess.dialogs.TransformationDialog.getPieceType()',1,'/**\r\n * Get the currently selected piece type.\r\n *\r\n * @return The currently selected piece type.\r\n */\r\npublic byte getPieceType() {\r\n    return _pieceType;\r\n}'),(496,'// Return a weighted score\r\nreturn ((short) (((((short) (2)) * positionalValue) + (((short) (7)) * materialValue)) + checkValue))','int',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',125,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze()',1,'/**\r\n * Analyze the current board.\r\n */\r\npublic final short analyze() {\r\n    // A check thread has a value, too.\r\n    short checkValue = 0;\r\n    // Start with the tests, if one of the players is in check.\r\n    // Its important to start the test with the color that moves next!\r\n    if (whiteHasMoveRight()) {\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n    } else {\r\n        if (isInCheck(false)) {\r\n            // If the opponents king is in check,\r\n            checkValue += BitBoardAnalyzer.WHITE_WIN;// the opponent seems to win.\r\n\r\n        }\r\n        if (isInCheck(true)) {\r\n            // If the king of the moving player is in check,\r\n            checkValue += BitBoardAnalyzer.BLACK_WIN;// the player seems to win.\r\n\r\n        }\r\n    }\r\n    // Early checks hinder the position building are punished therefore.\r\n    if ((getGame().getNumberOfPlies()) < 12) {\r\n        checkValue = ((short) (checkValue / 4));\r\n    }\r\n    // Now compute the position and material value of all pieces.\r\n    short materialValue = 0;\r\n    // Count the figures and their material value.\r\n    short positionalValue = 0;// Score the position value.\r\n\r\n    // Check the entire board.\r\n    // Use a bitmask to speedup the test for a piece on the square\r\n    long emptySquareMask = getBoard().getEmptySquares();\r\n    // Get the positions of the white and black pawns.\r\n    long[] pawnPos = new long[2];\r\n    pawnPos[0] = getBoard().getPositionOfPieces(((Piece.PAWN) << 1));\r\n    pawnPos[1] = getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1));\r\n    // I reuse the same PositionImpl object to avoid the overhead of\r\n    // object instancing for each square.\r\n    Position pos = new PositionImpl(0);\r\n    for (int i = 0; i < 64; i++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            pos.setSquareIndex(i);\r\n            Piece p = getBoard().getPiece(pos);\r\n            if (p != null) {\r\n                short mValue = 0;\r\n                short pValue = 0;\r\n                // Add the value of the piece\r\n                switch (p.getType()) {\r\n                    case Piece.PAWN :\r\n                        mValue = 10;\r\n                        pValue = BitBoardAnalyzerImpl._pawnPositionalValue[((getGame().getNumberOfPlies()) <= 12 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        // Check, if this pawn could be promoted\r\n                        if (p.isWhite()) {\r\n                            int j = i + 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j < 64) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        } else {\r\n                            int j = i - 8;\r\n                            Position pos2 = new PositionImpl(0);\r\n                            while (j >= 0) {\r\n                                pos2.setSquareIndex(j);\r\n                                Piece p2 = getBoard().getPiece(pos2);\r\n                                if ((p2 != null) && ((p2.getType()) == (Piece.PAWN))) {\r\n                                    pValue -= 2;\r\n                                    break;\r\n                                }\r\n                                j += 8;\r\n                            } \r\n                        }\r\n                        break;\r\n                    case Piece.KNIGHT :\r\n                        pValue = BitBoardAnalyzerImpl._knightPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) < 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.BISHOP :\r\n                        pValue = BitBoardAnalyzerImpl._bishopPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        if ((getGame().getNumberOfPlies()) <= 12) {\r\n                            // Check if this piece blocks a own pawn\r\n                            int row = i >>> 3;\r\n                            if ((((p.isWhite()) && ((row == 2) || (row == 3))) && ((((1L << (i - 8)) | (1L << (i - 16))) & (pawnPos[1])) != 0L)) || (((!(p.isWhite())) && ((row == 4) || (row == 5))) && ((((1L << (i + 8)) | (1L << (i + 16))) & (pawnPos[0])) != 0L))) {\r\n                                pValue -= BitBoardAnalyzerImpl._pawnBlocker;\r\n                            }\r\n                        }\r\n                        mValue = 30;\r\n                        break;\r\n                    case Piece.ROOK :\r\n                        mValue = 45;\r\n                        pValue = BitBoardAnalyzerImpl._rookPositionalValue[((getGame().getNumberOfPlies()) <= 8 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.QUEEN :\r\n                        mValue = 80;\r\n                        pValue = BitBoardAnalyzerImpl._queenPositionalValue[((getGame().getNumberOfPlies()) <= 14 ? 0 : 1)][(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                    case Piece.KING :\r\n                        pValue = BitBoardAnalyzerImpl._kingPositionalValue[(p.isWhite() ? i : ((7 - (i >>> 3)) << 3) + (i & 7))];\r\n                        break;\r\n                }\r\n                if (p.isWhite()) {\r\n                    materialValue += mValue;\r\n                    positionalValue += pValue;\r\n                } else {\r\n                    materialValue -= mValue;\r\n                    positionalValue -= pValue;\r\n                }\r\n            }\r\n        }\r\n        // Shift the mask to test the next square\r\n        emptySquareMask >>>= 1;\r\n    }\r\n    // Return a weighted score\r\n    return ((short) (((((short) (2)) * positionalValue) + (((short) (7)) * materialValue)) + checkValue));\r\n}'),(497,'return analyze()','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',21,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',126,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.analyze(de.java_chess.javaChess.bitboard.BitBoard,boolean)',1,'/**\r\n * Analyzed a new board.\r\n *\r\n * @param board\r\n * 		The new board to analyze.\r\n * @param white\r\n * 		Flag to indicate, if white has the next move.\r\n */\r\npublic final short analyze(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    setMoveRight(white);\r\n    return analyze();\r\n}'),(498,'return _board','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',21,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',127,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getBoard()',1,'// Methods\r\n/**\r\n * Get the currently analyzed board.\r\n *\r\n * @return The currently analyzed board.\r\n */\r\npublic final BitBoard getBoard() {\r\n    return _board;\r\n}'),(499,'return _game','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',21,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',128,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getGame()',1,'/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(500,'return _plyGenerator','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',21,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',129,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.getPlyGenerator()',1,'/**\r\n * Get the ply generator.\r\n *\r\n * @return The PlyGenerator.\r\n */\r\nprivate final PlyGenerator getPlyGenerator() {\r\n    return _plyGenerator;\r\n}'),(501,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(502,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(503,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(504,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(505,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(506,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(507,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(508,'return true// King is in check!\r\n','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(509,'return true','boolean',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(510,'// Get the positions of all black pawns and compare them with a moved king.\r\nreturn (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L','int',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(511,'// Get the positions of all white pawns and compare them with a moved king.\r\nreturn (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L','int',0,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',130,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(boolean)',1,'/**\r\n * Test, if the given player is in check.\r\n *\r\n * @param white\r\n * 		Flag, if the white king is to test.\r\n * @return true, if the king is in check, false otherwise.\r\n */\r\npublic final boolean isInCheck(boolean white) {\r\n    // Get the position of the king.\r\n    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));\r\n    int kingSquare = BitUtils.getHighestBit(kingPosition);\r\n    // Get and cache the empty squares of the current board.\r\n    long emptySquares = getBoard().getEmptySquares();\r\n    // Now compute the moves backwards from the kings position.\r\n    // Get all positions of bishops and queens\r\n    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));\r\n    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));\r\n    // The pieces, that attack diagonal\r\n    long diagonalPositions = bishopPositions | queenPositions;\r\n    // Move the king to the upper right.\r\n    long kingMask = kingPosition;\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower right.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the upper left.\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the lower left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);\r\n    if ((kingMask & diagonalPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Now we need the rooks, too.\r\n    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));\r\n    // The pieces, that attack horizontally or vertically.\r\n    long horVertPositions = rookPositions | queenPositions;\r\n    // Move the king downwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king upwards\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the left\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Move the king to the right\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);\r\n    if ((kingMask & horVertPositions) != 0L) {\r\n        return true;// King is in check!\r\n\r\n    }\r\n    // Check, if the king is in check by a knight\r\n    // Compute the knight moves backwards from the position of the\r\n    // king and see, if theres a knight on this square.\r\n    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {\r\n        return true;\r\n    }\r\n    // Check if the king is in check by a pawn\r\n    kingMask = kingPosition;// Reset bitmask.\r\n\r\n    if (white) {\r\n        // Get the positions of all black pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;\r\n    } else {\r\n        // Get the positions of all white pawns and compare them with a moved king.\r\n        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;\r\n    }\r\n}'),(512,'return isInCheck(white)','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',21,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',131,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.isInCheck(de.java_chess.javaChess.bitboard.BitBoard,boolean)',1,'/**\r\n * Test if a king is in check on a given board.\r\n *\r\n * @param board\r\n * 		The board to test.\r\n * @param white\r\n * 		true, if the white king is checked, false otherwise.\r\n */\r\npublic final boolean isInCheck(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return isInCheck(white);\r\n}'),(513,'return _whiteMoves','de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',21,21,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl',136,'de.java_chess.javaChess.engine.BitBoardAnalyzerImpl.whiteHasMoveRight()',1,'/**\r\n * Check, if white moves next.\r\n *\r\n * @return true, if white moves next, false otherwise.\r\n */\r\nprivate final boolean whiteHasMoveRight() {\r\n    return _whiteMoves;\r\n}'),(514,'// Use the byte as a index for a precomputed array\r\n// of bit indexes.\r\nreturn highestBit + (BitUtils._highestBit[bytePart])','int',0,22,'de.java_chess.javaChess.engine.BitUtils',138,'de.java_chess.javaChess.engine.BitUtils.getHighestBit(long)',1,'/**\r\n * Find the index of highest set bit in a long bitmask.\r\n *\r\n * @param bitmask\r\n * 		The bitmask to operate on.\r\n * @return The index of the highest set bit or 0, if no bits are set.\r\n */\r\npublic static final int getHighestBit(long bitmask) {\r\n    int highestBit = 0;\r\n    // The following 3 statements split the 64 bit word down to\r\n    // a byte.\r\n    int dwordPart = ((int) (bitmask >>> 32));\r\n    if (dwordPart != 0) {\r\n        highestBit += 32;\r\n    } else {\r\n        dwordPart = ((int) (bitmask));\r\n    }\r\n    int wordPart = (dwordPart >>> 16) & 65535;\r\n    if (wordPart != 0) {\r\n        highestBit += 16;\r\n    } else {\r\n        wordPart = dwordPart & 65535;\r\n    }\r\n    int bytePart = (wordPart >>> 8) & 255;\r\n    if (bytePart != 0) {\r\n        highestBit += 8;\r\n    } else {\r\n        bytePart = wordPart & 255;\r\n    }\r\n    // Use the byte as a index for a precomputed array\r\n    // of bit indexes.\r\n    return highestBit + (BitUtils._highestBit[bytePart]);\r\n}'),(515,'return _analyzer.analyze(((BitBoard) (board)), isWhite())','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',158,'de.java_chess.javaChess.engine.ChessEngineImpl.analyzeBoard(de.java_chess.javaChess.board.Board)',1,'/**\r\n * Compute a score for a game position.\r\n *\r\n * @return A score for the current game position.\r\n */\r\npublic final short analyzeBoard(Board board) {\r\n    return _analyzer.analyze(((BitBoard) (board)), isWhite());\r\n}'),(516,'return _bestPly.getPly()','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',159,'de.java_chess.javaChess.engine.ChessEngineImpl.computeBestPly()',1,'/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\npublic Ply computeBestPly() {\r\n    _bestPly = null;// Remove ply from last computation.\r\n\r\n    long startTime = System.currentTimeMillis();\r\n    if (inOpeningBook()) {\r\n        _bestPly = getOpeningBook().getOpeningBookPly();\r\n        if ((_bestPly) == null) {\r\n            // If theres no ply in the opening book.\r\n            setInOpeningBook(false);\r\n        }\r\n    }\r\n    if ((_bestPly) == null) {\r\n        // If we dont have a ply yet\r\n        start();\r\n        try {\r\n            Thread.sleep(getMaximumSearchTime());\r\n            setSearchStop(true);\r\n            // if( this.bFixedTime == false) {\r\n            _searchThread.join();// Wait for the search thread to end the search at this search depth.\r\n\r\n            // }\r\n            _searchThread = null;// Remove the thread, so it can be recreated for the next move.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n    long usedTime = (System.currentTimeMillis()) - startTime;\r\n    if ((_bestPly) != null) {\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOut = new StringBuffer();\r\n            sOut.append(\"Best ply: \");\r\n            sOut.append(_bestPly.getPly().toString());\r\n            sOut.append(\" with score \");\r\n            sOut.append(_bestPly.getScore());\r\n            sOut.append(\" and search depth \");\r\n            sOut.append(getSearchDepth());\r\n            this._enginePanel.modifyText(sOut.toString());\r\n            sOut = new StringBuffer();\r\n            sOut.append(\"Analyzed boards: \");\r\n            sOut.append(getAnalyzedBoards());\r\n            sOut.append(\" in \");\r\n            sOut.append(usedTime);\r\n            sOut.append(\" ms\");\r\n            this._enginePanel.modifyText(sOut.toString());\r\n        }\r\n        if ((this._statusPanel) != null)\r\n            this._statusPanel.setStatusText(\"Your turn...\");\r\n\r\n        return _bestPly.getPly();\r\n    }\r\n    return null;\r\n}'),(517,'return null','<nulltype>',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',159,'de.java_chess.javaChess.engine.ChessEngineImpl.computeBestPly()',1,'/**\r\n * Compute the best ply for the current position.\r\n *\r\n * @return The best known ply for the current position.\r\n */\r\npublic Ply computeBestPly() {\r\n    _bestPly = null;// Remove ply from last computation.\r\n\r\n    long startTime = System.currentTimeMillis();\r\n    if (inOpeningBook()) {\r\n        _bestPly = getOpeningBook().getOpeningBookPly();\r\n        if ((_bestPly) == null) {\r\n            // If theres no ply in the opening book.\r\n            setInOpeningBook(false);\r\n        }\r\n    }\r\n    if ((_bestPly) == null) {\r\n        // If we dont have a ply yet\r\n        start();\r\n        try {\r\n            Thread.sleep(getMaximumSearchTime());\r\n            setSearchStop(true);\r\n            // if( this.bFixedTime == false) {\r\n            _searchThread.join();// Wait for the search thread to end the search at this search depth.\r\n\r\n            // }\r\n            _searchThread = null;// Remove the thread, so it can be recreated for the next move.\r\n\r\n        } catch (InterruptedException ignored) {\r\n        }\r\n    }\r\n    long usedTime = (System.currentTimeMillis()) - startTime;\r\n    if ((_bestPly) != null) {\r\n        if ((this._enginePanel) != null) {\r\n            StringBuffer sOut = new StringBuffer();\r\n            sOut.append(\"Best ply: \");\r\n            sOut.append(_bestPly.getPly().toString());\r\n            sOut.append(\" with score \");\r\n            sOut.append(_bestPly.getScore());\r\n            sOut.append(\" and search depth \");\r\n            sOut.append(getSearchDepth());\r\n            this._enginePanel.modifyText(sOut.toString());\r\n            sOut = new StringBuffer();\r\n            sOut.append(\"Analyzed boards: \");\r\n            sOut.append(getAnalyzedBoards());\r\n            sOut.append(\" in \");\r\n            sOut.append(usedTime);\r\n            sOut.append(\" ms\");\r\n            this._enginePanel.modifyText(sOut.toString());\r\n        }\r\n        if ((this._statusPanel) != null)\r\n            this._statusPanel.setStatusText(\"Your turn...\");\r\n\r\n        return _bestPly.getPly();\r\n    }\r\n    return null;\r\n}'),(518,'return _analyzedBoards','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',162,'de.java_chess.javaChess.engine.ChessEngineImpl.getAnalyzedBoards()',1,'/**\r\n * Get the number of analyzed boards.\r\n *\r\n * @return The number of analyzed boards.\r\n */\r\npublic final long getAnalyzedBoards() {\r\n    return _analyzedBoards;\r\n}'),(519,'return _board','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',163,'de.java_chess.javaChess.engine.ChessEngineImpl.getBoard()',1,'/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic Board getBoard() {\r\n    return _board;\r\n}'),(520,'return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',164,'de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)',1,'/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * 		True, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}'),(521,'return validPliesAvailable ? GameState.ONGOING : GameState.DRAW','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',164,'de.java_chess.javaChess.engine.ChessEngineImpl.getCurrentGameState(boolean)',1,'/**\r\n * Get the current game state.\r\n *\r\n * @param white\r\n * 		True, if the state of the white player is requested.\r\n * @return The current game state.\r\n */\r\npublic final byte getCurrentGameState(boolean white) {\r\n    // Test if the given player is in check.\r\n    boolean inCheck = _analyzer.isInCheck(((BitBoard) (getBoard())), white);\r\n    // Test if the player has valid plies available.\r\n    // The following computation of the available plies is not really efficient,\r\n    // since they are done anyway (either to compute the next computer ply or to\r\n    // check if a user ply is valid). So maybe the plygenerator or the engine should\r\n    // cache the computed plies.\r\n    boolean validPliesAvailable = (_plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white).length) > 0;\r\n    if (inCheck) {\r\n        return validPliesAvailable ? GameState.CHECK : GameState.CHECKMATE;\r\n    } else {\r\n        return validPliesAvailable ? GameState.ONGOING : GameState.DRAW;\r\n    }\r\n}'),(522,'return _game','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',165,'de.java_chess.javaChess.engine.ChessEngineImpl.getGame()',1,'/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(523,'return this.getHashtable().getMaximumSize()','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',166,'de.java_chess.javaChess.engine.ChessEngineImpl.getHashSize()',1,'/**\r\n * Returns the hash size\r\n *\r\n * @return The hashsize\r\n */\r\npublic int getHashSize() {\r\n    return this.getHashtable().getMaximumSize();\r\n}'),(524,'return _hashtable','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',167,'de.java_chess.javaChess.engine.ChessEngineImpl.getHashtable()',1,'/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}'),(525,'return _maxSearchTime','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',168,'de.java_chess.javaChess.engine.ChessEngineImpl.getMaximumSearchTime()',1,'/**\r\n * Get the maximum search time.\r\n *\r\n * @return The maximum search time.\r\n */\r\npublic final int getMaximumSearchTime() {\r\n    return _maxSearchTime;\r\n}'),(526,'// Return the engine menu.\r\nreturn engineMenu','javax.swing.JMenu',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',169,'de.java_chess.javaChess.engine.ChessEngineImpl.getMenu()',1,'/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu engineMenu = new JMenu(\"Engine\");\r\n    // Add a toggle item for to the permanent brain.\r\n    engineMenu.add((_permanentBrainMenuItem = new JCheckBoxMenuItem(\"Use permanent brain\", usePermanentBrain())));\r\n    _permanentBrainMenuItem.addActionListener(this);\r\n    // Add a menu for the maximum search time\r\n    JMenu searchTimeMenu = new JMenu(\"Search time\");\r\n    // Add a sub-menu for fixed time.\r\n    JMenu searchTimeSubMenuFix = new JMenu(\"Fixed time\");\r\n    // Add a sub-menu for average time.\r\n    JMenu searchTimeSubMenuAv = new JMenu(\"Average time\");\r\n    // Add various options for the fixed search time\r\n    // (maybe a user defined search time should be added, too).\r\n    buttonGroupSearchTime = new ButtonGroup();\r\n    _fixSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _fixSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _fixSearchTimeMenuItem[st].addActionListener(this);\r\n        if ((_searchTime[st]) == 5) {\r\n            // set initially 5 sec max search time:\r\n            _fixSearchTimeMenuItem[st].setSelected(true);\r\n            this.setMaximumSearchTime(5000);\r\n        }\r\n        buttonGroupSearchTime.add(_fixSearchTimeMenuItem[st]);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuFix.add(_fixSearchTimeMenuItem[st]);\r\n    }\r\n    // Add various options for the average search time\r\n    _avSearchTimeMenuItem = new JRadioButtonMenuItem[_searchTime.length];\r\n    for (int st = 0; st < (_searchTime.length); st++) {\r\n        _avSearchTimeMenuItem[st] = new JRadioButtonMenuItem(((\"\" + (_searchTime[st])) + \" seconds\"));\r\n        _avSearchTimeMenuItem[st].addActionListener(this);\r\n        // Add the current search time menu item to its menu.\r\n        searchTimeSubMenuAv.add(_avSearchTimeMenuItem[st]);\r\n        buttonGroupSearchTime.add(_avSearchTimeMenuItem[st]);\r\n    }\r\n    searchTimeMenu.add(searchTimeSubMenuFix);\r\n    searchTimeMenu.add(searchTimeSubMenuAv);\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(searchTimeMenu);\r\n    // Add a menu for the hashtable size.\r\n    JMenu hashtableSizeMenu = new JMenu(\"Hashtable size\");\r\n    // Add various options for the hashtable size.\r\n    this.buttonGroupHashSize = new ButtonGroup();\r\n    _hashtableSizeMenuItem = new JRadioButtonMenuItem[_hashtableSizes.length];\r\n    for (int hts = 0; hts < (_hashtableSizes.length); hts++) {\r\n        _hashtableSizeMenuItem[hts] = new JRadioButtonMenuItem(((\"\" + (_hashtableSizes[hts])) + \" entries\"));\r\n        _hashtableSizeMenuItem[hts].addActionListener(this);\r\n        if ((_hashtableSizes[hts]) == 10000) {\r\n            _hashtableSizeMenuItem[hts].setSelected(true);\r\n            getHashtable().setMaximumSize(_hashtableSizes[hts]);\r\n        }\r\n        // Add the current search time menu item to its menu.\r\n        hashtableSizeMenu.add(_hashtableSizeMenuItem[hts]);\r\n        this.buttonGroupHashSize.add(_hashtableSizeMenuItem[hts]);\r\n    }\r\n    // Add the search time menu to the main engine menu.\r\n    engineMenu.add(hashtableSizeMenu);\r\n    // Add a menu item to read openings from PGN files.\r\n    engineMenu.addSeparator();\r\n    engineMenu.add(new LoadOpeningsAction(getOpeningBook()));\r\n    // Return the engine menu.\r\n    return engineMenu;\r\n}'),(527,'return _openingBook','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',170,'de.java_chess.javaChess.engine.ChessEngineImpl.getOpeningBook()',1,'/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}'),(528,'return _permanentBrain','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',171,'de.java_chess.javaChess.engine.ChessEngineImpl.getPermanentBrain()',1,'/**\r\n * Get the permanent brain.\r\n *\r\n * @return The permanent brain.\r\n */\r\npublic final PermanentBrain getPermanentBrain() {\r\n    return _permanentBrain;\r\n}'),(529,'return _searchDepth','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',172,'de.java_chess.javaChess.engine.ChessEngineImpl.getSearchDepth()',1,'/**\r\n * Get the current search depth.\r\n *\r\n * @return The current search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}'),(530,'return retString','String',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',173,'de.java_chess.javaChess.engine.ChessEngineImpl.getStatusDisplayString()',1,'/**\r\n * Returns the status string to display in status bar\r\n */\r\npublic String getStatusDisplayString() {\r\n    String retString = ((((\"HashSize: \" + (this.getHashSize())) + \" entries; \") + \"Search time: \") + ((this.getMaximumSearchTime()) / 1000)) + \"sec\";\r\n    if (this.isFixedTime()) {\r\n        retString += \" fix\";\r\n    } else {\r\n        retString += \" average\";\r\n    }\r\n    return retString;\r\n}'),(531,'return _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), (!(isWhite())))','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',174,'de.java_chess.javaChess.engine.ChessEngineImpl.getUserPlies()',1,'/**\r\n * Get all the potential plies for the human player.\r\n *\r\n * @return All the potential plies for the human player.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    return _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), (!(isWhite())));\r\n}'),(532,'return _inOpeningBook','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',175,'de.java_chess.javaChess.engine.ChessEngineImpl.inOpeningBook()',1,'/**\r\n * Get the flag to indicate, if we are still in the opening book.\r\n *\r\n * @return true, if we are still in the opening book. False otherwise.\r\n */\r\nprivate final boolean inOpeningBook() {\r\n    return _inOpeningBook;\r\n}'),(533,'return this.bFixedTime','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',178,'de.java_chess.javaChess.engine.ChessEngineImpl.isFixedTime()',1,'/**\r\n * Returns whether the search time is fixed or not.\r\n *\r\n * @return Is the search time fixed?\r\n */\r\npublic boolean isFixedTime() {\r\n    return this.bFixedTime;\r\n}'),(534,'return _stopSearch','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',179,'de.java_chess.javaChess.engine.ChessEngineImpl.isSearchStop()',1,'/**\r\n * Check, if a search should be stopped.\r\n *\r\n * @return true, if the search should be stopped.\r\n */\r\npublic final boolean isSearchStop() {\r\n    return _stopSearch;\r\n}'),(535,'return _white','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',180,'de.java_chess.javaChess.engine.ChessEngineImpl.isWhite()',1,'/**\r\n * Get the color of this engine.\r\n *\r\n * @param white\r\n * 		true, if the engine operates with the white pieces.\r\n */\r\npublic boolean isWhite() {\r\n    return _white;\r\n}'),(536,'return analyzeBoard(board)','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',1,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(537,'// Is this a checkmate?\r\nreturn BitBoardAnalyzer.BLACK_HAS_WON','de.java_chess.javaChess.engine.BitBoardAnalyzer',20,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',1,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(538,'// Looks like a draw?\r\nreturn BitBoardAnalyzer.DRAW','de.java_chess.javaChess.engine.BitBoardAnalyzer',20,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',1,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(539,'return curAlpha','short',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',1,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(540,'// Is this a checkmate?\r\nreturn BitBoardAnalyzer.WHITE_HAS_WON','de.java_chess.javaChess.engine.BitBoardAnalyzer',20,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',1,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(541,'// Looks like a draw?\r\nreturn BitBoardAnalyzer.DRAW','de.java_chess.javaChess.engine.BitBoardAnalyzer',20,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',1,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(542,'return curBeta','short',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',181,'de.java_chess.javaChess.engine.ChessEngineImpl.minimaxAlphaBeta(de.java_chess.javaChess.ply.Ply,de.java_chess.javaChess.board.Board,boolean,int,short,short)',1,'/**\r\n * Perform a alpha-beta minimax search on the board.\r\n *\r\n * @param lastPly\r\n * 		The ply, that created this board.\r\n * @param board\r\n * 		The board to analyze.\r\n * @param white\r\n * 		true, if white has the next move.\r\n * @param byte\r\n * 		searchLevel The level to search for.\r\n * @param alpha\r\n * 		The current maximum.\r\n * @param beta\r\n * 		The current minimum.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\nprivate final short minimaxAlphaBeta(Ply lastPly, Board board, boolean white, int searchLevel, short alpha, short beta) throws InterruptedException {\r\n    if ((searchLevel >= (getSearchDepth())) && (((!(lastPly.isCapture())) || (!(lastPly instanceof TransformationPly))) || (!(_analyzer.isInCheck(((BitBoard) (board)), (!white)))))) {\r\n        increaseAnalyzedBoards();\r\n        return analyzeBoard(board);\r\n    } else {\r\n        short curAlpha = alpha;\r\n        short curBeta = beta;\r\n        int bestPlyIndex = -1;\r\n        Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (board)), white);\r\n        if (white) {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), false, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val > curAlpha) {\r\n                    curAlpha = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curAlpha >= curBeta) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.BLACK_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curAlpha;\r\n        } else {\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                    // If the search time is over and at least depth 1 was completed\r\n                    throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n                }\r\n                getGame().doPly(plies[i]);\r\n                short val;\r\n                try {\r\n                    val = minimaxAlphaBeta(plies[i], board.getBoardAfterPly(plies[i]), true, (searchLevel + 1), curAlpha, curBeta);\r\n                } catch (InterruptedException ie) {\r\n                    getGame().undoLastPly();// Undo the last move\r\n\r\n                    throw ie;// and pass the exception.\r\n\r\n                }\r\n                if (val < curBeta) {\r\n                    curBeta = val;\r\n                    bestPlyIndex = i;// Store the index of this ply, so we can access it later.\r\n\r\n                }\r\n                if (curBeta <= curAlpha) {\r\n                    getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                    break;\r\n                }\r\n                getGame().undoLastPly();\r\n            }\r\n            if (bestPlyIndex != (-1)) {\r\n                // Since this is the best ply for this search level, we store it in the hashtable\r\n                getHashtable().pushEntry(new PlyHashtableEntryImpl(board, plies[bestPlyIndex], ((getSearchDepth()) - searchLevel)));\r\n            } else {\r\n                if ((plies.length) == 0) {\r\n                    // There are no legal moves available?\r\n                    if (_analyzer.isInCheck(((BitBoard) (board)), white)) {\r\n                        // Is this a checkmate?\r\n                        return BitBoardAnalyzer.WHITE_HAS_WON;\r\n                    } else {\r\n                        // Looks like a draw?\r\n                        return BitBoardAnalyzer.DRAW;\r\n                    }\r\n                }\r\n            }\r\n            return curBeta;\r\n        }\r\n    }\r\n}'),(543,'return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha)','int',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',199,'de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)',1,'/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}'),(544,'return null','<nulltype>',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',199,'de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)',1,'/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}'),(545,'return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta)','int',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',199,'de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)',1,'/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}'),(546,'return null','<nulltype>',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',199,'de.java_chess.javaChess.engine.ChessEngineImpl.startMinimaxAlphaBeta(boolean)',1,'/**\r\n * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the\r\n * analyzed ply, so it gets a special method.\r\n *\r\n * @param white\r\n * 		Flag to indicate, if white is about to move.\r\n * @throws InterruptedException\r\n * 		if the search was interrupted because of a timeout.\r\n */\r\npublic final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {\r\n    short curAlpha = AnalyzedPly.MIN_SCORE;\r\n    short curBeta = AnalyzedPly.MAX_SCORE;\r\n    int bestPlyIndex = -1;\r\n    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);\r\n    if (white) {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val > curAlpha) {\r\n                curAlpha = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curAlpha >= curBeta) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);\r\n        } else {\r\n            return null;\r\n        }\r\n    } else {\r\n        for (int i = 0; i < (plies.length); i++) {\r\n            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {\r\n                // If the search time is over and at least depth 1 was completed\r\n                throw new InterruptedException((\"Search interrupted at depth \" + (getSearchDepth())));// abort the search.\r\n\r\n            }\r\n            getGame().doPly(plies[i]);\r\n            short val;\r\n            try {\r\n                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);\r\n            } catch (InterruptedException ie) {\r\n                getGame().undoLastPly();// Undo the last move\r\n\r\n                throw ie;// and pass the exception.\r\n\r\n            }\r\n            if (val < curBeta) {\r\n                curBeta = val;\r\n                bestPlyIndex = i;\r\n            }\r\n            if (curBeta <= curAlpha) {\r\n                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.\r\n\r\n                break;\r\n            }\r\n            getGame().undoLastPly();\r\n        }\r\n        if (bestPlyIndex != (-1)) {\r\n            // Since this is the best ply so far, we store it in the hashtable. This makes sense,\r\n            // since the minimax algorithm is started several times, before a move is selected.\r\n            // So this move is not necessarily applied immediately!\r\n            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));\r\n            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}'),(547,'return _usePermanentBrain','de.java_chess.javaChess.engine.ChessEngineImpl',24,24,'de.java_chess.javaChess.engine.ChessEngineImpl',202,'de.java_chess.javaChess.engine.ChessEngineImpl.usePermanentBrain()',1,'/**\r\n * Check, if the permanent brain should be used.\r\n *\r\n * @return A flag, that indicates, if the permanent brain should be used.\r\n */\r\nprivate final boolean usePermanentBrain() {\r\n    return _usePermanentBrain;\r\n}'),(548,'return true// ply, it seems to be valid.\r\n','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',203,'de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}'),(549,'return false','boolean',0,24,'de.java_chess.javaChess.engine.ChessEngineImpl',203,'de.java_chess.javaChess.engine.ChessEngineImpl.validateUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Check if a ply made by the user is valid.\r\n *\r\n * @param ply\r\n * 		The user ply.\r\n * @return true, if the ply is valid. false otherwise.\r\n */\r\npublic final boolean validateUserPly(Ply ply) {\r\n    // Get the user plies from the permanent brain, where they\r\n    // were hopefully already computed (if the PB is actually active).\r\n    Ply[] plies = getPermanentBrain().getUserPlies();\r\n    // If the permanent brain is not activated at the moment, remove the\r\n    // computed plies immediately, so they are recomputed for the next move!\r\n    if (!(usePermanentBrain())) {\r\n        getPermanentBrain().resetUserPlies();\r\n    }\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        if (plies[p].equals(ply)) {\r\n            // if the user ply equals this computed\r\n            // Perform this ply in the opening book\r\n            getOpeningBook().doUserPly(ply);\r\n            // Store the last user ply in a instance variable.\r\n            _lastUserPly = ply;\r\n            return true;// ply, it seems to be valid.\r\n\r\n        }\r\n    }\r\n    // The computer could not compute the ply, the user has made,\r\n    // so we assume, that it is not valid.\r\n    System.out.println((\"Invalid move \" + (ply.toString())));\r\n    System.out.println((\"Piecetype on source square \" + ((getBoard().getPiece(ply.getSource())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getSource()).getType()))));\r\n    System.out.println((\"Piecetype on destination square \" + ((getBoard().getPiece(ply.getDestination())) == null ? \"null\" : \"\" + (getBoard().getPiece(ply.getDestination()).getType()))));\r\n    System.out.println(\"Valid moves are:\");\r\n    for (int p = 0; p < (plies.length); p++) {\r\n        // For each ply\r\n        System.out.print(((plies[p].toString()) + \" \"));\r\n    }\r\n    System.out.println();\r\n    return false;\r\n}'),(550,'return _analyzer','de.java_chess.javaChess.engine.PlyGenerator',25,25,'de.java_chess.javaChess.engine.PlyGenerator',222,'de.java_chess.javaChess.engine.PlyGenerator.getAnalyzer()',1,'/**\r\n * Get a analyzer for check test.\r\n *\r\n * @return A analyzer for chess boards.\r\n */\r\nfinal BitBoardAnalyzer getAnalyzer() {\r\n    return _analyzer;\r\n}'),(551,'return _board','de.java_chess.javaChess.engine.PlyGenerator',25,25,'de.java_chess.javaChess.engine.PlyGenerator',223,'de.java_chess.javaChess.engine.PlyGenerator.getBoard()',1,'/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\nfinal BitBoard getBoard() {\r\n    return _board;\r\n}'),(552,'return _game','de.java_chess.javaChess.engine.PlyGenerator',25,25,'de.java_chess.javaChess.engine.PlyGenerator',224,'de.java_chess.javaChess.engine.PlyGenerator.getGame()',1,'// Methods\r\n/**\r\n * Get the current game.\r\n *\r\n * @return The current game.\r\n */\r\npublic final Game getGame() {\r\n    return _game;\r\n}'),(553,'return _hashtable','de.java_chess.javaChess.engine.PlyGenerator',25,25,'de.java_chess.javaChess.engine.PlyGenerator',225,'de.java_chess.javaChess.engine.PlyGenerator.getHashtable()',1,'/**\r\n * Get the current hashtable for this ply generator.\r\n *\r\n * @return The current hashtable for this ply generator.\r\n */\r\npublic final PlyHashtable getHashtable() {\r\n    return _hashtable;\r\n}'),(554,'return _knightMask[square]','int',0,25,'de.java_chess.javaChess.engine.PlyGenerator',226,'de.java_chess.javaChess.engine.PlyGenerator.getKnightPlies(int)',1,'/**\r\n * Get the knight plies for a given knight square.\r\n *\r\n * @param square\r\n * 		The square, where the knight is located.\r\n * @return All the knight plies as a 64 bit bitmask.\r\n */\r\npublic final long getKnightPlies(int square) {\r\n    return _knightMask[square];\r\n}'),(555,'return getGame().getLastPly()','de.java_chess.javaChess.game.Game',50,25,'de.java_chess.javaChess.engine.PlyGenerator',227,'de.java_chess.javaChess.engine.PlyGenerator.getLastPly()',1,'/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\nfinal Ply getLastPly() {\r\n    return getGame().getLastPly();\r\n    // return _lastPly;\r\n}'),(556,'return plies','de.java_chess.javaChess.ply.Ply',75,25,'de.java_chess.javaChess.engine.PlyGenerator',228,'de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(boolean)',1,'/**\r\n * Get the plies for a given game position and color.\r\n *\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(boolean white) {\r\n    resetPlies();\r\n    _white = white;// Store the color of the current player.\r\n\r\n    // Compute some bitmasks, so we dont have to compute them again for each piece type.\r\n    _emptySquares = getBoard().getEmptySquares();// Get the positions of the empty squares.\r\n\r\n    _attackablePieces = (getBoard().getAllPiecesForColor((!(_white)))) & (~(getBoard().getPositionOfPieces((((Piece.KING) << 1) | (_white ? 0 : 1)))));\r\n    // Add the possible plies for all piece types.\r\n    // I tried to sort this list according to the probality for a check, so\r\n    // the analyzer has a better chance to find it early.\r\n    addPliesForKnights();\r\n    addPliesForBishops();\r\n    addPliesForRooks();\r\n    addPliesForQueens();\r\n    addPliesForPawns();\r\n    addPliesForKing();\r\n    // Check, if theres a good ply for this board in the hash table.\r\n    Ply hashtablePly = getHashtable().getPly(getBoard(), _white);\r\n    if (hashtablePly != null) {\r\n        // If so, increase the score of this ply.\r\n        for (int index = 0; index < (_plyCounter); index++) {\r\n            if (_currentPlies[index].getPly().equals(hashtablePly)) {\r\n                _currentPlies[index].setScore(HASHTABLE_PLY);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // Presort the plies\r\n    presortPlies();\r\n    // Convert the plies to a array of the correct size\r\n    Ply[] plies = new Ply[_plyCounter];\r\n    int destIndex = 0;\r\n    for (int sourceIndex = (_plyCounter) - 1; sourceIndex >= 0;) {\r\n        plies[(destIndex++)] = _currentPlies[(sourceIndex--)].getPly();\r\n    }\r\n    return plies;\r\n}'),(557,'return getPliesForColor(white)','boolean',0,25,'de.java_chess.javaChess.engine.PlyGenerator',229,'de.java_chess.javaChess.engine.PlyGenerator.getPliesForColor(de.java_chess.javaChess.bitboard.BitBoard,boolean)',1,'/**\r\n * Get the plies for a given board and color.\r\n * Passing the last ply is suboptimal, since its slower than\r\n * accessing the game history.\r\n *\r\n * @param lastPly\r\n * 		The ply, that lead to the given board.\r\n * @param board\r\n * 		The board with the game position.\r\n * @param white\r\n * 		true, if white has the next move.\r\n */\r\npublic final Ply[] getPliesForColor(BitBoard board, boolean white) {\r\n    setBoard(board);\r\n    return getPliesForColor(white);\r\n}'),(558,'return _board','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',28,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',253,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getBoard()',1,'// Methods\r\n/**\r\n * Get the board of this entry.\r\n *\r\n * @return The board of this entry.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}'),(559,'return _ply','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',28,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',254,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getPly()',1,'/**\r\n * Get the ply.\r\n *\r\n * @return The ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}'),(560,'return _searchDepth','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',28,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',255,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.getSearchDepth()',1,'/**\r\n * Get the search depth for the computed ply.\r\n *\r\n * @return The search depth for the computed ply.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}'),(561,'return PlyHashtableEntryImpl.hashKey(getBoard(), isWhiteMove())','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',28,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',256,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey()',1,'/**\r\n * Get the hashcode for this ply.\r\n *\r\n * @return A hashcode for this ply.\r\n */\r\npublic final long hashKey() {\r\n    return PlyHashtableEntryImpl.hashKey(getBoard(), isWhiteMove());\r\n}'),(562,'return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white)','de.java_chess.javaChess.board.Board',13,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',257,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.hashKey(de.java_chess.javaChess.board.Board,boolean)',1,'/**\r\n * Get a hashcode for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if its a ply with the white pieces.\r\n * @return A hashcode for the given board and color.\r\n */\r\npublic static long hashKey(Board board, boolean white) {\r\n    return ZobristKeyImpl.getInstance().computeKey(((BitBoard) (board)), white);\r\n}'),(563,'return (getBoard().getPiece(getPly().getSource()).getColor()) == (Piece.WHITE)','boolean',0,28,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl',258,'de.java_chess.javaChess.engine.hashtable.PlyHashtableEntryImpl.isWhiteMove()',1,'/**\r\n * Check, if its a move with white pieces.\r\n *\r\n * @return true, if its a move with white pieces.\r\n */\r\npublic final boolean isWhiteMove() {\r\n    return (getBoard().getPiece(getPly().getSource()).getColor()) == (Piece.WHITE);\r\n}'),(564,'return _maxSize','de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',29,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',263,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getMaximumSize()',1,'/**\r\n * Get the maximum number of entries in the hashtable.\r\n *\r\n * @return The maximum number of entries in the hashtable.\r\n */\r\npublic final int getMaximumSize() {\r\n    return _maxSize;\r\n}'),(565,'return entry.getPly()','de.java_chess.javaChess.engine.hashtable.PlyHashtableEntry',27,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',264,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)',1,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(566,'// No ply for this board found.\r\nreturn null','<nulltype>',0,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',264,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getPly(de.java_chess.javaChess.board.Board,boolean)',1,'/**\r\n * Get the stored ply for a given board and piece color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		true, if we want to ply with the white pieces.\r\n */\r\npublic final Ply getPly(Board board, boolean white) {\r\n    // Compute the hashkey for the board and piece color and try to get a ply.\r\n    PlyHashtableEntry entry = ((PlyHashtableEntry) (_hashtable.get(new Long(PlyHashtableEntryImpl.hashKey(board, white)))));\r\n    // Check, if the board from the entry is identical to the passed board.\r\n    if ((entry != null) && (entry.getBoard().equals(board))) {\r\n        return entry.getPly();\r\n    }\r\n    // No ply for this board found.\r\n    return null;\r\n}'),(567,'return _hashtable.size()','java.util.Hashtable',0,29,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl',265,'de.java_chess.javaChess.engine.hashtable.PlyHashtableImpl.getSize()',1,'/**\r\n * Get the current number of entries.\r\n *\r\n * @return The current number of entries.\r\n */\r\npublic final int getSize() {\r\n    return _hashtable.size();\r\n}'),(568,'return val','long',0,30,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl',271,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.computeKey(de.java_chess.javaChess.bitboard.BitBoard,boolean)',1,'/**\r\n * Compute a key for a board and a color.\r\n *\r\n * @param board\r\n * 		The current board.\r\n * @param white\r\n * 		Flag to indicate if white moves.\r\n * @return The zobrist key.\r\n */\r\npublic long computeKey(BitBoard board, boolean white) {\r\n    long val = 0L;\r\n    // Get a bitmask of the empty squares to speedup the\r\n    // test for a piece on the square.\r\n    long emptySquareMask = board.getEmptySquares();\r\n    // Reuse the same position object for each square.\r\n    Position curPosition = new PositionImpl(0);\r\n    for (int square = 0; square < 64; square++) {\r\n        if ((emptySquareMask & 1) == 0) {\r\n            // If theres a piece on the square\r\n            curPosition.setSquareIndex(square);\r\n            Piece p = board.getPiece(curPosition);\r\n            if (p != null) {\r\n                val ^= _factors[p.getColor()][((p.getType()) - 1)][square];\r\n            }\r\n        }\r\n        emptySquareMask >>>= 1;// Shift the mask to test for the next square.\r\n\r\n    }\r\n    if (!white) {\r\n        val ^= _blackMoves;\r\n    }\r\n    return val;\r\n}'),(569,'return ZobristKeyImpl._instance','de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl',30,30,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl',272,'de.java_chess.javaChess.engine.hashtable.ZobristKeyImpl.getInstance()',1,'// Methods\r\n/**\r\n * Get the only instance of this class.\r\n */\r\npublic static final ZobristKeyImpl getInstance() {\r\n    if ((ZobristKeyImpl._instance) == null) {\r\n        ZobristKeyImpl._instance = new ZobristKeyImpl();\r\n    }\r\n    return ZobristKeyImpl._instance;\r\n}'),(570,'return i','int',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',280,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.findOpening()',1,'/**\r\n * Try to find a opening for the current game notation.\r\n *\r\n * @return The index of the found opening.\r\n */\r\nprivate final int findOpening() {\r\n    for (int i = 0; i < (_openings.size()); i++) {\r\n        if (isInOpening(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;// No opening found.\r\n\r\n}'),(571,'return -1// No opening found.\r\n','int',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',280,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.findOpening()',1,'/**\r\n * Try to find a opening for the current game notation.\r\n *\r\n * @return The index of the found opening.\r\n */\r\nprivate final int findOpening() {\r\n    for (int i = 0; i < (_openings.size()); i++) {\r\n        if (isInOpening(i)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;// No opening found.\r\n\r\n}'),(572,'return _notation','de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',32,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',281,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getNotation()',1,'/**\r\n * Get the notation of the current game.\r\n *\r\n * @return The notation of the current game.\r\n */\r\nprivate final GameNotation getNotation() {\r\n    return _notation;\r\n}'),(573,'return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)))','int',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',282,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getOpeningBookPly()',1,'/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\npublic final AnalyzedPly getOpeningBookPly() {\r\n    // If we have no opening yet, try to find one.\r\n    if ((_currentOpening) == (-1)) {\r\n        _currentOpening = findOpening();\r\n    }\r\n    // Check, if we have found a opening.\r\n    if ((_currentOpening) != (-1)) {\r\n        // Check, if we have another ply in the opening.\r\n        int pliesMade = _notation.size();\r\n        GameNotation currentOpening = ((GameNotation) (_openings.get(_currentOpening)));\r\n        if ((currentOpening.size()) > pliesMade) {\r\n            return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)));\r\n        }\r\n    }\r\n    return null;// No ply found in the available opening books.\r\n\r\n}'),(574,'return null// No ply found in the available opening books.\r\n','<nulltype>',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',282,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.getOpeningBookPly()',1,'/**\r\n * Get the next ply from the opening book, if there is\r\n * one available, or null if not.\r\n *\r\n * @return The next ply from the opening book, or null\r\nif theres no ply available.\r\n */\r\npublic final AnalyzedPly getOpeningBookPly() {\r\n    // If we have no opening yet, try to find one.\r\n    if ((_currentOpening) == (-1)) {\r\n        _currentOpening = findOpening();\r\n    }\r\n    // Check, if we have found a opening.\r\n    if ((_currentOpening) != (-1)) {\r\n        // Check, if we have another ply in the opening.\r\n        int pliesMade = _notation.size();\r\n        GameNotation currentOpening = ((GameNotation) (_openings.get(_currentOpening)));\r\n        if ((currentOpening.size()) > pliesMade) {\r\n            return new AnalyzedPlyImpl(currentOpening.getPlyNotation(pliesMade).getPly(), ((short) (0)));\r\n        }\r\n    }\r\n    return null;// No ply found in the available opening books.\r\n\r\n}'),(575,'return false','boolean',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',283,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)',1,'/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * 		The index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}'),(576,'return false','boolean',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',283,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)',1,'/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * 		The index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}'),(577,'// The current game uses the given opening.\r\nreturn true','boolean',0,32,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl',283,'de.java_chess.javaChess.engine.opening_book.OpeningBookImpl.isInOpening(int)',1,'/**\r\n * Check, if the current game notation is part of a given opening.\r\n *\r\n * @param openingIndex\r\n * 		The index of the opening to test.\r\n */\r\nprivate final boolean isInOpening(int openingIndex) {\r\n    GameNotation notation = ((GameNotation) (_openings.get(openingIndex)));\r\n    // If the current game has more plies, than the opening, we can return\r\n    // false.\r\n    if ((_notation.size()) > (notation.size())) {\r\n        return false;\r\n    }\r\n    // Compare the notation ply by ply, which is rather slow, but should work\r\n    // for now.\r\n    for (int i = 0; i < (_notation.size()); i++) {\r\n        if (!(_notation.getPlyNotation(i).getPly().equals(notation.getPlyNotation(i).getPly()))) {\r\n            return false;\r\n        }\r\n    }\r\n    // The current game uses the given opening.\r\n    return true;\r\n}'),(578,'return _openingBook','de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',33,33,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction',288,'de.java_chess.javaChess.engine.opening_book.action.LoadOpeningsAction.getOpeningBook()',1,'/**\r\n * Get the current opening book.\r\n *\r\n * @return The current opening book.\r\n */\r\nprivate final OpeningBook getOpeningBook() {\r\n    return _openingBook;\r\n}'),(579,'return _engine','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',34,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',293,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getEngine()',1,'// Methods\r\n/**\r\n * Get the current chess engine.\r\n *\r\n * @return The current chess engine.\r\n */\r\nprivate final ChessEngine getEngine() {\r\n    return _engine;\r\n}'),(580,'// i holds the index of the user ply now, which equals the\r\n// index of the computed response.\r\nreturn _computedPlies[i]','int',0,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',294,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * 		The ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}'),(581,'return null','<nulltype>',0,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',294,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getPlyForUserPly(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Get the response for a user ply.\r\n *\r\n * @param ply\r\n * 		The ply of the human player.\r\n * @return The precomputed response for the user ply.\r\n */\r\npublic final PreComputedPly getPlyForUserPly(Ply ply) {\r\n    if ((_computedPlies) != null) {\r\n        // Stop the computation\r\n        // (but should already be done by the game controller)\r\n        stopComputation();\r\n        // Get the index of the user ply.\r\n        Ply[] userPlies = getUserPlies();\r\n        int plyCount = userPlies.length;\r\n        for (int i = 0; i < plyCount; i++) {\r\n            if (userPlies[i].equals(ply)) {\r\n                // i holds the index of the user ply now, which equals the\r\n                // index of the computed response.\r\n                return _computedPlies[i];\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}'),(582,'return _userPlies// Return the user plies.\r\n','de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',34,34,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain',295,'de.java_chess.javaChess.engine.permanent_brain.PermanentBrain.getUserPlies()',1,'/**\r\n * Get the potential plies for a user.\r\n * (Required to validate a user ply.)\r\n *\r\n * @return The potential plies for a user.\r\n */\r\npublic final Ply[] getUserPlies() {\r\n    // Lazy computation for better performance.\r\n    if ((_userPlies) == null) {\r\n        _userPlies = getEngine().getUserPlies();\r\n    }\r\n    return _userPlies;// Return the user plies.\r\n\r\n}'),(583,'return _ply','de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',36,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',304,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getPly()',1,'// Methods\r\n/**\r\n * Get the computed ply.\r\n *\r\n * @return The computed ply.\r\n */\r\npublic final AnalyzedPly getPly() {\r\n    return _ply;\r\n}'),(584,'return _searchDepth','de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',36,36,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl',305,'de.java_chess.javaChess.engine.permanent_brain.PreComputedPlyImpl.getSearchDepth()',1,'/**\r\n * Get the used search depth.\r\n *\r\n * @return The used search depth.\r\n */\r\npublic final int getSearchDepth() {\r\n    return _searchDepth;\r\n}'),(585,'return suite','junit.framework.TestSuite',0,40,'de.java_chess.javaChess.engine.test.ChessEngineTest',325,'de.java_chess.javaChess.engine.test.ChessEngineTest.suite()',1,'/**\r\n * Create the engine test suite.\r\n *\r\n * @return The engine test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite\r\n    TestSuite suite = new TestSuite();\r\n    // Test the ply generator\r\n    suite.addTest(new PlyGeneratorTest1());\r\n    suite.addTest(new PlyGeneratorTest2());\r\n    suite.addTest(new PlyGeneratorTest3());\r\n    suite.addTest(new PlyGeneratorTest4());\r\n    suite.addTest(new PlyGeneratorTest5());\r\n    suite.addTest(new PlyGeneratorTest6());\r\n    // Add the actual engine tests.\r\n    suite.addTest(new KingInKnightCheckTest());\r\n    // Test the analyzer\r\n    suite.addTest(new AnalyzerTest1());\r\n    suite.addTest(new AnalyzerTest2());\r\n    // Test the complete engine\r\n    suite.addTest(new MinimaxTest1());\r\n    suite.addTest(new MinimaxTest2());\r\n    suite.addTest(new BoardConsistencyTest1());\r\n    return suite;\r\n}'),(586,'return _gameStatus.empty() ? null : ((GameImpl.GameStatus) (_gameStatus.peek()))','de.java_chess.javaChess.game.GameImpl.GameStatus',0,52,'de.java_chess.javaChess.game.GameImpl',381,'de.java_chess.javaChess.game.GameImpl.getLastGameStatus()',1,'// Methods\r\n/**\r\n * Get the last game status.\r\n *\r\n * @return The last game status.\r\n */\r\nprivate final GameImpl.GameStatus getLastGameStatus() {\r\n    return _gameStatus.empty() ? null : ((GameImpl.GameStatus) (_gameStatus.peek()));\r\n}'),(587,'return lastStatus == null ? null : lastStatus.getPly()','de.java_chess.javaChess.game.GameImpl.GameStatus',0,52,'de.java_chess.javaChess.game.GameImpl',382,'de.java_chess.javaChess.game.GameImpl.getLastPly()',1,'/**\r\n * Get the last ply.\r\n *\r\n * @return The last ply.\r\n */\r\npublic final Ply getLastPly() {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? null : lastStatus.getPly();\r\n}'),(588,'return _gameStatus.size()','de.java_chess.javaChess.game.GameImpl',52,52,'de.java_chess.javaChess.game.GameImpl',383,'de.java_chess.javaChess.game.GameImpl.getNumberOfPlies()',1,'/**\r\n * Get the total number of plies.\r\n *\r\n * @return The total number of plies.\r\n */\r\npublic final int getNumberOfPlies() {\r\n    return _gameStatus.size();\r\n}'),(589,'return lastStatus == null ? false : lastStatus.hasBeenMoved(position)','de.java_chess.javaChess.game.GameImpl.GameStatus',0,52,'de.java_chess.javaChess.game.GameImpl',384,'de.java_chess.javaChess.game.GameImpl.hasBeenMoved(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Check, if a piece on a given positon was moved from its\r\n * initial position.\r\n *\r\n * @param position\r\n * 		The position to check.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    GameImpl.GameStatus lastStatus = getLastGameStatus();\r\n    return lastStatus == null ? false : lastStatus.hasBeenMoved(position);\r\n}'),(590,'return resultBuffer.toString()','StringBuffer',0,52,'de.java_chess.javaChess.game.GameImpl',386,'de.java_chess.javaChess.game.GameImpl.toString()',1,'/**\r\n * Convert the game to a string.\r\n *\r\n * @return A string representation of the game.\r\n */\r\npublic final String toString() {\r\n    // A buffer for the string representation\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Iterate over the stack content\r\n    for (Iterator iter = _gameStatus.iterator(); iter.hasNext();) {\r\n        resultBuffer.append(((GameImpl.GameStatus) (iter.next())).getPly().toString());\r\n        resultBuffer.append(\"\n\");\r\n    }\r\n    return resultBuffer.toString();\r\n}'),(591,'return _movedPieces','de.java_chess.javaChess.game.GameImpl.GameStatus',0,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',391,'de.java_chess.javaChess.game.GameImpl$GameStatus.getMovedPieces()',1,'/**\r\n * Get the bitmask for the moved pieces.\r\n *\r\n * @return The bitmask for the moved pieces.\r\n */\r\nprivate final long getMovedPieces() {\r\n    return _movedPieces;\r\n}'),(592,'return _ply','de.java_chess.javaChess.game.GameImpl.GameStatus',0,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',392,'de.java_chess.javaChess.game.GameImpl$GameStatus.getPly()',1,'// Methods\r\n/**\r\n * Get the ply, that lead to this game status.\r\n *\r\n * @return The ply, that lead to this game status.\r\n */\r\nfinal Ply getPly() {\r\n    return _ply;\r\n}'),(593,'return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L','de.java_chess.javaChess.game.GameImpl.GameStatus',0,51,'de.java_chess.javaChess.game.GameImpl$GameStatus',393,'de.java_chess.javaChess.game.GameImpl$GameStatus.hasBeenMoved(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Check if a piece on a given initial position\r\n * has been moved.\r\n */\r\npublic final boolean hasBeenMoved(Position position) {\r\n    return ((_movedPieces) & (1L << (position.getSquareIndex()))) != 0L;\r\n}'),(594,'return jmEditMenu','javax.swing.JMenu',0,54,'de.java_chess.javaChess.menu.EditMenu',400,'de.java_chess.javaChess.menu.EditMenu.getMenu()',1,'/**\r\n * Return a menu from the chess engine, where the user\r\n * can change the settings.\r\n *\r\n * @return A menu for the engine settings.\r\n */\r\npublic final JMenu getMenu() {\r\n    // Create a new menu.\r\n    JMenu jmEditMenu = new JMenu(\"Edit\");\r\n    // Add menu items\r\n    jmiBlackPlayerName.setText(\"Black player name\");\r\n    jmiWhitePlayerName.setText(\"White player name\");\r\n    jmiEditPosition.setText(\"Edit/Setup position\");\r\n    jmiEditPosition.setMnemonic(S);\r\n    jmiBlackPlayerName.addActionListener(this);\r\n    jmiWhitePlayerName.addActionListener(this);\r\n    jmiEditPosition.addActionListener(this);\r\n    jmEditMenu.add(jmiWhitePlayerName);\r\n    jmEditMenu.add(jmiBlackPlayerName);\r\n    jmEditMenu.addSeparator();\r\n    jmEditMenu.add(jmiEditPosition);\r\n    jmEditMenu.setMnemonic(KeyEvent.VK_E);\r\n    return jmEditMenu;\r\n}'),(595,'return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1))','int',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',415,'de.java_chess.javaChess.notation.GameNotationImpl.getMove(int,boolean)',1,'/**\r\n * Get the notation for a given move and piece color.\r\n *\r\n * @param moveIndex\r\n * 		The index of the move.\r\n * @param boolean\r\n * 		white Flag to indicate if the color is white.\r\n * @return The notation for a given move and color.\r\n */\r\npublic final String getMove(int moveIndex, boolean white) {\r\n    return getPly((white ? moveIndex << 1 : (moveIndex << 1) + 1));\r\n}'),(596,'return _notationPanel','de.java_chess.javaChess.notation.GameNotationImpl',56,56,'de.java_chess.javaChess.notation.GameNotationImpl',416,'de.java_chess.javaChess.notation.GameNotationImpl.getNotationPanel()',1,'/**\r\n * Get the panel for the output.\r\n *\r\n * @return The panel for the output.\r\n */\r\npublic final NotationPanel getNotationPanel() {\r\n    return _notationPanel;\r\n}'),(597,'return _openingName','de.java_chess.javaChess.notation.GameNotationImpl',56,56,'de.java_chess.javaChess.notation.GameNotationImpl',417,'de.java_chess.javaChess.notation.GameNotationImpl.getOpeningInfo()',1,'/**\r\n * Get the info on the used opening.\r\n *\r\n * @return The name of the used opening.\r\n */\r\npublic final String getOpeningInfo() {\r\n    return _openingName;\r\n}'),(598,'// Convert the header to a String and return it.\r\nreturn resultBuffer.toString()','StringBuffer',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',418,'de.java_chess.javaChess.notation.GameNotationImpl.getPGNheader()',1,'/**\r\n * Get some extended PGN compatible info on the game.\r\n *\r\n * @return Extended PGN compatible info on the game.\r\n */\r\npublic final String getPGNheader() {\r\n    // Create a buffer for the result.\r\n    StringBuffer resultBuffer = new StringBuffer();\r\n    // Add a empty event to the header\r\n    resultBuffer.append(\"[Event \"?\"]\n\");\r\n    // Info on the site\r\n    resultBuffer.append(\"[Site \"?\"]\n\");\r\n    // Add the current date to the header\r\n    resultBuffer.append(\"[Date \"\").append(new SimpleDateFormat(\"yyyy.MM.dd\").format(new Date())).append(\"\"]\n\");\r\n    // Add the round to the header\r\n    resultBuffer.append(\"[Round \"?\"]\n\");\r\n    // Add the name of the white player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(true)))) {\r\n        resultBuffer.append(\"[White \"\").append(getPlayerInfo(true)).append(\"\"]\n\");\r\n    }\r\n    // Add the name of the black player, if it is available.\r\n    if (!(\"\".equals(getPlayerInfo(false)))) {\r\n        resultBuffer.append(\"[Black \"\").append(getPlayerInfo(false)).append(\"\"]\n\");\r\n    }\r\n    // Info on the result\r\n    resultBuffer.append(\"[Result \"?\"]\n\");\r\n    // Convert the header to a String and return it.\r\n    return resultBuffer.toString();\r\n}'),(599,'return _playerInfo[(white ? 1 : 0)]','int',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',419,'de.java_chess.javaChess.notation.GameNotationImpl.getPlayerInfo(boolean)',1,'/**\r\n * Get some info on a player.\r\n *\r\n * @return Some info on a player.\r\n */\r\npublic final String getPlayerInfo(boolean white) {\r\n    return _playerInfo[(white ? 1 : 0)];\r\n}'),(600,'return _plies.get(plyIndex).toString()','int',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',420,'de.java_chess.javaChess.notation.GameNotationImpl.getPly(int)',1,'/**\r\n * Get the ply with the given index.\r\n *\r\n * @param plyIndex\r\n * 		The index of the ply.\r\n * @return The notation for the ply as a string.\r\n */\r\nprivate final String getPly(int plyIndex) {\r\n    return _plies.get(plyIndex).toString();\r\n}'),(601,'return ((PlyNotation) (_plies.get(index)))','int',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',421,'de.java_chess.javaChess.notation.GameNotationImpl.getPlyNotation(int)',1,'/**\r\n * Get a ply with a given index.\r\n *\r\n * @param index\r\n * 		The index of the ply.\r\n */\r\npublic PlyNotation getPlyNotation(int index) {\r\n    return ((PlyNotation) (_plies.get(index)));\r\n}'),(602,'return _plies.size()','java.util.ArrayList',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',426,'de.java_chess.javaChess.notation.GameNotationImpl.size()',1,'/**\r\n * Get the number of plies in this notation.\r\n *\r\n * @return The number of plies.\r\n */\r\npublic int size() {\r\n    return _plies.size();\r\n}'),(603,'return _notation.toString()','StringBuffer',0,56,'de.java_chess.javaChess.notation.GameNotationImpl',427,'de.java_chess.javaChess.notation.GameNotationImpl.toString()',1,'/**\r\n * Get the entire game as a string.\r\n *\r\n * @return The entire game as a string.\r\n */\r\npublic final String toString() {\r\n    return _notation.toString();\r\n}'),(604,'return _piece','de.java_chess.javaChess.notation.PlyNotationImpl',58,58,'de.java_chess.javaChess.notation.PlyNotationImpl',441,'de.java_chess.javaChess.notation.PlyNotationImpl.getPiece()',1,'/**\r\n * Get the piece of this ply.\r\n *\r\n * @return The piece, that is moved with this ply.\r\n */\r\npublic final Piece getPiece() {\r\n    return _piece;\r\n}'),(605,'return notation','String',0,58,'de.java_chess.javaChess.notation.PlyNotationImpl',442,'de.java_chess.javaChess.notation.PlyNotationImpl.getPieceTypeNotation(byte)',1,'/**\r\n * Get the notation for a piece type.\r\n *\r\n * @return The notation for a piece type.\r\n */\r\npublic final String getPieceTypeNotation(byte pieceType) {\r\n    String notation = \"\";// The result;\r\n\r\n    // Convert the piece type to a string.\r\n    switch (pieceType) {\r\n        case Piece.PAWN :\r\n            notation = \"P\";\r\n            break;\r\n        case Piece.KNIGHT :\r\n            notation = \"N\";\r\n            break;\r\n        case Piece.BISHOP :\r\n            notation = \"B\";\r\n            break;\r\n        case Piece.ROOK :\r\n            notation = \"R\";\r\n            break;\r\n        case Piece.QUEEN :\r\n            notation = \"Q\";\r\n            break;\r\n        case Piece.KING :\r\n            notation = \"K\";\r\n            break;\r\n    }\r\n    return notation;\r\n}'),(606,'return _ply','de.java_chess.javaChess.notation.PlyNotationImpl',58,58,'de.java_chess.javaChess.notation.PlyNotationImpl',443,'de.java_chess.javaChess.notation.PlyNotationImpl.getPly()',1,'/**\r\n * Get the ply of this notation.\r\n *\r\n * @return The ply for this notation.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}'),(607,'return getPly().isCapture()','de.java_chess.javaChess.notation.PlyNotationImpl',58,58,'de.java_chess.javaChess.notation.PlyNotationImpl',444,'de.java_chess.javaChess.notation.PlyNotationImpl.isCapture()',1,'/**\r\n * Check if the piece captures another piece with this ply.\r\n *\r\n * @return true, if another piece is captureed with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return getPly().isCapture();\r\n}'),(608,'return _check','de.java_chess.javaChess.notation.PlyNotationImpl',58,58,'de.java_chess.javaChess.notation.PlyNotationImpl',445,'de.java_chess.javaChess.notation.PlyNotationImpl.isCheck()',1,'/**\r\n * Get the flag for a check.\r\n *\r\n * @return true, if the opponent is in check.\r\n */\r\npublic final boolean isCheck() {\r\n    return _check;\r\n}'),(609,'return _checkMate','de.java_chess.javaChess.notation.PlyNotationImpl',58,58,'de.java_chess.javaChess.notation.PlyNotationImpl',446,'de.java_chess.javaChess.notation.PlyNotationImpl.isCheckMate()',1,'/**\r\n * Get the flag for a checkmate.\r\n *\r\n * @return true, if the opponent is checkmate.\r\n */\r\npublic final boolean isCheckMate() {\r\n    return _checkMate;\r\n}'),(610,'return _stringRepresentation','de.java_chess.javaChess.notation.PlyNotationImpl',58,58,'de.java_chess.javaChess.notation.PlyNotationImpl',451,'de.java_chess.javaChess.notation.PlyNotationImpl.toString()',1,'// Methods\r\n/**\r\n * Render this notation as a string.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic String toString() {\r\n    return _stringRepresentation;\r\n}'),(611,'return null','<nulltype>',0,59,'de.java_chess.javaChess.pgn.GameLoader',453,'de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)',1,'// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * 		The info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}'),(612,'// And return the notation for the ply.\r\nreturn notation','de.java_chess.javaChess.notation.PlyNotation',57,59,'de.java_chess.javaChess.pgn.GameLoader',453,'de.java_chess.javaChess.pgn.GameLoader.completePly(de.java_chess.javaChess.pgn.PGNPlyFragment)',1,'// Methods\r\n/**\r\n * Turn a loaded ply fragment from a PGN file into a notated ply.\r\n *\r\n * @param plyFragment\r\n * 		The info from the PGN file.\r\n * @return The notation for the ply, if we could recognize the ply, or null.\r\n */\r\npublic final PlyNotation completePly(PGNPlyFragment plyFragment) {\r\n    // Create a ply from the ply fragment.\r\n    Ply ply = null;\r\n    PlyNotation notation = null;\r\n    // If the origin of the move is missing, compute it from the destination\r\n    // ...not necessary yet...\r\n    if (plyFragment.isCastling()) {\r\n        ply = new CastlingPlyImpl(new PositionImpl((_whiteMoves ? 4 : 60)), plyFragment.isLeftCastling());\r\n        notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n    } else {\r\n        // Check, how complete our fragment is so far.\r\n        if ((plyFragment.getOrigin()) == null) {\r\n            // If there was no origin given, try to figure it from the currently available moves\r\n            // Compute all the available moves for this board.\r\n            Ply[] plies = _plyGenerator.getPliesForColor(_whiteMoves);\r\n            for (int i = 0; i < (plies.length); i++) {\r\n                if (((plies[i].getDestination()) == (plyFragment.getDestination())) && ((_board.getPiece(plies[i].getSource()).getType()) == (plyFragment.getPieceType()))) {\r\n                    // Found the right ply!\r\n                    plyFragment.setOrigin(plies[i].getSource());\r\n                    break;// Stop the search for the ply origin.\r\n\r\n                }\r\n            }\r\n        }\r\n        if (plyFragment.isPawnPromotion()) {\r\n            ply = new TransformationPlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), plyFragment.getNewPieceType(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        } else {\r\n            ply = new PlyImpl(plyFragment.getOrigin(), plyFragment.getDestination(), ((_board.getPiece(plyFragment.getDestination())) == null));\r\n            notation = new PlyNotationImpl(ply, _board.getPiece(ply.getSource()));\r\n        }\r\n        // Verifiy, if the notation doesnt show a capture on an empty sqare.\r\n        if ((plyFragment.isCapture()) && ((_board.getPiece(plyFragment.getDestination())) == null)) {\r\n            return null;\r\n        }\r\n    }\r\n    // No perform the ply on our simulated board.\r\n    doPly(ply);\r\n    // And return the notation for the ply.\r\n    return notation;\r\n}'),(613,'return _parser// And return it.\r\n','de.java_chess.javaChess.pgn.PGNFile',60,60,'de.java_chess.javaChess.pgn.PGNFile',456,'de.java_chess.javaChess.pgn.PGNFile.getPGNParser()',1,'/**\r\n * Get the current parser, if theres already one, or\r\n * create a new parser and return it.\r\n *\r\n * @return The current PGN parser.\r\n */\r\nprivate final PGNParser getPGNParser() {\r\n    if ((_parser) == null) {\r\n        // If there is no parser yet, create one.\r\n        _parser = new PGNParser(new PGNLexer(getReader()));\r\n    }\r\n    return _parser;// And return it.\r\n\r\n}'),(614,'return _reader','de.java_chess.javaChess.pgn.PGNFile',60,60,'de.java_chess.javaChess.pgn.PGNFile',457,'de.java_chess.javaChess.pgn.PGNFile.getReader()',1,'/**\r\n * Get the reader for the current file.\r\n *\r\n * @return The current reader.\r\n */\r\nprivate final Reader getReader() {\r\n    return _reader;\r\n}'),(615,'return notationBuffer','de.java_chess.javaChess.notation.GameNotation',55,60,'de.java_chess.javaChess.pgn.PGNFile',458,'de.java_chess.javaChess.pgn.PGNFile.readGame()',1,'// Methods\r\n/**\r\n * Read one game from the current file.\r\n *\r\n * @return The notation of the game.\r\n * @throws RecognitionException\r\n * 		If a parser problem occured.\r\n * @throws TokenStreamException\r\n * 		If a scanner problem occured.\r\n */\r\npublic final GameNotation readGame() throws RecognitionException, TokenStreamException {\r\n    // A buffer for the result.\r\n    GameNotation notationBuffer = new GameNotationImpl();\r\n    // Start the parsing of the file.\r\n    getPGNParser().pgnGame(notationBuffer);\r\n    return notationBuffer;\r\n}'),(616,'return false','boolean',0,61,'de.java_chess.javaChess.pgn.PGNFileFilter',462,'de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)',1,'// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * 		The file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}'),(617,'return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase())','int',0,61,'de.java_chess.javaChess.pgn.PGNFileFilter',462,'de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)',1,'// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * 		The file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}'),(618,'return false','boolean',0,61,'de.java_chess.javaChess.pgn.PGNFileFilter',462,'de.java_chess.javaChess.pgn.PGNFileFilter.accept(java.io.File)',1,'// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Check if the given file is a PGN file.\r\n *\r\n * @param file\r\n * 		The file to check.\r\n * @return true, if the file is a PGN file, false otherwise.\r\n */\r\npublic boolean accept(File file) {\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    String filename = file.getName();\r\n    int i = filename.lastIndexOf(.);\r\n    if ((i > 0) && (i < ((filename.length()) - 1))) {\r\n        return \"pgn\".equalsIgnoreCase(filename.substring((i + 1)).toLowerCase());\r\n    }\r\n    return false;\r\n}'),(619,'return \"PGN - Portable Game Notation format\"','String',0,61,'de.java_chess.javaChess.pgn.PGNFileFilter',463,'de.java_chess.javaChess.pgn.PGNFileFilter.getDescription()',1,'/**\r\n * Get a description of this file filter.\r\n *\r\n * @return A description of this file filter.\r\n */\r\npublic String getDescription() {\r\n    return \"PGN - Portable Game Notation format\";\r\n}'),(620,'return _gameLoader','de.java_chess.javaChess.pgn.PGNParser',64,64,'de.java_chess.javaChess.pgn.PGNParser',501,'de.java_chess.javaChess.pgn.PGNParser.getGameLoader()',1,'/**\r\n * Get the current game loader.\r\n *\r\n * @return The current game loader.\r\n */\r\nprivate final GameLoader getGameLoader() {\r\n    return _gameLoader;\r\n}'),(621,'return _notation','de.java_chess.javaChess.pgn.PGNParser',64,64,'de.java_chess.javaChess.pgn.PGNParser',502,'de.java_chess.javaChess.pgn.PGNParser.getNotation()',1,'/**\r\n * Get the current notation.\r\n *\r\n * @return The current notation.\r\n */\r\npublic final GameNotation getNotation() {\r\n    return _notation;\r\n}'),(622,'return notation','de.java_chess.javaChess.notation.PlyNotation',57,64,'de.java_chess.javaChess.pgn.PGNParser',507,'de.java_chess.javaChess.pgn.PGNParser.ply()',1,'public final PlyNotation ply() throws RecognitionException, TokenStreamException {\r\n    PlyNotation notation = null;\r\n    Token lc = null;\r\n    Token snOrg = null;\r\n    Token snDest = null;\r\n    Token lc2 = null;\r\n    PGNPlyFragment plyFragment = new PGNPlyFragment();\r\n    {\r\n        switch (LA(1)) {\r\n            case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n            case PGNTokenTypes.SQUARE_NAME :\r\n            case PGNTokenTypes.PIECE_MOVE :\r\n            case PGNTokenTypes.PIECE_CAPTURE :\r\n                {\r\n                    {\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                    {\r\n                                        lc = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        plyFragment.setPieceTypeFromLetter(lc.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                        {\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.SQUARE_NAME :\r\n                                        {\r\n                                            snOrg = LT(1);\r\n                                            match(PGNTokenTypes.SQUARE_NAME);\r\n                                            plyFragment.setOrigin(snOrg.getText());\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            {\r\n                                switch (LA(1)) {\r\n                                    case PGNTokenTypes.PIECE_MOVE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_MOVE);\r\n                                            plyFragment.setCapture(false);\r\n                                            break;\r\n                                        }\r\n                                    case PGNTokenTypes.PIECE_CAPTURE :\r\n                                        {\r\n                                            match(PGNTokenTypes.PIECE_CAPTURE);\r\n                                            plyFragment.setCapture(true);\r\n                                            break;\r\n                                        }\r\n                                    default :\r\n                                        {\r\n                                            throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                        }\r\n                                }\r\n                            }\r\n                            snDest = LT(1);\r\n                            match(PGNTokenTypes.SQUARE_NAME);\r\n                            plyFragment.setDestination(snDest.getText());\r\n                        }\r\n                        {\r\n                            switch (LA(1)) {\r\n                                case PGNTokenTypes.PAWN_PROMOTION :\r\n                                    {\r\n                                        match(PGNTokenTypes.PAWN_PROMOTION);\r\n                                        lc2 = LT(1);\r\n                                        match(PGNTokenTypes.FIGURINE_LETTER_CODE);\r\n                                        if (!((!(\"P\".equals(lc2.getText()))) && (!(\"K\".equals(lc2.getText())))))\r\n                                            throw new SemanticException(\" ! \"P\".equals( lc2.getText()) && ! \"K\".equals( lc2.getText())\");\r\n\r\n                                        plyFragment.setPawnPromotion(lc2.getText().charAt(0));\r\n                                        break;\r\n                                    }\r\n                                case PGNTokenTypes.GAME_TERMINATOR :\r\n                                case PGNTokenTypes.MOVE_INDEX :\r\n                                case PGNTokenTypes.FIGURINE_LETTER_CODE :\r\n                                case PGNTokenTypes.SQUARE_NAME :\r\n                                case PGNTokenTypes.PIECE_MOVE :\r\n                                case PGNTokenTypes.PIECE_CAPTURE :\r\n                                case PGNTokenTypes.LEFT_CASTLING :\r\n                                case PGNTokenTypes.RIGHT_CASTLING :\r\n                                case PGNTokenTypes.WS :\r\n                                    {\r\n                                        break;\r\n                                    }\r\n                                default :\r\n                                    {\r\n                                        throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                                    }\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.LEFT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.LEFT_CASTLING);\r\n                    plyFragment.setCastling(true);\r\n                    break;\r\n                }\r\n            case PGNTokenTypes.RIGHT_CASTLING :\r\n                {\r\n                    match(PGNTokenTypes.RIGHT_CASTLING);\r\n                    plyFragment.setCastling(false);\r\n                    break;\r\n                }\r\n            default :\r\n                {\r\n                    throw new antlr.NoViableAltException(LT(1), getFilename());\r\n                }\r\n        }\r\n    }\r\n    // When we have all the info from the PGN file, we can try to\r\n    // create a ply notation from it.\r\n    notation = getGameLoader().completePly(plyFragment);\r\n    if (!(notation != null))\r\n        throw new SemanticException(\"notation != null\");\r\n\r\n    return notation;\r\n}'),(623,'return _destination','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',518,'de.java_chess.javaChess.pgn.PGNPlyFragment.getDestination()',1,'/**\r\n * Get the current destination of this ply.\r\n *\r\n * @return The currently known destination of this ply.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}'),(624,'return _newPieceType','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',519,'de.java_chess.javaChess.pgn.PGNPlyFragment.getNewPieceType()',1,'/**\r\n * Get the new piece type after the pawn promotion.\r\n *\r\n * @return The new piece type after the pawn promotion.\r\n */\r\npublic final byte getNewPieceType() {\r\n    return _newPieceType;\r\n}'),(625,'return _origin','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',520,'de.java_chess.javaChess.pgn.PGNPlyFragment.getOrigin()',1,'/**\r\n * Get the current origin of this ply.\r\n *\r\n * @return The currently known origin of this ply.\r\n */\r\npublic final Position getOrigin() {\r\n    return _origin;\r\n}'),(626,'return _pieceType','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',521,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceType()',1,'/**\r\n * Get the type of the moved piece.\r\n *\r\n * @return The type of the moved piece.\r\n */\r\npublic final byte getPieceType() {\r\n    return _pieceType;\r\n}'),(627,'return Piece.PAWN','de.java_chess.javaChess.piece.Piece',67,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',1,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(628,'return Piece.KNIGHT','de.java_chess.javaChess.piece.Piece',67,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',1,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(629,'return Piece.BISHOP','de.java_chess.javaChess.piece.Piece',67,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',1,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(630,'return Piece.ROOK','de.java_chess.javaChess.piece.Piece',67,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',1,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(631,'return Piece.QUEEN','de.java_chess.javaChess.piece.Piece',67,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',1,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(632,'return Piece.KING','de.java_chess.javaChess.piece.Piece',67,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',1,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(633,'return ((byte) (-1))','int',0,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',522,'de.java_chess.javaChess.pgn.PGNPlyFragment.getPieceTypeFromLetter(char)',1,'/**\r\n * Get the piece type from a figurine letter.\r\n *\r\n * @param letter\r\n * 		The figurine letter code.\r\n * @return The piece type or -1, if it was no valid figurine letter code.\r\n */\r\nprivate final byte getPieceTypeFromLetter(char letter) {\r\n    if (letter == P) {\r\n        return Piece.PAWN;\r\n    }\r\n    if (letter == N) {\r\n        return Piece.KNIGHT;\r\n    }\r\n    if (letter == B) {\r\n        return Piece.BISHOP;\r\n    }\r\n    if (letter == R) {\r\n        return Piece.ROOK;\r\n    }\r\n    if (letter == Q) {\r\n        return Piece.QUEEN;\r\n    }\r\n    if (letter == K) {\r\n        return Piece.KING;\r\n    }\r\n    return ((byte) (-1));\r\n}'),(634,'return _capture','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',523,'de.java_chess.javaChess.pgn.PGNPlyFragment.isCapture()',1,'/**\r\n * Check, if this ply fragment is a capture.\r\n *\r\n * @return true, if this move is a capture.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}'),(635,'return _castling','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',524,'de.java_chess.javaChess.pgn.PGNPlyFragment.isCastling()',1,'/**\r\n * Check, if this ply fragment is a castling.\r\n *\r\n * @return true, if this ply fragment represents a castling. False otherwise.\r\n */\r\npublic final boolean isCastling() {\r\n    return _castling;\r\n}'),(636,'return _leftCastling','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',525,'de.java_chess.javaChess.pgn.PGNPlyFragment.isLeftCastling()',1,'/**\r\n * Check, if this castling goes to the left.\r\n *\r\n * @return true, if this castling goes to the left.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _leftCastling;\r\n}'),(637,'return _pawnPromotion','de.java_chess.javaChess.pgn.PGNPlyFragment',65,65,'de.java_chess.javaChess.pgn.PGNPlyFragment',526,'de.java_chess.javaChess.pgn.PGNPlyFragment.isPawnPromotion()',1,'/**\r\n * Check, if this move is a pawn promotion.\r\n *\r\n * @return true, if this move is a pawn promotion. False otherwise.\r\n */\r\npublic final boolean isPawnPromotion() {\r\n    return _pawnPromotion;\r\n}'),(638,'return ((byte) ((_typeColor) & ((byte) (1))))','int',0,68,'de.java_chess.javaChess.piece.PieceImpl',543,'de.java_chess.javaChess.piece.PieceImpl.getColor()',1,'/**\r\n * Get the color of this piece.\r\n *\r\n * @return The color of this piece.\r\n */\r\npublic final byte getColor() {\r\n    return ((byte) ((_typeColor) & ((byte) (1))));\r\n}'),(639,'return ((byte) ((_typeColor) >> 1))','int',0,68,'de.java_chess.javaChess.piece.PieceImpl',544,'de.java_chess.javaChess.piece.PieceImpl.getType()',1,'// Methods\r\n/**\r\n * Get the type of this piece.\r\n *\r\n * @return The type of this piece.\r\n */\r\npublic final byte getType() {\r\n    return ((byte) ((_typeColor) >> 1));\r\n}'),(640,'return _typeColor','de.java_chess.javaChess.piece.PieceImpl',68,68,'de.java_chess.javaChess.piece.PieceImpl',545,'de.java_chess.javaChess.piece.PieceImpl.getTypeAndColor()',1,'/**\r\n * Get type and color as 1 byte.\r\n *\r\n * @return Type and color and 1 byte.\r\n */\r\npublic final byte getTypeAndColor() {\r\n    return _typeColor;\r\n}'),(641,'return ((_typeColor) & 1) != 0','int',0,68,'de.java_chess.javaChess.piece.PieceImpl',546,'de.java_chess.javaChess.piece.PieceImpl.isWhite()',1,'/**\r\n * Check, if this piece is white.\r\n *\r\n * @return true, if this piece is white, false if black.\r\n */\r\npublic final boolean isWhite() {\r\n    return ((_typeColor) & 1) != 0;\r\n}'),(642,'return new AnalyzedPlyImpl(getPly(), getScore())','de.java_chess.javaChess.ply.AnalyzedPlyImpl',70,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',555,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.clone()',1,'/**\r\n * Clone this ply.\r\n *\r\n * @return A clone of this ply.\r\n */\r\npublic Object clone() {\r\n    return new AnalyzedPlyImpl(getPly(), getScore());\r\n}'),(643,'return _ply','de.java_chess.javaChess.ply.AnalyzedPlyImpl',70,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',556,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.getPly()',1,'// Methods\r\n/**\r\n * Get the analyzed ply.\r\n *\r\n * @return The analyzed ply.\r\n */\r\npublic final Ply getPly() {\r\n    return _ply;\r\n}'),(644,'return _score','de.java_chess.javaChess.ply.AnalyzedPlyImpl',70,70,'de.java_chess.javaChess.ply.AnalyzedPlyImpl',557,'de.java_chess.javaChess.ply.AnalyzedPlyImpl.getScore()',1,'/**\r\n * Get the scrore of this ply.\r\n *\r\n * @return The score of this ply.\r\n */\r\npublic final short getScore() {\r\n    return _score;\r\n}'),(645,'return _goesLeft','de.java_chess.javaChess.ply.CastlingPlyImpl',72,72,'de.java_chess.javaChess.ply.CastlingPlyImpl',563,'de.java_chess.javaChess.ply.CastlingPlyImpl.isLeftCastling()',1,'// Methods\r\n/**\r\n * Check, if this castling goes to the left side of the board.\r\n *\r\n * @return true, if the castling goes to the left side, false otherwise.\r\n */\r\npublic final boolean isLeftCastling() {\r\n    return _goesLeft;\r\n}'),(646,'return isLeftCastling() ? \"O-O-O\" : \"O-O\"','String',0,72,'de.java_chess.javaChess.ply.CastlingPlyImpl',565,'de.java_chess.javaChess.ply.CastlingPlyImpl.toString()',1,'/**\r\n * Get a string representation of this castling.\r\n *\r\n * @return A string representation of this ply.\r\n */\r\npublic final String toString() {\r\n    return isLeftCastling() ? \"O-O-O\" : \"O-O\";\r\n}'),(647,'return _attackedPosition','de.java_chess.javaChess.ply.EnPassantPlyImpl',74,74,'de.java_chess.javaChess.ply.EnPassantPlyImpl',569,'de.java_chess.javaChess.ply.EnPassantPlyImpl.getAttackedPosition()',1,'// Methods\r\n/**\r\n * Get the position of the attacked pawn.\r\n *\r\n * @return Get the position of the attacked pawn.\r\n */\r\npublic final Position getAttackedPosition() {\r\n    return _attackedPosition;\r\n}'),(648,'return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()))','boolean',0,76,'de.java_chess.javaChess.ply.PlyImpl',578,'de.java_chess.javaChess.ply.PlyImpl.equals(de.java_chess.javaChess.ply.Ply)',1,'/**\r\n * Test, if this ply is equal to another ply.\r\n *\r\n * @param ply\r\n * 		The other ply.\r\n * @return true, if the 2 plies are equal.\r\n */\r\npublic final boolean equals(Ply ply) {\r\n    return (ply.getSource().equals(getSource())) && (ply.getDestination().equals(getDestination()));\r\n}'),(649,'return _destination','de.java_chess.javaChess.ply.PlyImpl',76,76,'de.java_chess.javaChess.ply.PlyImpl',579,'de.java_chess.javaChess.ply.PlyImpl.getDestination()',1,'/**\r\n * Get the destination of the piece.\r\n *\r\n * @return The destination of the piece.\r\n */\r\npublic final Position getDestination() {\r\n    return _destination;\r\n}'),(650,'return _source','de.java_chess.javaChess.ply.PlyImpl',76,76,'de.java_chess.javaChess.ply.PlyImpl',580,'de.java_chess.javaChess.ply.PlyImpl.getSource()',1,'// Methods\r\n/**\r\n * Get the source of the ply.\r\n *\r\n * @return The source of the piece.\r\n */\r\npublic final Position getSource() {\r\n    return _source;\r\n}'),(651,'return _capture','de.java_chess.javaChess.ply.PlyImpl',76,76,'de.java_chess.javaChess.ply.PlyImpl',581,'de.java_chess.javaChess.ply.PlyImpl.isCapture()',1,'/**\r\n * Check, if this ply captures another piece.\r\n *\r\n * @return true, if another piece is captured with this ply.\r\n */\r\npublic final boolean isCapture() {\r\n    return _capture;\r\n}'),(652,'return ((getSource().toSquareName()) + \"-\") + (getDestination().toSquareName())','de.java_chess.javaChess.position.Position',80,76,'de.java_chess.javaChess.ply.PlyImpl',585,'de.java_chess.javaChess.ply.PlyImpl.toString()',1,'/**\r\n * Convert the ply into something human readable. Its not exactly chess\r\n * notation, since we dont have a board to check, if it is a move or\r\n * a attack.\r\n *\r\n * @return The ply as a string.\r\n */\r\npublic String toString() {\r\n    return ((getSource().toSquareName()) + \"-\") + (getDestination().toSquareName());\r\n}'),(653,'return _newPieceType','de.java_chess.javaChess.ply.TransformationPlyImpl',78,78,'de.java_chess.javaChess.ply.TransformationPlyImpl',589,'de.java_chess.javaChess.ply.TransformationPlyImpl.getTypeAfterTransformation()',1,'// Methods\r\n/**\r\n * Get the new type of the piece after the transformation.\r\n *\r\n * @return The new piece after the transformation.\r\n */\r\npublic final byte getTypeAfterTransformation() {\r\n    return _newPieceType;\r\n}'),(654,'return (pos.getSquareIndex()) == (getSquareIndex())','boolean',0,81,'de.java_chess.javaChess.position.PositionImpl',600,'de.java_chess.javaChess.position.PositionImpl.equals(de.java_chess.javaChess.position.Position)',1,'/**\r\n * Test if 2 positions are equal.\r\n *\r\n * @param Another\r\n * 		position.\r\n * @return true, if the positions are equal, false otherwise.\r\n */\r\npublic final boolean equals(Position pos) {\r\n    return (pos.getSquareIndex()) == (getSquareIndex());\r\n}'),(655,'return (_squareIndex) & 7','int',0,81,'de.java_chess.javaChess.position.PositionImpl',601,'de.java_chess.javaChess.position.PositionImpl.getLineIndex()',1,'/**\r\n * Get the line index of this postion (0-7).\r\n *\r\n * @return The line index of this position.\r\n */\r\npublic final int getLineIndex() {\r\n    return (_squareIndex) & 7;\r\n}'),(656,'return (_squareIndex) >> 3','int',0,81,'de.java_chess.javaChess.position.PositionImpl',602,'de.java_chess.javaChess.position.PositionImpl.getRowIndex()',1,'/**\r\n * Get the row index of this position (0-7).\r\n *\r\n * @return The row index of this position.\r\n */\r\npublic final int getRowIndex() {\r\n    return (_squareIndex) >> 3;\r\n}'),(657,'return _squareIndex','de.java_chess.javaChess.position.PositionImpl',81,81,'de.java_chess.javaChess.position.PositionImpl',603,'de.java_chess.javaChess.position.PositionImpl.getSquareIndex()',1,'// Methods\r\n/**\r\n * Get the square index of this position (0-63).\r\n *\r\n * @return The square index of this position.\r\n */\r\npublic final int getSquareIndex() {\r\n    return _squareIndex;\r\n}'),(658,'return new String(byteRepresentation)','byte',0,81,'de.java_chess.javaChess.position.PositionImpl',605,'de.java_chess.javaChess.position.PositionImpl.toSquareName()',1,'/**\r\n * Convert this position to a square name (like a4).\r\n *\r\n * @return The suare name of this position.\r\n */\r\npublic final String toSquareName() {\r\n    byte[] byteRepresentation = new byte[2];\r\n    byteRepresentation[0] = ((byte) (((int) (a)) + (getLineIndex())));\r\n    byteRepresentation[1] = ((byte) (((int) (1)) + (getRowIndex())));\r\n    return new String(byteRepresentation);\r\n}'),(659,'return _piecesLayer','de.java_chess.javaChess.renderer2d.AnimationLayer',83,83,'de.java_chess.javaChess.renderer2d.AnimationLayer',613,'de.java_chess.javaChess.renderer2d.AnimationLayer.getPiecesLayer()',1,'/**\r\n * Paint the animated piece.\r\n *\r\n * @param g\r\n * 		The graphics context.\r\n */\r\n/* public void paint( Graphics g) {\nSystem.out.println( \"Repaint piece at \" + _currentPoint.x + \",\" + _currentPoint.y);\n// g.drawImage( _piece, _currentPoint.x, _currentPoint.y, this);\n}\n */\r\n/**\r\n * Get the current pieces layer.\r\n *\r\n * @return The current pieces layer.\r\n */\r\nPiecesLayer getPiecesLayer() {\r\n    return _piecesLayer;\r\n}'),(660,'return _boardSize','de.java_chess.javaChess.renderer2d.BoardLayer',84,84,'de.java_chess.javaChess.renderer2d.BoardLayer',618,'de.java_chess.javaChess.renderer2d.BoardLayer.getBoardSize()',1,'/**\r\n * Get the board size.\r\n *\r\n * @return The board size.\r\n */\r\nfinal int getBoardSize() {\r\n    return _boardSize;\r\n}'),(661,'return getMinimumSize()','de.java_chess.javaChess.renderer2d.BoardLayer',84,84,'de.java_chess.javaChess.renderer2d.BoardLayer',619,'de.java_chess.javaChess.renderer2d.BoardLayer.getMaximumSize()',1,'/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}'),(662,'return new Dimension(getBoardSize(), getBoardSize())','de.java_chess.javaChess.renderer2d.BoardLayer',84,84,'de.java_chess.javaChess.renderer2d.BoardLayer',620,'de.java_chess.javaChess.renderer2d.BoardLayer.getMinimumSize()',1,'/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(getBoardSize(), getBoardSize());\r\n}'),(663,'return getMinimumSize()','de.java_chess.javaChess.renderer2d.BoardLayer',84,84,'de.java_chess.javaChess.renderer2d.BoardLayer',621,'de.java_chess.javaChess.renderer2d.BoardLayer.getPreferredSize()',1,'/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}'),(664,'return _squareSize','de.java_chess.javaChess.renderer2d.BoardLayer',84,84,'de.java_chess.javaChess.renderer2d.BoardLayer',622,'de.java_chess.javaChess.renderer2d.BoardLayer.getSquareSize()',1,'/**\r\n * Get the square size.\r\n *\r\n * @return The square size.\r\n */\r\nfinal int getSquareSize() {\r\n    return _squareSize;\r\n}'),(665,'return _board','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',85,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',627,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getBoard()',1,'/**\r\n * Get the current board.\r\n *\r\n * @return The current board.\r\n */\r\npublic final Board getBoard() {\r\n    return _board;\r\n}'),(666,'return getMinimumSize()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',85,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',628,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMaximumSize()',1,'/**\r\n * Get the maximum size of the board.\r\n *\r\n * @return The maximum size of the board.\r\n */\r\npublic final Dimension getMaximumSize() {\r\n    return getMinimumSize();\r\n}'),(667,'return new Dimension(((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)), ((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)))','int',0,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',629,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getMinimumSize()',1,'/**\r\n * Get the minimum size of the board.\r\n *\r\n * @return The minimum size of the board.\r\n */\r\npublic final Dimension getMinimumSize() {\r\n    return new Dimension(((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)), ((8 * (ChessBoardRenderer2D.getSquareSize())) + ((ChessBoardRenderer2D.getSquareSize()) / 2)));\r\n}'),(668,'return getMinimumSize()','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',85,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',630,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getPreferredSize()',1,'/**\r\n * Get the preferred size of the board.\r\n *\r\n * @return The preferred size of the board.\r\n */\r\npublic final Dimension getPreferredSize() {\r\n    return getMinimumSize();\r\n}'),(669,'return ChessBoardRenderer2D._squareSize','de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',85,85,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D',631,'de.java_chess.javaChess.renderer2d.ChessBoardRenderer2D.getSquareSize()',1,'/**\r\n * Get the size of a square.\r\n *\r\n * @return The size of a square as a int (since height and width are the same).\r\n */\r\npublic static final int getSquareSize() {\r\n    return ChessBoardRenderer2D._squareSize;\r\n}'),(670,'return _controller','de.java_chess.javaChess.renderer2d.ControlLayer',87,87,'de.java_chess.javaChess.renderer2d.ControlLayer',638,'de.java_chess.javaChess.renderer2d.ControlLayer.getController()',1,'/**\r\n * Get the game controller.\r\n *\r\n * @return The game controller.\r\n */\r\nprivate final GameController getController() {\r\n    return _controller;\r\n}'),(671,'return ((int) ((_time) / 1000L))','int',0,88,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel',646,'de.java_chess.javaChess.renderer2d.CountdownTimerPanel.getRemainingTime()',1,'/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}'),(672,'return this.jtEngine.getText()','de.java_chess.javaChess.renderer2d.EnginePanel',89,89,'de.java_chess.javaChess.renderer2d.EnginePanel',653,'de.java_chess.javaChess.renderer2d.EnginePanel.getText()',1,'/**\r\n * Get the current text of the panel.\r\n *\r\n * @return The current text of the panel.\r\n */\r\npublic final String getText() {\r\n    return this.jtEngine.getText();\r\n}'),(673,'return _running','de.java_chess.javaChess.renderer2d.GameTimerPanel',90,90,'de.java_chess.javaChess.renderer2d.GameTimerPanel',661,'de.java_chess.javaChess.renderer2d.GameTimerPanel.isRunning()',1,'/**\r\n * Get the active state of this timer.\r\n *\r\n * @return The active state of this timer.\r\n */\r\npublic boolean isRunning() {\r\n    return _running;\r\n}'),(674,'return this.jbBlack.getText()','de.java_chess.javaChess.renderer2d.NotationPanel',92,92,'de.java_chess.javaChess.renderer2d.NotationPanel',682,'de.java_chess.javaChess.renderer2d.NotationPanel.getBlackPlayerName()',1,'/**\r\n * Returns the black players name\r\n *\r\n * @return The String for the black player\r\n */\r\npublic String getBlackPlayerName() {\r\n    return this.jbBlack.getText();\r\n}'),(675,'return this.jbWhite.getText()','de.java_chess.javaChess.renderer2d.NotationPanel',92,92,'de.java_chess.javaChess.renderer2d.NotationPanel',683,'de.java_chess.javaChess.renderer2d.NotationPanel.getWhitePlayerName()',1,'/**\r\n * Returns the white players name\r\n *\r\n * @return The String for the white player\r\n */\r\npublic String getWhitePlayerName() {\r\n    return this.jbWhite.getText();\r\n}'),(676,'return _animationLayer','de.java_chess.javaChess.renderer2d.PiecesLayer',94,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',694,'de.java_chess.javaChess.renderer2d.PiecesLayer.getAnimationLayer()',1,'/**\r\n * Get the current animation layer.\r\n *\r\n * @return The current animation layer.\r\n */\r\nfinal AnimationLayer getAnimationLayer() {\r\n    return _animationLayer;\r\n}'),(677,'return _square[squareIndex]','int',0,94,'de.java_chess.javaChess.renderer2d.PiecesLayer',695,'de.java_chess.javaChess.renderer2d.PiecesLayer.getPositionRenderer(int)',1,'/**\r\n * Get the position renderer for a given square.\r\n *\r\n * @param squareIndex\r\n * 		The index of the square.\r\n * @return The position renderer for the given square.\r\n */\r\nfinal PositionRenderer getPositionRenderer(int squareIndex) {\r\n    return _square[squareIndex];\r\n}'),(678,'return ((int) ((_time) / 1000L))','int',0,97,'de.java_chess.javaChess.renderer2d.TimerPanel',711,'de.java_chess.javaChess.renderer2d.TimerPanel.getRemainingTime()',1,'/**\r\n * Get the remaining time in seconds.\r\n *\r\n * @return The remaining time in seconds.\r\n */\r\npublic int getRemainingTime() {\r\n    return ((int) ((_time) / 1000L));\r\n}'),(679,'return _countdown','de.java_chess.javaChess.renderer2d.TimerPanel',97,97,'de.java_chess.javaChess.renderer2d.TimerPanel',712,'de.java_chess.javaChess.renderer2d.TimerPanel.isCountdown()',1,'/**\r\n * Check, if this timer counts downwards.\r\n *\r\n * @return true, if the counter counts downwards.\r\n */\r\nprivate final boolean isCountdown() {\r\n    return _countdown;\r\n}'),(680,'return suite','junit.framework.TestSuite',0,98,'de.java_chess.javaChess.test.JavaChessTest',720,'de.java_chess.javaChess.test.JavaChessTest.suite()',1,'// Instance variables\r\n// Constructors\r\n// Methods\r\n/**\r\n * Create the main test suite.\r\n *\r\n * @return The main test suite.\r\n */\r\npublic static Test suite() {\r\n    // Create a new test suite.\r\n    TestSuite suite = new TestSuite();\r\n    // Add the test suite for the engine.\r\n    suite.addTest(ChessEngineTest.suite());\r\n    return suite;\r\n}'),(681,'return (_curElement) < (_nItems)','boolean',0,100,'de.java_chess.javaChess.util.ArrayStackIterator',727,'de.java_chess.javaChess.util.ArrayStackIterator.hasNext()',1,'// Methods\r\n/**\r\n * Check, if there are more elements to iterate over.\r\n *\r\n * @return true, if there are more elements.\r\n */\r\npublic final boolean hasNext() {\r\n    return (_curElement) < (_nItems);\r\n}'),(682,'return _items[((_curElement)++)]','int',0,100,'de.java_chess.javaChess.util.ArrayStackIterator',728,'de.java_chess.javaChess.util.ArrayStackIterator.next()',1,'/**\r\n * Get the next elements from the collection.\r\n *\r\n * @return The next element from the collection.\r\n */\r\npublic final Object next() {\r\n    return _items[((_curElement)++)];\r\n}'),(683,'return ResourceLoader._instance','de.java_chess.javaChess.util.ResourceLoader',101,101,'de.java_chess.javaChess.util.ResourceLoader',732,'de.java_chess.javaChess.util.ResourceLoader.getInstance()',1,'// Methods\r\n/**\r\n * Get the only instance of this class.\r\n *\r\n * @return The only instance of this class.\r\n */\r\npublic static final ResourceLoader getInstance() {\r\n    if ((ResourceLoader._instance) == null) {\r\n        ResourceLoader._instance = new ResourceLoader();\r\n    }\r\n    return ResourceLoader._instance;\r\n}'),(684,'return result','java.awt.Image',0,101,'de.java_chess.javaChess.util.ResourceLoader',733,'de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)',1,'/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}'),(685,'return null// Image not found.\r\n','<nulltype>',0,101,'de.java_chess.javaChess.util.ResourceLoader',733,'de.java_chess.javaChess.util.ResourceLoader.loadImage(java.lang.String)',1,'/**\r\n * Load an image resource.\r\n *\r\n * @return The image resource, if it was found or null otherwise.\r\n */\r\npublic final Image loadImage(String imageName) {\r\n    Image result = null;\r\n    for (Iterator iter = _locations.iterator(); iter.hasNext();) {\r\n        try {\r\n            result = Toolkit.getDefaultToolkit().getImage(new URL(((iter.next()) + imageName)));\r\n            if (result != null) {\r\n                return result;\r\n            }\r\n        } catch (MalformedURLException ignored) {\r\n        }\r\n    }\r\n    return null;// Image not found.\r\n\r\n}'),(686,'// only character count\r\nreturn ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)','int',0,102,'de.java_chess.javaChess.util.StringTextDocument',735,'de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)',1,'/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * 		The string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}'),(687,'// numbers only\r\nreturn (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s))','int',0,102,'de.java_chess.javaChess.util.StringTextDocument',735,'de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)',1,'/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * 		The string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}'),(688,'// a3-d3 and a6-d6 are valid squares for en passant\r\nreturn this.isValidSquare(s, true)','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',735,'de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)',1,'/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * 		The string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}'),(689,'// between a1 and h8\r\nreturn this.isValidSquare(s, false)','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',735,'de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)',1,'/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * 		The string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}'),(690,'return false','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',735,'de.java_chess.javaChess.util.StringTextDocument.canBecomeValid(java.lang.String)',1,'/**\r\n * Returns if the new string (after inserting a character or pasted string) is valid\r\n *\r\n * @param s\r\n * 		The string to check\r\n * @return <code>true</code> if the string is valid, based on the users conditions\r\ngiven in the constructor\r\n */\r\npublic boolean canBecomeValid(String s) {\r\n    switch (iType) {\r\n        case CHECK_FOR_CHAR_NUM :\r\n            // only character count\r\n            return ((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0);\r\n        case CHECK_FOR_NUMBER :\r\n            // numbers only\r\n            return (((s.length()) <= (iCharacterCount)) && ((s.length()) >= 0)) && (isValid(s));\r\n        case CHECK_FOR_EP_SQUARE :\r\n            // a3-d3 and a6-d6 are valid squares for en passant\r\n            return this.isValidSquare(s, true);\r\n        case CHECK_FOR_SQUARE :\r\n            // between a1 and h8\r\n            return this.isValidSquare(s, false);\r\n        default :\r\n            return false;\r\n    }\r\n}'),(691,'return true','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',737,'de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)',1,'/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * 		The string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}'),(692,'return false','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',737,'de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)',1,'/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * 		The string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}'),(693,'return false','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',737,'de.java_chess.javaChess.util.StringTextDocument.isValid(java.lang.String)',1,'/**\r\n * Parse the string for number with value > 0\r\n *\r\n * @param sNewString\r\n * 		The string to parse\r\n * @return <code>true</code> when the given string is a number with value > 0\r\n */\r\nprivate boolean isValid(String sNewString) {\r\n    try {\r\n        int iVal = Integer.parseInt(sNewString);\r\n        if (iVal > 0)\r\n            return true;\r\n\r\n        return false;\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}'),(694,'return true','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',738,'de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)',1,'/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * 		The character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}'),(695,'return false','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',738,'de.java_chess.javaChess.util.StringTextDocument.isValidLine(char)',1,'/**\r\n * Checks the character for being between a and h which limit the chessboard lines\r\n *\r\n * @param charToCheck\r\n * 		The character to check\r\n * @return <code>true</code> when between a and h\r\n */\r\nprivate boolean isValidLine(char charToCheck) {\r\n    if (((charToCheck >= a) && (charToCheck <= h)) || ((charToCheck >= A) && (charToCheck <= H))) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}'),(696,'return true','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',1,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(697,'return true','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',1,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(698,'return false','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',1,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(699,'return true','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',1,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(700,'return false','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',1,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(701,'return false','boolean',0,102,'de.java_chess.javaChess.util.StringTextDocument',739,'de.java_chess.javaChess.util.StringTextDocument.isValidSquare(java.lang.String,boolean)',1,'/**\r\n * Checks whether the given string consists of a valid square from a chessboard\r\n * between a1 and h8\r\n *\r\n * @param sString\r\n * 		The string to parse\r\n * @param bEnPassantSquare\r\n * 		Flag to check for en passant (3rd row) or not\r\n * @return <code>true</code> if square is valid on a chessboard\r\n */\r\nprivate boolean isValidSquare(String sString, boolean bEnPassantSquare) {\r\n    if (((sString.length()) <= (iCharacterCount)) && ((sString.length()) > 0)) {\r\n        if (isValidLine(sString.charAt(0))) {\r\n            if ((sString.length()) == 2) {\r\n                if (bEnPassantSquare == false) {\r\n                    if (((sString.charAt(1)) >= 1) && ((sString.charAt(1)) <= 8)) {\r\n                        return true;\r\n                    }\r\n                } else {\r\n                    if (((sString.charAt(1)) == 3) || ((sString.charAt(1)) == 6)) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}'),(702,'return (_nItems) == 0','int',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',745,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.empty()',1,'// Methods\r\n/**\r\n * Test, if this stack is empty.\r\n *\r\n * @return true, if the stack is empty. False otherwise.\r\n */\r\npublic final boolean empty() {\r\n    return (_nItems) == 0;\r\n}'),(703,'return new ArrayStackIterator(_items, _nItems)','de.java_chess.javaChess.util.UnsynchronizedArrayStack',104,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',747,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.iterator()',1,'/**\r\n * Get a iterator for the elements of this stack.\r\n *\r\n * @return A iterator for the elements of this stack.\r\n */\r\npublic final Iterator iterator() {\r\n    return new ArrayStackIterator(_items, _nItems);\r\n}'),(704,'return empty() ? null : _items[((_nItems) - 1)]','int',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',748,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.peek()',1,'/**\r\n * Look at the object, that is at the top of the stack without removing it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object peek() {\r\n    return empty() ? null : _items[((_nItems) - 1)];\r\n}'),(705,'return item','Object',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',749,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.pop()',1,'/**\r\n * Remove the object at the top of the stack and return it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object pop() {\r\n    if (!(empty())) {\r\n        Object item = _items[(--(_nItems))];\r\n        _items[_nItems] = null;\r\n        return item;\r\n    }\r\n    return null;\r\n}'),(706,'return null','<nulltype>',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',749,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.pop()',1,'/**\r\n * Remove the object at the top of the stack and return it.\r\n *\r\n * @return The object at the top of the stack.\r\n */\r\npublic final Object pop() {\r\n    if (!(empty())) {\r\n        Object item = _items[(--(_nItems))];\r\n        _items[_nItems] = null;\r\n        return item;\r\n    }\r\n    return null;\r\n}'),(707,'return i','int',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',751,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)',1,'/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}'),(708,'return -1','int',0,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',751,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.search(java.lang.Object)',1,'/**\r\n * Return the position of a object on the stack, or -1 if it\r\n * is not found.\r\n *\r\n * @return The position of the object on the stack.\r\n */\r\npublic final int search(Object o) {\r\n    for (int i = 0; i < (_nItems); i++) {\r\n        if (_items[i].equals(o)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}'),(709,'return _nItems','de.java_chess.javaChess.util.UnsynchronizedArrayStack',104,104,'de.java_chess.javaChess.util.UnsynchronizedArrayStack',752,'de.java_chess.javaChess.util.UnsynchronizedArrayStack.size()',1,'/**\r\n * Get the current number of elements on the stack.\r\n *\r\n * @param The\r\n * 		current size of the stack.\r\n */\r\npublic final int size() {\r\n    return _nItems;\r\n}');
/*!40000 ALTER TABLE `parameters` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-05-07 15:41:52
