/**
 * Function to dedent selected task this will change the parent child
 * relationship. This Code is based on the UP/DOWN Coder I found in here
 * barmeier
 */
/**
 * Unindent the selected nodes.
 */
public void dedentCurrentNodes() {
    final DefaultMutableTreeNode[] cdmtn = getSelectedTaskNodes();
    if (cdmtn == null) {
        myUIFacade.setStatusText(language.getText("msg21"));
        return;
    }
    final GanttTree2 gt2 = this;
    getUndoManager().undoableEdit("Dedent", new Runnable() {
        public void run() {
            TreePath[] selectedPaths = new TreePath[cdmtn.length];
            // Information about previous node is needed to determine if current node had sibling that was moved.
            DefaultMutableTreeNode previousFather = new DefaultMutableTreeNode();
            DefaultMutableTreeNode father = new DefaultMutableTreeNode();
            HashSet targetContainers = new HashSet();
            for (int i = 0; i < (cdmtn.length); i++) {
                // We use information about previous father to determine new index of the node in the tree.
                if (i > 0) {
                    previousFather = father;
                }
                father = gt2.getFatherNode(cdmtn[i]);
                // Getting the fathers father !? The grandpa I think  :)
                DefaultMutableTreeNode newFather = gt2.getFatherNode(father);
                // If no grandpa is available we must stop.
                if (newFather == null) {
                    return;
                }
                int oldIndex = father.getIndex(((TreeNode) (cdmtn[i])));
                cdmtn[i].removeFromParent();
                treeModel.nodesWereRemoved(father, new int[]{ oldIndex }, new Object[]{ cdmtn });
                targetContainers.add(((Task) (father.getUserObject())));
                // If node and previous node were siblings add current node after its previous sibling
                int newIndex;
                if ((i > 0) && (father.equals(previousFather))) {
                    newIndex = (newFather.getIndex(((TreeNode) (cdmtn[(i - 1)])))) + 1;
                } else {
                    newIndex = (newFather.getIndex(((TreeNode) (father)))) + 1;
                }
                ((GanttTreeTableModel) (treeModel)).insertNodeInto(((MutableTreeNode) (cdmtn[i])), ((MutableTreeNode) (newFather)), newIndex);
                // Select tagain this node
                TreeNode[] treepath = cdmtn[i].getPath();
                TreePath path = new TreePath(treepath);
                // tree.setSelectionPath(path);
                selectedPaths[i] = path;
                // refresh the father date
                // Task current = (Task)(cdmtn[i].getUserObject());
                // refreshAllFather(current.toString());
                expandRefresh(cdmtn[i]);
                if ((father.getChildCount()) == 0)
                    ((Task) (father.getUserObject())).setProjectTask(false);

            }
            getTaskManager().getAlgorithmCollection().getAdjustTaskBoundsAlgorithm().run(((Task[]) (targetContainers.toArray(new Task[0]))));
            forwardScheduling();
            treetable.getTree().setSelectionPaths(selectedPaths);
            area.repaint();
            // appli.setQuickSave (true);
            // appli.quickSave ("Dedent");
        }
    });
}