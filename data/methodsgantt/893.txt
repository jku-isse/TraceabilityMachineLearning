public void dragOver(DropTargetDragEvent dtde) {
    if (!(isDragAcceptable(dtde)))
        dtde.rejectDrag();
    else
        dtde.acceptDrag(dtde.getDropAction());

    // Even if the mouse is not moving, this method is still invoked
    // 10 times per second
    Point pt = dtde.getLocation();
    if (pt.equals(lastEventPoint))
        return;

    lastEventPoint = pt;
    Graphics2D g2 = ((Graphics2D) (treetable.getGraphics()));
    // If a drag image is not supported by the platform, then draw our
    // own drag image
    if (!(DragSource.isDragImageSupported())) {
        // Rub out the last ghost image and cue line
        treetable.paintImmediately(ghostImageRect.getBounds());
        // And remember where we are about to draw the new ghost image
        ghostImageRect.setRect(((pt.x) - (offsetPoint.x)), ((pt.y) - (offsetPoint.y)), ghostImage.getWidth(), ghostImage.getHeight());
        g2.drawImage(ghostImage, AffineTransform.getTranslateInstance(ghostImageRect.getX(), ghostImageRect.getY()), null);
    } else {
        // Just rub out the last cue line
        treetable.paintImmediately(cueLineRect.getBounds());
    }
    TreePath path = treetable.getTree().getClosestPathForLocation(pt.x, pt.y);
    if (!(path == (lastPath))) {
        lastPath = path;
        hoverTimer.restart();
    }
    // In any case draw (over the ghost image if necessary) a cue line
    // indicating where a drop will occur
    Rectangle raPath = treetable.getTree().getPathBounds(path);
    if (raPath == null)
        raPath = new Rectangle(1, 1);

    cueLineRect.setRect(0, ((raPath.y) + ((int) (raPath.getHeight()))), getWidth(), 2);
    g2.setColor(cueLineColor);
    g2.fill(cueLineRect);
    // And include the cue line in the area to be rubbed out next time
    ghostImageRect = ghostImageRect.createUnion(cueLineRect);
}