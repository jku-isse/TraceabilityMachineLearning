public void adjustNestedTasks(Task supertask) throws TaskDependencyException {
    TaskContainmentHierarchyFacade containmentFacade = createContainmentFacade();
    /* <Task> */
    List nestedTasks = new ArrayList(Arrays.asList(containmentFacade.getNestedTasks(supertask)));
    if ((nestedTasks.size()) == 0) {
        return;
    }
    SortTasksAlgorithm sortAlgorithm = new SortTasksAlgorithm();
    sortAlgorithm.sortTasksByStartDate(nestedTasks);
    Set modifiedTasks = new HashSet();
    for (int i = 0; i < (nestedTasks.size()); i++) {
        Task nextNested = ((Task) (nestedTasks.get(i)));
        if (nextNested.getStart().getTime().before(supertask.getStart().getTime())) {
            TaskMutator mutator = nextNested.createMutatorFixingDuration();
            mutator.setStart(supertask.getStart());
            mutator.commit();
            // 
            modifiedTasks.add(nextNested);
        }
        if (nextNested.getEnd().getTime().after(supertask.getEnd().getTime())) {
            TaskMutator mutator = nextNested.createMutatorFixingDuration();
            mutator.shift(supertask.getManager().createLength(supertask.getDuration().getTimeUnit(), nextNested.getEnd().getTime(), supertask.getEnd().getTime()));
            mutator.commit();
            // 
            modifiedTasks.add(nextNested);
        }
    }
    run(((Task[]) (modifiedTasks.toArray(new Task[0]))));
    RecalculateTaskScheduleAlgorithm alg = new RecalculateTaskScheduleAlgorithm(this) {
        protected TaskContainmentHierarchyFacade createContainmentFacade() {
            return AdjustTaskBoundsAlgorithm.this.createContainmentFacade();
        }
    };
    alg.run(modifiedTasks);
}