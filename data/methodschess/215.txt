/**
 * Add the plies for one rook position.
 *
 * @param square
 * 		The square index of the rook pos.
 */
private final void addPliesForRookPos(int square) {
    int orgPos = square;// Save the original position.

    long bitmask;
    // Compute plies to the left.
    bitmask = 1L << square;
    while ((square & 7) > 0) {
        square -= 1;
        bitmask >>>= 1;
        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {
            boolean capture = (bitmask & (_attackablePieces)) != 0L;
            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));
            // If we attacked a piece, we cannot move further
            if (capture) {
                break;
            }
        } else {
            break;
        }
    } 
    // Compute plies downwards.
    square = orgPos;
    bitmask = 1L << square;
    while (square > 8) {
        square -= 8;
        bitmask >>>= 8;
        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {
            boolean capture = (bitmask & (_attackablePieces)) != 0L;
            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));
            // If we attacked a piece, we cannot move further
            if (capture) {
                break;
            }
        } else {
            break;
        }
    } 
    // Compute plies to the right.
    square = orgPos;
    bitmask = 1L << square;
    while ((square & 7) < 7) {
        square += 1;
        bitmask <<= 1;
        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {
            boolean capture = (bitmask & (_attackablePieces)) != 0L;
            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));
            // If we attacked a piece, we cannot move further
            if (capture) {
                break;
            }
        } else {
            break;
        }
    } 
    // Compute plies upwards.
    square = orgPos;
    bitmask = 1L << square;
    while (square < 56) {
        square += 8;
        bitmask <<= 8;
        if ((bitmask & ((_emptySquares) | (_attackablePieces))) != 0) {
            boolean capture = (bitmask & (_attackablePieces)) != 0L;
            addRegularPly(orgPos, square, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));
            // If we attacked a piece, we cannot move further
            if (capture) {
                break;
            }
        } else {
            break;
        }
    } 
}