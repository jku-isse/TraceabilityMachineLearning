/**
 * Test, if the given player is in check.
 *
 * @param white
 * 		Flag, if the white king is to test.
 * @return true, if the king is in check, false otherwise.
 */
public final boolean isInCheck(boolean white) {
    // Get the position of the king.
    long kingPosition = getBoard().getPositionOfPieces((white ? ((Piece.KING) << 1) | 1 : (Piece.KING) << 1));
    int kingSquare = BitUtils.getHighestBit(kingPosition);
    // Get and cache the empty squares of the current board.
    long emptySquares = getBoard().getEmptySquares();
    // Now compute the moves backwards from the kings position.
    // Get all positions of bishops and queens
    long bishopPositions = getBoard().getPositionOfPieces((white ? (Piece.BISHOP) << 1 : ((Piece.BISHOP) << 1) | 1));
    long queenPositions = getBoard().getPositionOfPieces((white ? (Piece.QUEEN) << 1 : ((Piece.QUEEN) << 1) | 1));
    // The pieces, that attack diagonal
    long diagonalPositions = bishopPositions | queenPositions;
    // Move the king to the upper right.
    long kingMask = kingPosition;
    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) & emptySquares) != 0L);
    if ((kingMask & diagonalPositions) != 0L) {
        return true;// King is in check!

    }
    // Move the king to the lower right.
    kingMask = kingPosition;// Reset bitmask.

    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) & emptySquares) != 0L);
    if ((kingMask & diagonalPositions) != 0L) {
        return true;// King is in check!

    }
    // Move the king to the upper left.
    kingMask = kingPosition;// Reset bitmask.

    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7) & emptySquares) != 0L);
    if ((kingMask & diagonalPositions) != 0L) {
        return true;// King is in check!

    }
    // Move the king to the lower left
    kingMask = kingPosition;// Reset bitmask.

    while (((kingMask = ((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9) & emptySquares) != 0L);
    if ((kingMask & diagonalPositions) != 0L) {
        return true;// King is in check!

    }
    // Now we need the rooks, too.
    long rookPositions = getBoard().getPositionOfPieces((white ? (Piece.ROOK) << 1 : ((Piece.ROOK) << 1) | 1));
    // The pieces, that attack horizontally or vertically.
    long horVertPositions = rookPositions | queenPositions;
    // Move the king downwards
    kingMask = kingPosition;// Reset bitmask.

    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_1)) >>> 8) & emptySquares) != 0L);
    if ((kingMask & horVertPositions) != 0L) {
        return true;// King is in check!

    }
    // Move the king upwards
    kingMask = kingPosition;// Reset bitmask.

    while (((kingMask = (kingMask & (BitBoard._NOT_ROW_8)) << 8) & emptySquares) != 0L);
    if ((kingMask & horVertPositions) != 0L) {
        return true;// King is in check!

    }
    // Move the king to the left
    kingMask = kingPosition;// Reset bitmask.

    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_A)) >>> 1) & emptySquares) != 0L);
    if ((kingMask & horVertPositions) != 0L) {
        return true;// King is in check!

    }
    // Move the king to the right
    kingMask = kingPosition;// Reset bitmask.

    while (((kingMask = (kingMask & (BitBoard._NOT_LINE_H)) << 1) & emptySquares) != 0L);
    if ((kingMask & horVertPositions) != 0L) {
        return true;// King is in check!

    }
    // Check, if the king is in check by a knight
    // Compute the knight moves backwards from the position of the
    // king and see, if theres a knight on this square.
    if (((getPlyGenerator().getKnightPlies(kingSquare)) & (getBoard().getPositionOfPieces((white ? (Piece.KNIGHT) << 1 : ((Piece.KNIGHT) << 1) | 1)))) != 0L) {
        return true;
    }
    // Check if the king is in check by a pawn
    kingMask = kingPosition;// Reset bitmask.

    if (white) {
        // Get the positions of all black pawns and compare them with a moved king.
        return (((((kingMask & (BitBoard._NOT_LINE_H)) & (BitBoard._NOT_ROW_8)) << 9) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_8)) << 7)) & (getBoard().getPositionOfPieces(((Piece.PAWN) << 1)))) != 0L;
    } else {
        // Get the positions of all white pawns and compare them with a moved king.
        return (((((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 7) | (((kingMask & (BitBoard._NOT_LINE_A)) & (BitBoard._NOT_ROW_1)) >>> 9)) & (getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1)))) != 0L;
    }
}