/**
 * Start a complete Minimax-Alpha-Beta search. This is the search level 1, where we have to store the
 * analyzed ply, so it gets a special method.
 *
 * @param white
 * 		Flag to indicate, if white is about to move.
 * @throws InterruptedException
 * 		if the search was interrupted because of a timeout.
 */
public final AnalyzedPly startMinimaxAlphaBeta(boolean white) throws InterruptedException {
    short curAlpha = AnalyzedPly.MIN_SCORE;
    short curBeta = AnalyzedPly.MAX_SCORE;
    int bestPlyIndex = -1;
    Ply[] plies = _plyGenerator.getPliesForColor(((BitBoard) (getBoard())), white);
    if (white) {
        for (int i = 0; i < (plies.length); i++) {
            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {
                // If the search time is over and at least depth 1 was completed
                throw new InterruptedException(("Search interrupted at depth " + (getSearchDepth())));// abort the search.

            }
            getGame().doPly(plies[i]);
            short val;
            try {
                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), false, 1, curAlpha, curBeta);
            } catch (InterruptedException ie) {
                getGame().undoLastPly();// Undo the last move

                throw ie;// and pass the exception.

            }
            if (val > curAlpha) {
                curAlpha = val;
                bestPlyIndex = i;
            }
            if (curAlpha >= curBeta) {
                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.

                break;
            }
            getGame().undoLastPly();
        }
        if (bestPlyIndex != (-1)) {
            // Since this is the best ply so far, we store it in the hashtable. This makes sense,
            // since the minimax algorithm is started several times, before a move is selected.
            // So this move is not necessarily applied immediately!
            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));
            return new AnalyzedPlyImpl(plies[bestPlyIndex], curAlpha);
        } else {
            return null;
        }
    } else {
        for (int i = 0; i < (plies.length); i++) {
            if ((isSearchStop()) && ((getSearchDepth()) > 1)) {
                // If the search time is over and at least depth 1 was completed
                throw new InterruptedException(("Search interrupted at depth " + (getSearchDepth())));// abort the search.

            }
            getGame().doPly(plies[i]);
            short val;
            try {
                val = minimaxAlphaBeta(plies[i], getBoard().getBoardAfterPly(plies[i]), true, 1, curAlpha, curBeta);
            } catch (InterruptedException ie) {
                getGame().undoLastPly();// Undo the last move

                throw ie;// and pass the exception.

            }
            if (val < curBeta) {
                curBeta = val;
                bestPlyIndex = i;
            }
            if (curBeta <= curAlpha) {
                getGame().undoLastPly();// Take the last ply back, before the loop is aborted.

                break;
            }
            getGame().undoLastPly();
        }
        if (bestPlyIndex != (-1)) {
            // Since this is the best ply so far, we store it in the hashtable. This makes sense,
            // since the minimax algorithm is started several times, before a move is selected.
            // So this move is not necessarily applied immediately!
            getHashtable().pushEntry(new PlyHashtableEntryImpl(getBoard(), plies[bestPlyIndex], getSearchDepth()));
            return new AnalyzedPlyImpl(plies[bestPlyIndex], curBeta);
        } else {
            return null;
        }
    }
}