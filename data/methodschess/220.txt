/**
 * Convert a bitmask to a series of relative plies.
 * We pass the destination fields here along with a offset to compute the source square.
 *
 * @param destinationPos
 * 		The destination positions for all the plies.
 * @param int
 * 		startBit The bit to start scanning from.
 * @param int
 * 		endBit The bit to end the scanning at.
 * 		int offset The offset for each ply.
 */
private final void addRelativePliesUpward(long destinationPos, int startBit, int endBit, int offset) {
    // Compute a bitmask to mask the bits in the destination bitfield.
    long bitmask = 1L << startBit;
    // End the loop also if the bitmask is 0, so there are no more destination fields
    // in the bitmask (so we dont have to check the entire chessboard for plies).
    for (int currentBit = startBit; (currentBit <= endBit) && (destinationPos != 0); currentBit++) {
        // If the bit of the destination square is set, its the destination for a ply.
        if ((destinationPos & bitmask) != 0) {
            // Add the ply to the buffer.
            boolean capture = (bitmask & (_attackablePieces)) != 0L;
            addRegularPly((currentBit + offset), currentBit, capture, (capture ? MATERIAL_WIN : REGULAR_PLY));
            // Remove the bit, so we can check if there are more plies to find.
            destinationPos &= ~bitmask;
        }
        bitmask <<= 1;
    }
}