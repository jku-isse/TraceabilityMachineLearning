/**
 * Add all the plies for pawns of the current color.
 */
private final void addPliesForPawns() {
    if (_white) {
        // Get the positions of all pawns
        long pawnPos = getBoard().getPositionOfPieces((((Piece.PAWN) << 1) | 1));
        // Add all the diagonal attacks
        addRelativePliesUpward((((pawnPos & (BitBoard._NOT_LINE_H)) << 9) & (_attackablePieces)), 17, 63, (-9));
        addRelativePliesUpward((((pawnPos & (BitBoard._NOT_LINE_A)) << 7) & (_attackablePieces)), 16, 62, (-7));
        // Check for a en-passent attack
        if ((getLastPly()) != null) {
            Position destination = getLastPly().getDestination();
            Piece piece = getBoard().getPiece(destination);
            // The check for the color is sorta redundant, but during analysis the
            // order of moves might be incorrect.
            if (((piece != null) && ((piece.getType()) == (Piece.PAWN))) && ((piece.getColor()) == (Piece.BLACK))) {
                int sourceIndex = getLastPly().getSource().getSquareIndex();
                int destinationIndex = getLastPly().getDestination().getSquareIndex();
                // If the pawn moved 2 squares
                if ((sourceIndex - destinationIndex) == 16) {
                    int attackableIndex = sourceIndex - 8;
                    // Compute the bitmask for the pawn.
                    long attackablePawnBitmask = 1L << attackableIndex;
                    // Add the en passant attacks.
                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) << 9) & attackablePawnBitmask) != 0L) {
                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex - 9)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);
                    }
                    // Add the en passant attacks.
                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) << 7) & attackablePawnBitmask) != 0L) {
                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex - 7)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);
                    }
                }
            }
        }
        // Add all the 2 square plies. Since the square in front of the pawn has to be free, I have to
        // add the bit and with the shifted empty squares.
        addRelativePliesUpward(((((pawnPos & (BitBoard._ROW_2)) & ((_emptySquares) >>> 8)) << 16) & (_emptySquares)), 24, 31, (-16));
        // Add all the 1 square plies.
        long movedPawns = (pawnPos << 8) & (_emptySquares);
        addRelativePliesUpward((movedPawns & (BitBoard._NOT_ROW_8)), 16, 55, (-8));
        // Now take care of the last row.
        movedPawns &= BitBoard._ROW_8;
        while (movedPawns != 0L) {
            int destinationSquare = BitUtils.getHighestBit(movedPawns);
            int sourceSquare = destinationSquare - 8;
            // Add all transformation types as plies.
            boolean capture = ((1L << destinationSquare) & (_attackablePieces)) != 0L;
            addTransformationPly(sourceSquare, destinationSquare, Piece.QUEEN, capture, QUEEN_TRANSFORMATION);
            addTransformationPly(sourceSquare, destinationSquare, Piece.KNIGHT, capture, KNIGHT_TRANSFORMATION);
            addTransformationPly(sourceSquare, destinationSquare, Piece.ROOK, capture, ROOK_TRANSFORMATION);
            addTransformationPly(sourceSquare, destinationSquare, Piece.BISHOP, capture, BISHOP_TRANSFORMATION);
            movedPawns &= ~(1L << destinationSquare);
        } 
    } else {
        // Get the positions of all pawns
        long pawnPos = getBoard().getPositionOfPieces(((Piece.PAWN) << 1));
        // Add all the diagonal attacks
        addRelativePliesDownward((((pawnPos & (BitBoard._NOT_LINE_A)) >>> 9) & (_attackablePieces)), 46, 0, 9);
        addRelativePliesDownward((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 7) & (_attackablePieces)), 47, 0, 7);
        // Check for a en-passent attack
        if ((getLastPly()) != null) {
            Position destination = getLastPly().getDestination();
            Piece piece = getBoard().getPiece(destination);
            // The check for the color is sorta redundant, but during analysis the
            // order of moves might be incorrect.
            if (((piece != null) && ((piece.getType()) == (Piece.PAWN))) && ((piece.getColor()) == (Piece.BLACK))) {
                int sourceIndex = getLastPly().getSource().getSquareIndex();
                int destinationIndex = getLastPly().getDestination().getSquareIndex();
                // If the pawn moved 2 squares
                if ((destinationIndex - sourceIndex) == 16) {
                    int attackableIndex = sourceIndex + 8;
                    // Compute the bitmask for the pawn.
                    long attackablePawnBitmask = 1L << attackableIndex;
                    // Add the en passant attacks.
                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 9) & attackablePawnBitmask) != 0L) {
                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex + 9)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);
                    }
                    // Add the en passant attacks.
                    if ((((pawnPos & (BitBoard._NOT_LINE_H)) >>> 7) & attackablePawnBitmask) != 0L) {
                        addPly(new EnPassantPlyImpl(new PositionImpl((attackableIndex + 7)), new PositionImpl(attackableIndex), new PositionImpl(destinationIndex)), MATERIAL_WIN);
                    }
                }
            }
        }
        // Add all the 2 square plies. Since the square in front of the pawn has to be free, I have to
        // add the bit and with the shifted empty squares.
        addRelativePliesDownward(((((pawnPos & (BitBoard._ROW_7)) & ((_emptySquares) << 8)) >>> 16) & (_emptySquares)), 39, 32, 16);
        // Add all the 1 square plies.
        long movedPawns = (pawnPos >>> 8) & (_emptySquares);
        addRelativePliesDownward((movedPawns & (BitBoard._NOT_ROW_1)), 56, 8, 8);
        // Now take care of the last row.
        movedPawns &= BitBoard._ROW_1;
        while (movedPawns != 0L) {
            int destinationSquare = BitUtils.getHighestBit(movedPawns);
            int sourceSquare = destinationSquare + 8;
            // Add all transformation types as plies.
            boolean capture = ((1L << destinationSquare) & (_attackablePieces)) != 0L;
            addTransformationPly(sourceSquare, destinationSquare, Piece.QUEEN, capture, QUEEN_TRANSFORMATION);
            addTransformationPly(sourceSquare, destinationSquare, Piece.KNIGHT, capture, KNIGHT_TRANSFORMATION);
            addTransformationPly(sourceSquare, destinationSquare, Piece.ROOK, capture, ROOK_TRANSFORMATION);
            addTransformationPly(sourceSquare, destinationSquare, Piece.BISHOP, capture, BISHOP_TRANSFORMATION);
            movedPawns &= ~(1L << destinationSquare);
        } 
    }
}