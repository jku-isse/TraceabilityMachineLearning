/**
 * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
 * <code>nohref</code> Attribute for the specified figure and shape.
 *
 * @return Returns true, if the polygon is inside of the image bounds.
 */
private boolean writePolyAttributes(IXMLElement elem, SVGFigure f, Shape shape) {
    AffineTransform t = AttributeKeys.TRANSFORM.getClone(f);
    if (t == null) {
        t = drawingTransform;
    } else {
        t.preConcatenate(drawingTransform);
    }
    StringBuilder buf = new StringBuilder();
    float[] coords = new float[6];
    GeneralPath path = new GeneralPath();
    for (PathIterator i = shape.getPathIterator(t, 1.5F); !(i.isDone()); i.next()) {
        switch (i.currentSegment(coords)) {
            case PathIterator.SEG_MOVETO :
                if ((buf.length()) != 0) {
                    throw new IllegalArgumentException(("Illegal shape " + shape));
                }
                if ((buf.length()) != 0) {
                    buf.append(,);
                }
                buf.append(((int) (coords[0])));
                buf.append(,);
                buf.append(((int) (coords[1])));
                path.moveTo(coords[0], coords[1]);
                break;
            case PathIterator.SEG_LINETO :
                if ((buf.length()) != 0) {
                    buf.append(,);
                }
                buf.append(((int) (coords[0])));
                buf.append(,);
                buf.append(((int) (coords[1])));
                path.lineTo(coords[0], coords[1]);
                break;
            case PathIterator.SEG_CLOSE :
                path.closePath();
                break;
            default :
                throw new InternalError(("Illegal segment type " + (i.currentSegment(coords))));
        }
    }
    elem.setAttribute("shape", "poly");
    elem.setAttribute("coords", buf.toString());
    writeHrefAttribute(elem, f);
    return path.intersects(new Rectangle2D.Float(bounds.x, bounds.y, bounds.width, bounds.height));
}