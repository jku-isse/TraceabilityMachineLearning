/**
 * Reads enough of the input stream to convert
 * to/from Base64 and returns the next byte.
 *
 * @return next byte
 * @since 1.3
 */
public int read() throws IOException {
    // Do we need to get data?
    if ((position) < 0) {
        if (encode) {
            byte[] b3 = new byte[3];
            int numBinaryBytes = 0;
            for (int i = 0; i < 3; i++) {
                try {
                    int b = in.read();
                    // If end of stream, b is -1.
                    if (b >= 0) {
                        b3[i] = ((byte) (b));
                        numBinaryBytes++;
                    }// end if: not end of stream

                }// end try: read
                 catch (IOException e) {
                    // Only a problem if we got no data at all.
                    if (i == 0)
                        throw e;

                }// end catch

            }// end for: each needed input byte

            if (numBinaryBytes > 0) {
                Base64.encode3to4(b3, 0, numBinaryBytes, buffer, 0);
                position = 0;
                numSigBytes = 4;
            }// end else
             else // end if: got data
            {
                return -1;
            }// end else

        }// end else: decode
         else // end if: encoding
        // Else decoding
        {
            byte[] b4 = new byte[4];
            int i = 0;
            for (i = 0; i < 4; i++) {
                // Read four "meaningful" bytes:
                int b = 0;
                do {
                    b = in.read();
                } while ((b >= 0) && ((Base64.DECODABET[(b & 127)]) <= (Base64.WHITE_SPACE_ENC)) );
                if (b < 0)
                    break;
                // Reads a -1 if end of stream

                b4[i] = ((byte) (b));
            }// end for: each needed input byte

            if (i == 4) {
                numSigBytes = Base64.decode4to3(b4, 0, buffer, 0);
                position = 0;
            }// end
             else// end if: got four characters

                if (i == 0) {
                    return -1;
                } else // end else if: also padded correctly
                {
                    // Must have broken out from above.
                    throw new IOException("Improperly padded Base64 input.");
                }
            // end

        }// end else: decode

    }// end else: get data

    // Got data?
    if ((position) >= 0) {
        // End of relevant data?
        /* !encode && */
        if ((position) >= (numSigBytes))
            return -1;

        if (((encode) && (breakLines)) && ((lineLength) >= (Base64.MAX_LINE_LENGTH))) {
            lineLength = 0;
            return 
;
        }// end else
         else // end if
        {
            (lineLength)++;// This isnt important when decoding

            // but throwing an extra "if" seems
            // just as wasteful.
            int b = buffer[((position)++)];
            if ((position) >= (bufferLength))
                position = -1;

            return b & 255;// This is how you "cast" a byte thats

            // intended to be unsigned.
        }// end else

    }// end else
     else // end if: position >= 0
    // Else error
    {
        // When JDK1.4 is more accepted, use an assertion here.
        throw new IOException("Error in Base64 code reading stream.");
    }// end else

}// end read
