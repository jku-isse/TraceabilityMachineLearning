/**
 * Very low-level access to decoding ASCII characters in
 * the form of a byte array. Does not support automatically
 * gunzipping or any other "fancy" features.
 *
 * @param source
 * 		The Base64 encoded data
 * @param off
 * 		The offset of where to begin decoding
 * @param len
 * 		The length of characters to decode
 * @return decoded data
 * @since 1.3
 */
public static byte[] decode(byte[] source, int off, int len) {
    int len34 = (len * 3) / 4;
    byte[] outBuff = new byte[len34];// Upper limit on size of output

    int outBuffPosn = 0;
    byte[] b4 = new byte[4];
    int b4Posn = 0;
    int i = 0;
    byte sbiCrop = 0;
    byte sbiDecode = 0;
    for (i = off; i < (off + len); i++) {
        sbiCrop = ((byte) ((source[i]) & 127));// Only the low seven bits

        sbiDecode = Base64.DECODABET[sbiCrop];
        // White space, Equals sign or better
        if (sbiDecode >= (Base64.WHITE_SPACE_ENC)) {
            if (sbiDecode >= (Base64.EQUALS_SIGN_ENC)) {
                b4[(b4Posn++)] = sbiCrop;
                if (b4Posn > 3) {
                    outBuffPosn += Base64.decode4to3(b4, 0, outBuff, outBuffPosn);
                    b4Posn = 0;
                    // If that was the equals sign, break out of for loop
                    if (sbiCrop == (Base64.EQUALS_SIGN))
                        break;

                }// end if: quartet built

            }// end if: equals sign or better

        }// end else:
         else // end if: white space, equals sign or better
        {
            System.err.println((((("Bad Base64 input character at " + i) + ": ") + (source[i])) + "(decimal)"));
            return null;
        }// end else:

    }// each input character

    byte[] out = new byte[outBuffPosn];
    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
    return out;
}// end decode
