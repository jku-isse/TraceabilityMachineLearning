/**
 * Returns the coordinates and type of the current path segment in
 * the iteration.
 * The return value is the path segment type:
 * SEG_MOVETO, SEG_LINETO, SEG_QUADTO, SEG_CUBICTO, or SEG_CLOSE.
 * A float array of length 6 must be passed in and may be used to
 * store the coordinates of the point(s).
 * Each point is stored as a pair of float x,y coordinates.
 * SEG_MOVETO and SEG_LINETO types will return one point,
 * SEG_QUADTO will return two points,
 * SEG_CUBICTO will return 3 points
 * and SEG_CLOSE will not return any points.
 *
 * @see PathIterator#SEG_MOVETO
 * @see PathIterator#SEG_LINETO
 * @see PathIterator#SEG_QUADTO
 * @see PathIterator#SEG_CUBICTO
 * @see PathIterator#SEG_CLOSE
 */
public int currentSegment(float[] coords) {
    int numCoords = 0;
    int type = 0;
    if ((index) == (path.size())) {
        // We only get here for closed paths
        if ((path.size()) > 1) {
            BezierPath.Node previous = path.get(((path.size()) - 1));
            BezierPath.Node current = path.get(0);
            if (((previous.mask) & (BezierPath.C2_MASK)) == 0) {
                if (((current.mask) & (BezierPath.C1_MASK)) == 0) {
                    numCoords = 1;
                    type = PathIterator.SEG_LINETO;
                    coords[0] = ((float) (current.x[0]));
                    coords[1] = ((float) (current.y[0]));
                } else {
                    numCoords = 2;
                    type = PathIterator.SEG_QUADTO;
                    coords[0] = ((float) (current.x[1]));
                    coords[1] = ((float) (current.y[1]));
                    coords[2] = ((float) (current.x[0]));
                    coords[3] = ((float) (current.y[0]));
                }
            } else {
                if (((current.mask) & (BezierPath.C1_MASK)) == 0) {
                    numCoords = 2;
                    type = PathIterator.SEG_QUADTO;
                    coords[0] = ((float) (previous.x[2]));
                    coords[1] = ((float) (previous.y[2]));
                    coords[2] = ((float) (current.x[0]));
                    coords[3] = ((float) (current.y[0]));
                } else {
                    numCoords = 3;
                    type = PathIterator.SEG_CUBICTO;
                    coords[0] = ((float) (previous.x[2]));
                    coords[1] = ((float) (previous.y[2]));
                    coords[2] = ((float) (current.x[1]));
                    coords[3] = ((float) (current.y[1]));
                    coords[4] = ((float) (current.x[0]));
                    coords[5] = ((float) (current.y[0]));
                }
            }
        }
    } else
        if ((index) > (path.size())) {
            // We only get here for closed paths
            return PathIterator.SEG_CLOSE;
        } else
            if ((index) == 0) {
                BezierPath.Node current = path.get(index);
                coords[0] = ((float) (current.x[0]));
                coords[1] = ((float) (current.y[0]));
                numCoords = 1;
                type = PathIterator.SEG_MOVETO;
            } else
                if ((index) < (path.size())) {
                    BezierPath.Node current = path.get(index);
                    BezierPath.Node previous = path.get(((index) - 1));
                    if (((previous.mask) & (BezierPath.C2_MASK)) == 0) {
                        if (((current.mask) & (BezierPath.C1_MASK)) == 0) {
                            numCoords = 1;
                            type = PathIterator.SEG_LINETO;
                            coords[0] = ((float) (current.x[0]));
                            coords[1] = ((float) (current.y[0]));
                        } else {
                            numCoords = 2;
                            type = PathIterator.SEG_QUADTO;
                            coords[0] = ((float) (current.x[1]));
                            coords[1] = ((float) (current.y[1]));
                            coords[2] = ((float) (current.x[0]));
                            coords[3] = ((float) (current.y[0]));
                        }
                    } else {
                        if (((current.mask) & (BezierPath.C1_MASK)) == 0) {
                            numCoords = 2;
                            type = PathIterator.SEG_QUADTO;
                            coords[0] = ((float) (previous.x[2]));
                            coords[1] = ((float) (previous.y[2]));
                            coords[2] = ((float) (current.x[0]));
                            coords[3] = ((float) (current.y[0]));
                        } else {
                            numCoords = 3;
                            type = PathIterator.SEG_CUBICTO;
                            coords[0] = ((float) (previous.x[2]));
                            coords[1] = ((float) (previous.y[2]));
                            coords[2] = ((float) (current.x[1]));
                            coords[3] = ((float) (current.y[1]));
                            coords[4] = ((float) (current.x[0]));
                            coords[5] = ((float) (current.y[0]));
                        }
                    }
                }



    if ((affine) != null) {
        affine.transform(coords, 0, coords, 0, numCoords);
    }
    return type;
}