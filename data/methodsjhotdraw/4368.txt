/**
 * Encodes a byte array into Base64 notation.
 * <p>
 * Valid options:<pre>
 *   GZIP: gzip-compresses object before encoding it.
 *   DONT_BREAK_LINES: dont break lines at 76 characters
 *     <i>Note: Technically, this makes your encoding non-compliant.</i>
 * </pre>
 * <p>
 * Example: <code>encodeBytes( myData, Base64.GZIP )</code> or
 * <p>
 * Example: <code>encodeBytes( myData, Base64.GZIP | Base64.DONT_BREAK_LINES )</code>
 *
 * @param source
 * 		The data to convert
 * @param off
 * 		Offset in array where conversion should begin
 * @param len
 * 		Length of data to convert
 * @param options
 * 		Specified options
 * @see Base64#GZIP
 * @see Base64#DONT_BREAK_LINES
 * @since 2.0
 */
public static String encodeBytes(byte[] source, int off, int len, int options) {
    // Isolate options
    int dontBreakLines = options & (Base64.DONT_BREAK_LINES);
    int gzip = options & (Base64.GZIP);
    // Compress?
    if (gzip == (Base64.GZIP)) {
        ByteArrayOutputStream baos = null;
        GZIPOutputStream gzos = null;
        Base64.OutputStream b64os = null;
        // end catch
        try {
            // GZip -> Base64 -> ByteArray
            baos = new ByteArrayOutputStream();
            b64os = new Base64.OutputStream(baos, ((Base64.ENCODE) | dontBreakLines));
            gzos = new GZIPOutputStream(b64os);
            gzos.write(source, off, len);
            gzos.close();
        }// end try
         catch (IOException e) {
            e.printStackTrace();
            return null;
        } finally {
            try {
                gzos.close();
            } catch (Exception e) {
            }
            try {
                b64os.close();
            } catch (Exception e) {
            }
            try {
                baos.close();
            } catch (Exception e) {
            }
        }// end finally

        // Return value according to relevant encoding.
        try {
            return new String(baos.toByteArray(), Base64.PREFERRED_ENCODING);
        }// end try
         catch (UnsupportedEncodingException uue) {
            return new String(baos.toByteArray());
        }// end catch

    }// end else: dont compress
     else // end if: compress
    // Else, dont compress. Better not to use streams at all then.
    {
        // Convert option to boolean in way that code likes it.
        boolean breakLines = dontBreakLines == 0;
        int len43 = (len * 4) / 3;
        byte[] outBuff = new byte[(len43// Main 4:3
         + ((len % 3) > 0 ? 4 : 0))// Account for padding
         + (breakLines ? len43 / (Base64.MAX_LINE_LENGTH) : 0)];// New lines

        int d = 0;
        int e = 0;
        int len2 = len - 2;
        int lineLength = 0;
        for (; d < len2; d += 3 , e += 4) {
            Base64.encode3to4(source, (d + off), 3, outBuff, e);
            lineLength += 4;
            if (breakLines && (lineLength == (Base64.MAX_LINE_LENGTH))) {
                outBuff[(e + 4)] = Base64.NEW_LINE;
                e++;
                lineLength = 0;
            }// end if: end of line

        }// en dfor: each piece of array

        if (d < len) {
            Base64.encode3to4(source, (d + off), (len - d), outBuff, e);
            e += 4;
        }// end if: some padding needed

        // Return value according to relevant encoding.
        try {
            return new String(outBuff, 0, e, Base64.PREFERRED_ENCODING);
        }// end try
         catch (UnsupportedEncodingException uue) {
            return new String(outBuff, 0, e);
        }// end catch

    }// end else: dont compress

}// end encodeBytes
