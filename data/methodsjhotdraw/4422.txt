/**
 * Parses the next token from the input stream of this tokenizer.
 * The type of the next token is returned in the <code>ttype</code>
 * field. Additional information about the token may be in the
 * <code>nval</code> field or the <code>sval</code> field of this
 * tokenizer.
 * <p>
 * Typical clients of this
 * class first set up the syntax tables and then sit in a loop
 * calling nextToken to parse successive tokens until TT_EOF
 * is returned.
 *
 * @return the value of the <code>ttype</code> field.
 * @exception IOException  if an I/O error occurs.
 * @see java.io.StreamTokenizer#nval
 * @see java.io.StreamTokenizer#sval
 * @see java.io.StreamTokenizer#ttype
 */
public int nextToken() throws IOException {
    if (pushedBack) {
        pushedBack = false;
        return ttype;
    }
    byte[] ct = ctype;
    sval = null;
    int c = peekc;
    if (c < 0)
        c = StreamPosTokenizer.NEED_CHAR;

    if (c == (StreamPosTokenizer.SKIP_LF)) {
        c = read();
        if (c < 0) {
            // rlw
            startpos = endpos = (readpos) - 1;
            return ttype = StreamPosTokenizer.TT_EOF;
        }
        if (c == 
)
            c = StreamPosTokenizer.NEED_CHAR;

    }
    if (c == (StreamPosTokenizer.NEED_CHAR)) {
        c = read();
        if (c < 0) {
            // rlw
            startpos = endpos = (readpos) - 1;
            return ttype = StreamPosTokenizer.TT_EOF;
        }
    }
    ttype = c;/* Just to be safe */

    /* Set peekc so that the next invocation of nextToken will read
    another character unless peekc is reset in this invocation
     */
    peekc = StreamPosTokenizer.NEED_CHAR;
    int ctype = (c < 256) ? ct[c] : StreamPosTokenizer.CT_ALPHA;
    while ((ctype & (StreamPosTokenizer.CT_WHITESPACE)) != 0) {
        if (c == ) {
            (lineno)++;
            if (eolIsSignificantP) {
                peekc = StreamPosTokenizer.SKIP_LF;
                // rlw
                startpos = endpos = (readpos) - 1;
                return ttype = StreamPosTokenizer.TT_EOL;
            }
            c = read();
            if (c == 
)
                c = read();

        } else {
            if (c == 
) {
                (lineno)++;
                if (eolIsSignificantP) {
                    // rlw
                    startpos = endpos = (readpos) - 1;
                    return ttype = StreamPosTokenizer.TT_EOL;
                }
            }
            c = read();
        }
        if (c < 0) {
            // rlw
            startpos = endpos = readpos;
            return ttype = StreamPosTokenizer.TT_EOF;
        }
        ctype = (c < 256) ? ct[c] : StreamPosTokenizer.CT_ALPHA;
    } 
    // rlw
    startpos = (readpos) - 1;
    // rlw hexadecimal
    hex : if ((((ctype & (StreamPosTokenizer.CT_DIGIT)) != 0) && (c == 0)) && (isParseHexNumbers)) {
        c = read();
        if (c == x) {
            int digits = 0;
            long hval = 0;
            while (digits < 16) {
                c = read();
                if ((c >= 0) && (c <= 9)) {
                    hval = (hval << 4) | (c - 0);
                } else
                    if ((c >= A) && (c <= F)) {
                        hval = (hval << 4) | ((c - A) + 10);
                    } else
                        if ((c >= a) && (c <= f)) {
                            hval = (hval << 4) | ((c - a) + 10);
                        } else {
                            unread(c);
                            if (digits == 0) {
                                sval = "0x";
                                endpos = (readpos) - 1;
                                return ttype = StreamPosTokenizer.TT_WORD;
                            } else {
                                nval = ((double) (hval));
                                endpos = (readpos) - 1;
                                return ttype = StreamPosTokenizer.TT_NUMBER;
                            }
                        }


                digits++;
            } 
            nval = ((double) (hval));
            endpos = (readpos) - 1;
            return ttype = StreamPosTokenizer.TT_NUMBER;
        } else {
            unread(c);
            c = 0;
        }
    }
    digit : if ((ctype & (StreamPosTokenizer.CT_DIGIT)) != 0) {
        int digits = 0;
        boolean neg = false;
        if (c == -) {
            c = read();
            if ((c != .) && ((c < 0) || (c > 9))) {
                peekc = c;
                // rlw
                if ((- & (StreamPosTokenizer.CT_ALPHA)) != 0) {
                    unread(c);
                    c = -;
                    break digit;
                } else {
                    endpos = (readpos) - 1;
                    return ttype = -;
                }
            }
            neg = true;
        } else
            if (c == +) {
                c = read();
                if ((c != .) && ((c < 0) || (c > 9))) {
                    peekc = c;
                    // rlw
                    if ((+ & (StreamPosTokenizer.CT_ALPHA)) != 0) {
                        unread(c);
                        c = +;
                        break digit;
                    } else {
                        endpos = (readpos) - 1;
                        return ttype = -;
                    }
                }
                neg = false;
            }

        double v = 0;
        int decexp = 0;
        int seendot = 0;
        while (true) {
            if ((c == .) && (seendot == 0))
                seendot = 1;
            else
                if ((0 <= c) && (c <= 9)) {
                    digits++;
                    v = (v * 10) + (c - 0);
                    decexp += seendot;
                } else
                    break;


            c = read();
        } 
        peekc = c;
        if (decexp != 0) {
            double denom = 10;
            decexp--;
            while (decexp > 0) {
                denom *= 10;
                decexp--;
            } 
            /* Do one division of a likely-to-be-more-accurate number */
            v = v / denom;
        }
        nval = (neg) ? -v : v;
        // rlw
        endpos = (c == (-1)) ? (readpos) - 1 : (readpos) - 2;
        if (digits == 0) {
            if ((. & (StreamPosTokenizer.CT_ALPHA)) != 0) {
                unread(c);
                if (neg) {
                    unread(.);
                    c = -;
                } else {
                    read();// consume full stop

                    c = .;
                }
                break digit;
            } else {
                return ttype = .;
            }
        } else {
            if (isParseExponents) {
                if ((c == E) || (c == e)) {
                    c = read();
                    digits = 0;
                    neg = false;
                    if (c == -) {
                        c = read();
                        if ((c < 0) || (c > 9)) {
                            unread(c);
                            unread(E);
                            return ttype = StreamPosTokenizer.TT_NUMBER;
                        }
                        neg = true;
                    }
                    v = 0;
                    decexp = 0;
                    while (true) {
                        if ((0 <= c) && (c <= 9)) {
                            digits++;
                            v = (v * 10) + (c - 0);
                        } else {
                            break;
                        }
                        c = read();
                    } 
                    peekc = c;
                    nval *= Math.pow(10, (neg ? -v : v));
                }
            }
            return ttype = StreamPosTokenizer.TT_NUMBER;
        }
    }
    if ((ctype & (StreamPosTokenizer.CT_ALPHA)) != 0) {
        int i = 0;
        do {
            if (i >= (buf.length)) {
                char[] nb = new char[(buf.length) * 2];
                System.arraycopy(buf, 0, nb, 0, buf.length);
                buf = nb;
            }
            buf[(i++)] = ((char) (c));
            c = read();
            ctype = (c < 0) ? StreamPosTokenizer.CT_WHITESPACE : c < 256 ? ct[c] : StreamPosTokenizer.CT_ALPHA;
        } while ((ctype & ((StreamPosTokenizer.CT_ALPHA) | (StreamPosTokenizer.CT_DIGIT))) != 0 );
        peekc = c;
        sval = String.copyValueOf(buf, 0, i);
        if (forceLower)
            sval = sval.toLowerCase();

        // rlw EOF must be treated specially
        endpos = (c == (-1)) ? (readpos) - 1 : (readpos) - 2;
        return ttype = StreamPosTokenizer.TT_WORD;
    }
    if ((ctype & (StreamPosTokenizer.CT_QUOTE)) != 0) {
        ttype = c;
        int i = 0;
        /* Invariants (because Octal needs a lookahead):
          (i)  c contains char value
          (ii) d contains the lookahead
         */
        int d = read();
        while ((((d >= 0) && (d != (ttype))) && (d != 
)) && (d != )) {
            if (d == \) {
                c = read();
                int first = c;/* To allow 377, but not 477 */

                if ((c >= 0) && (c <= 7)) {
                    c = c - 0;
                    int c2 = read();
                    if ((0 <= c2) && (c2 <= 7)) {
                        c = (c << 3) + (c2 - 0);
                        c2 = read();
                        if (((0 <= c2) && (c2 <= 7)) && (first <= 3)) {
                            c = (c << 3) + (c2 - 0);
                            d = read();
                        } else
                            d = c2;

                    } else
                        d = c2;

                } else {
                    switch (c) {
                        case a :
                            c = 7;
                            break;
                        case b :
                            c = ;
                            break;
                        case f :
                            c = 12;
                            break;
                        case n :
                            c = 
;
                            break;
                        case r :
                            c = ;
                            break;
                        case t :
                            c = 	;
                            break;
                        case v :
                            c = 11;
                            break;
                    }
                    d = read();
                }
            } else {
                c = d;
                d = read();
            }
            if (i >= (buf.length)) {
                char[] nb = new char[(buf.length) * 2];
                System.arraycopy(buf, 0, nb, 0, buf.length);
                buf = nb;
            }
            buf[(i++)] = ((char) (c));
        } 
        /* If we broke out of the loop because we found a matching quote
        character then arrange to read a new character next time
        around; otherwise, save the character.
         */
        peekc = (d == (ttype)) ? StreamPosTokenizer.NEED_CHAR : d;
        sval = String.copyValueOf(buf, 0, i);
        // rlw
        endpos = (readpos) - 2;
        return ttype;
    }
    /* rlw */
    /* if (c == / && (slashSlashCommentsP || slashStarCommentsP)) {
    c = read();
    if (c == * && slashStarCommentsP) {
    int prevc = 0;
    while ((c = read()) != / || prevc != *) {
    if (c == ) {
    lineno++;
    c = read();
    if (c == 
) {
    c = read();
    }
    } else {
    if (c == 
) {
    lineno++;
    c = read();
    }
    }
    if (c < 0) {
    endpos = readpos;
    return ttype = TT_EOF;
    }
    prevc = c;
    }
    return nextToken();
    } else if (c == / && slashSlashCommentsP) {
    while ((c = read()) != 
 && c !=  && c >= 0);
    peekc = c;
    return nextToken();
    } else {
    // Now see if it is still a single line comment
    if ((ct[/] & CT_COMMENT) != 0) {
    while ((c = read()) != 
 && c !=  && c >= 0);
    peekc = c;
    return nextToken();
    } else {
    peekc = c;
    // rlw
    endpos = readpos - 2;
    return ttype = /;
    }
    }
    }
     */
    if (((slashSlashCommentsP) && (c == (slashSlash[0]))) || ((slashStarCommentsP) && (c == (slashStar[0])))) {
        if ((c == (slashStar[0])) && ((slashStar.length) == 1)) {
            // This is the scanner code if the slashStar token
            // is one characters long
            while ((c = read()) != (starSlash[0])) {
                if (c == ) {
                    (lineno)++;
                    c = read();
                    if (c == 
) {
                        c = read();
                    }
                } else {
                    if (c == 
) {
                        (lineno)++;
                        c = read();
                    }
                }
                if (c < 0) {
                    endpos = readpos;
                    return ttype = StreamPosTokenizer.TT_EOF;
                }
            } 
            return nextToken();
        } else
            if ((c == (slashSlash[0])) && ((slashSlash.length) == 1)) {
                // This is the scanner code if the slashSlash token
                // is one characters long
                while ((((c = read()) != 
) && (c != )) && (c >= 0));
                peekc = c;
                return nextToken();
            } else {
                // This is the scanner code if the slashStar and the slashSlash
                // tokens are two characters long
                c = read();
                if ((c == (slashStar[1])) && (slashStarCommentsP)) {
                    int prevc = 0;
                    while (((c = read()) != (starSlash[1])) || (prevc != (starSlash[0]))) {
                        if (c == ) {
                            (lineno)++;
                            c = read();
                            if (c == 
) {
                                c = read();
                            }
                        } else {
                            if (c == 
) {
                                (lineno)++;
                                c = read();
                            }
                        }
                        if (c < 0) {
                            endpos = readpos;
                            return ttype = StreamPosTokenizer.TT_EOF;
                        }
                        prevc = c;
                    } 
                    return nextToken();
                } else
                    if ((c == (slashSlash[1])) && (slashSlashCommentsP)) {
                        while ((((c = read()) != 
) && (c != )) && (c >= 0));
                        peekc = c;
                        return nextToken();
                    } else {
                        // Now see if it is still a single line comment
                        if (((ct[slashSlash[0]]) & (StreamPosTokenizer.CT_COMMENT)) != 0) {
                            while ((((c = read()) != 
) && (c != )) && (c >= 0));
                            peekc = c;
                            return nextToken();
                        } else {
                            peekc = c;
                            // rlw
                            endpos = (readpos) - 2;
                            return ttype = slashSlash[0];
                        }
                    }

            }

    }
    if ((ctype & (StreamPosTokenizer.CT_COMMENT)) != 0) {
        while ((((c = read()) != 
) && (c != )) && (c >= 0));
        peekc = c;
        return nextToken();
    }
    // rlw
    endpos = (readpos) - 1;
    return ttype = c;
}