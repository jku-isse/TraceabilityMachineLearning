/**
 * Computes the convex hull from a set of points.
 *
 * @param points
 * 		
 * @return convex hull of the points
 */
public static Point[] getConvexHull(Point[] points) {
    // Quickly return if no work is needed
    if ((points.length) < 3) {
        return points.clone();
    }
    // Sort points from left to right O(n log n)
    Point[] sorted = points.clone();
    Arrays.sort(sorted, new Comparator<Point>() {
        public int compare(Point o1, Point o2) {
            int v = (o1.x) - (o2.x);
            return v == 0 ? (o1.y) - (o2.y) : v;
        }
    });
    Point[] hull = new Point[(sorted.length) + 2];
    // Process upper part of convex hull O(n)
    int upper = 0;// Number of points in upper part of convex hull

    hull[(upper++)] = sorted[0];
    hull[(upper++)] = sorted[1];
    for (int i = 2; i < (sorted.length); i++) {
        hull[(upper++)] = sorted[i];
        while ((upper > 2) && (!(ConvexHull.isRightTurn(hull[(upper - 3)], hull[(upper - 2)], hull[(upper - 1)])))) {
            hull[(upper - 2)] = hull[(upper - 1)];
            upper--;
        } 
    }
    // Process lower part of convex hull O(n)
    int lower = upper;// (lower - number + 1) = number of points in the lower part of the convex hull

    hull[(lower++)] = sorted[((sorted.length) - 2)];
    for (int i = (sorted.length) - 3; i >= 0; i--) {
        hull[(lower++)] = sorted[i];
        while (((lower - upper) > 1) && (!(ConvexHull.isRightTurn(hull[(lower - 3)], hull[(lower - 2)], hull[(lower - 1)])))) {
            hull[(lower - 2)] = hull[(lower - 1)];
            lower--;
        } 
    }
    lower -= 1;
    // Reduce array
    Point[] convexHull = new Point[lower];
    System.arraycopy(hull, 0, convexHull, 0, lower);
    return convexHull;
}