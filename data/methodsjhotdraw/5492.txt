/**
 * Appends a paragraph of text at the specified y location and returns
 * the bounds of the paragraph.
 *
 * @param shape
 * 		Shape to which to add the glyphs of the paragraph. This
 * 		parameter is null, if we only want to measure the size of the paragraph.
 * @param styledText
 * 		the text of the paragraph.
 * @param verticalPos
 * 		the top bound of the paragraph
 * @param maxVerticalPos
 * 		the bottom bound of the paragraph
 * @param leftMargin
 * 		the left bound of the paragraph
 * @param rightMargin
 * 		the right bound of the paragraph
 * @param tabStops
 * 		an array with tab stops
 * @param tabCounts
 * 		the number of entries in tabStops which contain actual
 * 		values
 * @return Returns the actual bounds of the paragraph.
 */
private Rectangle2D.Double appendParagraph(GeneralPath shape, AttributedCharacterIterator styledText, float verticalPos, float maxVerticalPos, float leftMargin, float rightMargin, float[] tabStops, int tabCount) {
    // assume styledText is an AttributedCharacterIterator, and the number
    // of tabs in styledText is tabCount
    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);
    int[] tabLocations = new int[tabCount + 1];
    int i = 0;
    for (char c = styledText.first(); c != (styledText.DONE); c = styledText.next()) {
        if (c == 	) {
            tabLocations[(i++)] = styledText.getIndex();
        }
    }
    tabLocations[tabCount] = (styledText.getEndIndex()) - 1;
    // Now tabLocations has an entry for every tabs offset in
    // the text.  For convenience, the last entry is tabLocations
    // is the offset of the last character in the text.
    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());
    int currentTab = 0;
    while ((measurer.getPosition()) < (styledText.getEndIndex())) {
        // Lay out and draw each line.  All segments on a line
        // must be computed before any drawing can occur, since
        // we must know the largest ascent on the line.
        // TextLayouts are computed and stored in a List;
        // their horizontal positions are stored in a parallel
        // List.
        // lineContainsText is true after first segment is drawn
        boolean lineContainsText = false;
        boolean lineComplete = false;
        float maxAscent = 0;
        float maxDescent = 0;
        float horizontalPos = leftMargin;
        LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();
        LinkedList<Float> penPositions = new LinkedList<Float>();
        while (!lineComplete) {
            float wrappingWidth = rightMargin - horizontalPos;
            TextLayout layout = null;
            layout = measurer.nextLayout(wrappingWidth, ((tabLocations[currentTab]) + 1), lineContainsText);
            // layout can be null if lineContainsText is true
            if (layout != null) {
                layouts.add(layout);
                penPositions.add(horizontalPos);
                horizontalPos += layout.getAdvance();
                maxAscent = Math.max(maxAscent, layout.getAscent());
                maxDescent = Math.max(maxDescent, ((layout.getDescent()) + (layout.getLeading())));
            } else {
                lineComplete = true;
            }
            lineContainsText = true;
            if ((measurer.getPosition()) == ((tabLocations[currentTab]) + 1)) {
                currentTab++;
            }
            if ((measurer.getPosition()) == (styledText.getEndIndex())) {
                lineComplete = true;
            } else
                if (((tabStops.length) == 0) || (horizontalPos >= (tabStops[((tabStops.length) - 1)]))) {
                    lineComplete = true;
                }

            if (!lineComplete) {
                // move to next tab stop
                int j;
                for (j = 0; horizontalPos >= (tabStops[j]); j++) {
                }
                horizontalPos = tabStops[j];
            }
        } 
        verticalPos += maxAscent;
        if (verticalPos > maxVerticalPos) {
            break;
        }
        Iterator<TextLayout> layoutEnum = layouts.iterator();
        Iterator<Float> positionEnum = penPositions.iterator();
        // now iterate through layouts and draw them
        while (layoutEnum.hasNext()) {
            TextLayout nextLayout = layoutEnum.next();
            float nextPosition = positionEnum.next();
            AffineTransform tx = new AffineTransform();
            tx.translate(nextPosition, verticalPos);
            if (shape != null) {
                Shape outline = nextLayout.getOutline(tx);
                shape.append(outline, false);
            }
            Rectangle2D layoutBounds = nextLayout.getBounds();
            paragraphBounds.add(new Rectangle2D.Double(((layoutBounds.getX()) + nextPosition), ((layoutBounds.getY()) + verticalPos), layoutBounds.getWidth(), layoutBounds.getHeight()));
        } 
        verticalPos += maxDescent;
    } 
    return paragraphBounds;
}