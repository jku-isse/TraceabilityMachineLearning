// ------------
// Attributes
// ------------
/* Writes shape attributes. */
protected void writeShapeAttributes(IXMLElement elem, Map<AttributeKey, Object> f) throws IOException {
    Color color;
    String value;
    int intValue;
    // color
    // Value:  	<color> | inherit
    // Initial:  	 depends on user agent
    // Applies to:  	None. Indirectly affects other properties via currentColor
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified <color> value, except inherit
    // 
    // Nothing to do: Attribute color is not needed.
    // color-rendering
    // Value:  	 auto | optimizeSpeed | optimizeQuality | inherit
    // Initial:  	 auto
    // Applies to:  	 container elements , graphics elements and animateColor
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    // 
    // Nothing to do: Attribute color-rendering is not needed.
    // fill
    // Value:  	<paint> | inherit (See Specifying paint)
    // Initial:  	 black
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 "none", system paint, specified <color> value or absolute IRI
    Gradient gradient = SVGAttributeKeys.FILL_GRADIENT.get(f);
    if (gradient != null) {
        String id;
        if (gradientToIDMap.containsKey(gradient)) {
            id = gradientToIDMap.get(gradient);
        } else {
            IXMLElement gradientElem;
            if (gradient instanceof LinearGradient) {
                LinearGradient lg = ((LinearGradient) (gradient));
                gradientElem = createLinearGradient(document, lg.getX1(), lg.getY1(), lg.getX2(), lg.getY2(), lg.getStopOffsets(), lg.getStopColors(), lg.getStopOpacities(), lg.isRelativeToFigureBounds(), lg.getTransform());
            } else {
                RadialGradient rg = ((RadialGradient) (gradient));
                gradientElem = createRadialGradient(document, rg.getCX(), rg.getCY(), rg.getFX(), rg.getFY(), rg.getR(), rg.getStopOffsets(), rg.getStopColors(), rg.getStopOpacities(), rg.isRelativeToFigureBounds(), rg.getTransform());
            }
            id = getId(gradientElem);
            gradientElem.setAttribute("id", "xml", id);
            defs.addChild(gradientElem);
            gradientToIDMap.put(gradient, id);
        }
        writeAttribute(elem, "fill", (("url(#" + id) + ")"), "#000");
    } else {
        writeAttribute(elem, "fill", SVGOutputFormat.toColor(AttributeKeys.FILL_COLOR.get(f)), "#000");
    }
    // fill-opacity
    // Value:  	 <opacity-value> | inherit
    // Initial:  	 1
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    writeAttribute(elem, "fill-opacity", SVGAttributeKeys.FILL_OPACITY.get(f), 1.0);
    // fill-rule
    // Value:	 nonzero | evenodd | inherit
    // Initial: 	 nonzero
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    if ((AttributeKeys.WINDING_RULE.get(f)) != (AttributeKeys.WindingRule.NON_ZERO)) {
        writeAttribute(elem, "fill-rule", "evenodd", "nonzero");
    }
    // stroke
    // Value:  	<paint> | inherit (See Specifying paint)
    // Initial:  	 none
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 "none", system paint, specified <color> value
    // or absolute IRI
    gradient = SVGAttributeKeys.STROKE_GRADIENT.get(f);
    if (gradient != null) {
        String id;
        if (gradientToIDMap.containsKey(gradient)) {
            id = gradientToIDMap.get(gradient);
        } else {
            IXMLElement gradientElem;
            if (gradient instanceof LinearGradient) {
                LinearGradient lg = ((LinearGradient) (gradient));
                gradientElem = createLinearGradient(document, lg.getX1(), lg.getY1(), lg.getX2(), lg.getY2(), lg.getStopOffsets(), lg.getStopColors(), lg.getStopOpacities(), lg.isRelativeToFigureBounds(), lg.getTransform());
            } else {
                RadialGradient rg = ((RadialGradient) (gradient));
                gradientElem = createRadialGradient(document, rg.getCX(), rg.getCY(), rg.getFX(), rg.getFY(), rg.getR(), rg.getStopOffsets(), rg.getStopColors(), rg.getStopOpacities(), rg.isRelativeToFigureBounds(), rg.getTransform());
            }
            id = getId(gradientElem);
            gradientElem.setAttribute("id", "xml", id);
            defs.addChild(gradientElem);
            gradientToIDMap.put(gradient, id);
        }
        writeAttribute(elem, "stroke", (("url(#" + id) + ")"), "none");
    } else {
        writeAttribute(elem, "stroke", SVGOutputFormat.toColor(AttributeKeys.STROKE_COLOR.get(f)), "none");
    }
    // stroke-dasharray
    // Value:  	 none | <dasharray> | inherit
    // Initial:  	 none
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes (non-additive)
    // Computed value:  	 Specified value, except inherit
    double[] dashes = AttributeKeys.STROKE_DASHES.get(f);
    if (dashes != null) {
        StringBuilder buf = new StringBuilder();
        for (int i = 0; i < (dashes.length); i++) {
            if (i != 0) {
                buf.append(,);
            }
            buf.append(SVGOutputFormat.toNumber(dashes[i]));
        }
        writeAttribute(elem, "stroke-dasharray", buf.toString(), null);
    }
    // stroke-dashoffset
    // Value:  	<length> | inherit
    // Initial:  	 0
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    writeAttribute(elem, "stroke-dashoffset", AttributeKeys.STROKE_DASH_PHASE.get(f), 0.0);
    // stroke-linecap
    // Value:  	 butt | round | square | inherit
    // Initial:  	 butt
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    writeAttribute(elem, "stroke-linecap", SVGOutputFormat.strokeLinecapMap.get(AttributeKeys.STROKE_CAP.get(f)), "butt");
    // stroke-linejoin
    // Value:  	 miter | round | bevel | inherit
    // Initial:  	 miter
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    writeAttribute(elem, "stroke-linejoin", SVGOutputFormat.strokeLinejoinMap.get(AttributeKeys.STROKE_JOIN.get(f)), "miter");
    // stroke-miterlimit
    // Value:  	 <miterlimit> | inherit
    // Initial:  	 4
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    writeAttribute(elem, "stroke-miterlimit", AttributeKeys.STROKE_MITER_LIMIT.get(f), 4.0);
    // stroke-opacity
    // Value:  	 <opacity-value> | inherit
    // Initial:  	 1
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    writeAttribute(elem, "stroke-opacity", SVGAttributeKeys.STROKE_OPACITY.get(f), 1.0);
    // stroke-width
    // Value:  	<length> | inherit
    // Initial:  	 1
    // Applies to:  	 shapes and text content elements
    // Inherited:  	 yes
    // Percentages:  	 N/A
    // Media:  	 visual
    // Animatable:  	 yes
    // Computed value:  	 Specified value, except inherit
    writeAttribute(elem, "stroke-width", AttributeKeys.STROKE_WIDTH.get(f), 1.0);
}