/**
 * Creates a BufferedImage from the specified list of figures.
 * <p>
 * The images are drawn using the specified scale factor. If some figures
 * have a drawing area located at negative coordinates, then the drawing
 * coordinates are translated, so that all figures are visible on the
 * image.
 *
 * @param drawing
 * 		The drawing.
 * @param figures
 * 		A list of figures of the drawing.
 * @param scaleFactor
 * 		The scale factor used when drawing the figures.
 * @param clipToFigures
 * 		If this is true, the image is clipped to the figures.
 * 		If this is false, the image includes the drawing area,
 */
public BufferedImage toImage(Drawing drawing, List<Figure> figures, double scaleFactor, boolean clipToFigures) {
    // Determine the draw bounds of the figures
    Rectangle2D.Double drawBounds = null;
    for (Figure f : figures) {
        if (drawBounds == null) {
            drawBounds = f.getDrawingArea();
        } else {
            drawBounds.add(f.getDrawingArea());
        }
    }
    if (clipToFigures) {
        AffineTransform transform = new AffineTransform();
        transform.translate(((-(drawBounds.x)) * scaleFactor), ((-(drawBounds.y)) * scaleFactor));
        transform.scale(scaleFactor, scaleFactor);
        return toImage(drawing, figures, transform, new Dimension(((int) ((drawBounds.width) * scaleFactor)), ((int) ((drawBounds.height) * scaleFactor))));
    } else {
        AffineTransform transform = new AffineTransform();
        if ((drawBounds.x) < 0) {
            transform.translate(((-(drawBounds.x)) * scaleFactor), 0);
        }
        if ((drawBounds.y) < 0) {
            transform.translate(0, ((-(drawBounds.y)) * scaleFactor));
        }
        transform.scale(scaleFactor, scaleFactor);
        return toImage(drawing, figures, transform, new Dimension(((int) (((Math.max(0, drawBounds.x)) + (drawBounds.width)) * scaleFactor)), ((int) (((Math.max(0, drawBounds.y)) + (drawBounds.height)) * scaleFactor))));
    }
}