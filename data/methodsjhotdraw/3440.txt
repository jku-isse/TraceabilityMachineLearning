/**
 * Computes the convex hull from a set of points.
 *
 * @param points
 * 		
 * @return convex hull of the points
 */
public static Point2D.Double[] getConvexHull2D(Point2D.Double[] points) {
    // Quickly return if no work is needed
    if ((points.length) < 3) {
        return points.clone();
    }
    // Sort points from left to right O(n log n)
    Point2D.Double[] sorted = points.clone();
    Arrays.sort(sorted, new Comparator<Point2D.Double>() {
        public int compare(Point2D.Double o1, Point2D.Double o2) {
            double v = (o1.x) - (o2.x);
            if (v == 0) {
                v = (o1.y) - (o2.y);
            }
            return v > 0 ? 1 : v < 0 ? -1 : 0;
        }
    });
    Point2D.Double[] hull = new Point2D.Double[(sorted.length) + 2];
    // Process upper part of convex hull O(n)
    int upper = 0;// Number of points in upper part of convex hull

    hull[(upper++)] = sorted[0];
    hull[(upper++)] = sorted[1];
    for (int i = 2; i < (sorted.length); i++) {
        hull[(upper++)] = sorted[i];
        while ((upper > 2) && (!(ConvexHull.isRightTurn2D(hull[(upper - 3)], hull[(upper - 2)], hull[(upper - 1)])))) {
            hull[(upper - 2)] = hull[(upper - 1)];
            upper--;
        } 
    }
    // Process lower part of convex hull O(n)
    int lower = upper;// (lower - number + 1) = number of points in the lower part of the convex hull

    hull[(lower++)] = sorted[((sorted.length) - 2)];
    for (int i = (sorted.length) - 3; i >= 0; i--) {
        hull[(lower++)] = sorted[i];
        while (((lower - upper) > 1) && (!(ConvexHull.isRightTurn2D(hull[(lower - 3)], hull[(lower - 2)], hull[(lower - 1)])))) {
            hull[(lower - 2)] = hull[(lower - 1)];
            lower--;
        } 
    }
    lower -= 1;
    // Reduce array
    Point2D.Double[] convexHull = new Point2D.Double[lower];
    System.arraycopy(hull, 0, convexHull, 0, lower);
    return convexHull;
}