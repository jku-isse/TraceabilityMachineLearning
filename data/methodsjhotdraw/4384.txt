/**
 * Writes the byte to the output stream after
 * converting to/from Base64 notation.
 * When encoding, bytes are buffered three
 * at a time before the output stream actually
 * gets a write() call.
 * When decoding, bytes are buffered four
 * at a time.
 *
 * @param theByte
 * 		the byte to write
 * @since 1.3
 */
public void write(int theByte) throws IOException {
    // Encoding suspended?
    if (suspendEncoding) {
        super.out.write(theByte);
        return;
    }// end if: supsended

    // Encode?
    if (encode) {
        buffer[((position)++)] = ((byte) (theByte));
        // Enough to encode.
        if ((position) >= (bufferLength)) {
            out.write(Base64.encode3to4(b4, buffer, bufferLength));
            lineLength += 4;
            if ((breakLines) && ((lineLength) >= (Base64.MAX_LINE_LENGTH))) {
                out.write(Base64.NEW_LINE);
                lineLength = 0;
            }// end if: end of line

            position = 0;
        }// end if: enough to output

    }// end else: decoding
     else // end if: encoding
    // Else, Decoding
    {
        // Meaningful Base64 character?
        if ((Base64.DECODABET[(theByte & 127)]) > (Base64.WHITE_SPACE_ENC)) {
            buffer[((position)++)] = ((byte) (theByte));
            // Enough to output.
            if ((position) >= (bufferLength)) {
                int len = Base64.decode4to3(buffer, 0, b4, 0);
                out.write(b4, 0, len);
                // out.write( Base64.decode4to3( buffer ) );
                position = 0;
            }// end if: enough to output

        }// end else: not white space either
         else// end if: meaningful base64 character

            if ((Base64.DECODABET[(theByte & 127)]) != (Base64.WHITE_SPACE_ENC)) {
                throw new IOException("Invalid character in Base64 data.");
            }
        // end else: not white space either

    }// end else: decoding

}// end write
