/**
 * Writes the <code>shape</code>, <code>coords</code>, <code>href</code>,
 * <code>nohref</code> Attribute for the specified figure and ellipse.
 *
 * @return Returns true, if the circle is inside of the image bounds.
 */
private boolean writeCircleAttributes(IXMLElement elem, SVGFigure f, Ellipse2D.Double ellipse) {
    AffineTransform t = AttributeKeys.TRANSFORM.getClone(f);
    if (t == null) {
        t = drawingTransform;
    } else {
        t.preConcatenate(drawingTransform);
    }
    if ((((t.getType()) & ((AffineTransform.TYPE_UNIFORM_SCALE) | (AffineTransform.TYPE_TRANSLATION))) == (t.getType())) && ((ellipse.width) == (ellipse.height))) {
        Point2D.Double start = new Point2D.Double(ellipse.x, ellipse.y);
        Point2D.Double end = new Point2D.Double(((ellipse.x) + (ellipse.width)), ((ellipse.y) + (ellipse.height)));
        t.transform(start, start);
        t.transform(end, end);
        ellipse.x = Math.min(start.x, end.x);
        ellipse.y = Math.min(start.y, end.y);
        ellipse.width = Math.abs(((start.x) - (end.x)));
        ellipse.height = Math.abs(((start.y) - (end.y)));
        elem.setAttribute("shape", "circle");
        elem.setAttribute("coords", ((((((int) ((ellipse.x) + ((ellipse.width) / 2.0))) + ",") + ((int) ((ellipse.y) + ((ellipse.height) / 2.0)))) + ",") + ((int) ((ellipse.width) / 2.0))));
        writeHrefAttribute(elem, f);
        return bounds.intersects(ellipse.getBounds());
    } else {
        return writePolyAttributes(elem, f, ((Shape) (ellipse)));
    }
}