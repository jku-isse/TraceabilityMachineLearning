/**
 * Draws or measures a paragraph of text at the specified y location and
 * the bounds of the paragraph.
 *
 * @param g
 * 		Graphics object. This parameter is null, if we want to
 * 		measure the size of the paragraph.
 * @param styledText
 * 		the text of the paragraph.
 * @param verticalPos
 * 		the top bound of the paragraph
 * @param maxVerticalPos
 * 		the bottom bound of the paragraph
 * @param leftMargin
 * 		the left bound of the paragraph
 * @param rightMargin
 * 		the right bound of the paragraph
 * @param tabStops
 * 		an array with tab stops
 * @param tabCounts
 * 		the number of entries in tabStops which contain actual
 * 		values
 * @return Returns the actual bounds of the paragraph.
 */
private Rectangle2D.Double drawParagraph(Graphics2D g, AttributedCharacterIterator styledText, float verticalPos, float maxVerticalPos, float leftMargin, float rightMargin, float[] tabStops, int tabCount) {
    // This method is based on the code sample given
    // in the class comment of java.awt.font.LineBreakMeasurer,
    // assume styledText is an AttributedCharacterIterator, and the number
    // of tabs in styledText is tabCount
    Rectangle2D.Double paragraphBounds = new Rectangle2D.Double(leftMargin, verticalPos, 0, 0);
    int[] tabLocations = new int[tabCount + 1];
    int i = 0;
    for (char c = styledText.first(); c != (styledText.DONE); c = styledText.next()) {
        if (c == 	) {
            tabLocations[(i++)] = styledText.getIndex();
        }
    }
    tabLocations[tabCount] = (styledText.getEndIndex()) - 1;
    // Now tabLocations has an entry for every tabs offset in
    // the text.  For convenience, the last entry is tabLocations
    // is the offset of the last character in the text.
    LineBreakMeasurer measurer = new LineBreakMeasurer(styledText, getFontRenderContext());
    int currentTab = 0;
    while (((measurer.getPosition()) < (styledText.getEndIndex())) && (verticalPos <= maxVerticalPos)) {
        // Lay out and draw each line.  All segments on a line
        // must be computed before any drawing can occur, since
        // we must know the largest ascent on the line.
        // TextLayouts are computed and stored in a List;
        // their horizontal positions are stored in a parallel
        // List.
        // lineContainsText is true after first segment is drawn
        boolean lineContainsText = false;
        boolean lineComplete = false;
        float maxAscent = 0;
        float maxDescent = 0;
        float horizontalPos = leftMargin;
        LinkedList<TextLayout> layouts = new LinkedList<TextLayout>();
        LinkedList<Float> penPositions = new LinkedList<Float>();
        int first = layouts.size();
        while ((!lineComplete) && (verticalPos <= maxVerticalPos)) {
            float wrappingWidth = rightMargin - horizontalPos;
            TextLayout layout = null;
            layout = measurer.nextLayout(wrappingWidth, ((tabLocations[currentTab]) + 1), lineContainsText);
            // layout can be null if lineContainsText is true
            if (layout != null) {
                layouts.add(layout);
                penPositions.add(horizontalPos);
                horizontalPos += layout.getAdvance();
                maxAscent = Math.max(maxAscent, layout.getAscent());
                maxDescent = Math.max(maxDescent, ((layout.getDescent()) + (layout.getLeading())));
            } else {
                lineComplete = true;
            }
            lineContainsText = true;
            if ((measurer.getPosition()) == ((tabLocations[currentTab]) + 1)) {
                currentTab++;
            }
            if ((measurer.getPosition()) == (styledText.getEndIndex())) {
                lineComplete = true;
            } else
                if (((tabStops.length) == 0) || (horizontalPos >= (tabStops[((tabStops.length) - 1)]))) {
                    lineComplete = true;
                }

            if (!lineComplete) {
                // move to next tab stop
                int j;
                for (j = 0; horizontalPos >= (tabStops[j]); j++) {
                }
                horizontalPos = tabStops[j];
            }
        } 
        // If there is only one layout element on the line, and we are
        // drawing, then honor alignemnt
        if ((first == ((layouts.size()) - 1)) && (g != null)) {
            switch (AttributeKeys.TEXT_ALIGNMENT.get(this)) {
                case TRAILING :
                    penPositions.set(first, ((rightMargin - (layouts.get(first).getVisibleAdvance())) - 1));
                    break;
                case CENTER :
                    penPositions.set(first, (((((rightMargin - 1) - leftMargin) - (layouts.get(first).getVisibleAdvance())) / 2) + leftMargin));
                    break;
                case BLOCK :
                    // not supported
                    break;
                case LEADING :
                default :
                    break;
            }
        }
        verticalPos += maxAscent;
        Iterator<TextLayout> layoutEnum = layouts.iterator();
        Iterator<Float> positionEnum = penPositions.iterator();
        // now iterate through layouts and draw them
        while (layoutEnum.hasNext()) {
            TextLayout nextLayout = layoutEnum.next();
            float nextPosition = positionEnum.next();
            if (g != null) {
                nextLayout.draw(g, nextPosition, verticalPos);
            }
            Rectangle2D layoutBounds = nextLayout.getBounds();
            paragraphBounds.add(new Rectangle2D.Double(((layoutBounds.getX()) + nextPosition), ((layoutBounds.getY()) + verticalPos), layoutBounds.getWidth(), layoutBounds.getHeight()));
        } 
        verticalPos += maxDescent;
    } 
    return paragraphBounds;
}